 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 170
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 1-25-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Packet Structure
 0000           ; // ----------------
 0000           ; // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.  Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // MODULE LENGTH DEFINES
 0000           ; // These defines are for the upstream and downstream lengths of the modules.
 0000           ; // These lengths are represented by two bytes for a maximum value of 65535.
 0000           ; // The lengths are sent as hundredths of millimeters and normalized later to floats.
 0000           ; // Therefore, the maximum length up or down the module is 655.35 mm.
 0000           ; // Examples: MSB=0,LSB=100,total=1 mm MSB=1,LSB=0,total=2.56 mm
 0000           ; #define               UPSTREAM_MSB                            (19)    // The MSB of the length from the center to the upper edge.
 0000           ; #define               UPSTREAM_LSB                            (136)   // The LSB of the length from the center to the upper edge.
 0000           ; #define               DOWNSTREAM_MSB                          (19)    // The MSB of the length from the center to the lower edge.
 0000           ; #define               DOWNSTREAM_LSB                          (136)   // The LSB of the length from the center to the lower edge.
 0000           ; 
 0000           ; // These define the angle offset where the module is centered.
 0000           ; // This value can be read by the external computing source and noted for kinematic solving.
 0000           ; #define               ANGLE_OFFSET_MSB                        (1)             // The MSB of the angle offset for module center.
 0000           ; #define               ANGLE_OFFSET_LSB                        (255)   // The LSB of the angle offset for module center.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type.  These are the only
 0000           ; // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
 0000           ; // This will be the amount of iterations we do after the last byte has been received as well.
 0000           ; #define               RESPONSE_ITERATIONS                     (10)
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations.  This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function sends out an acknowledgement of a configuration reset.
 0000           ; void configCleared(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 172
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 173
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 174
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 175
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 176
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 177
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 179
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 181
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 184
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C0FC8            xcall _servoBootWait
 0035                   .dbline 187
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0CFD            xcall _servoFinder
 0038 8012              xjmp L3
 003A           L2:
 003A                   .dbline 191
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 192
 003A           ;               if(commandReady())
 003A 9282              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A003              jz L5
 0049           X1:
 0049                   .dbline 193
 0049           ;               {
 0049                   .dbline 195
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 9655              xcall _takeAction
 004B                   .dbline 196
 004B           ;               }
 004B           L5:
 004B                   .dbline 197
 004B           ;       }
 004B           L3:
 004B                   .dbline 190
 004B 8FEE              xjmp L2
 004D           X0:
 004D                   .dbline -2
 004D           L1:
 004D                   .dbline 0 ; func end
 004D 8FFF              jmp .
 004F                   .dbend
 004F                   .dbfunc e sayHello _sayHello fV
 004F           _sayHello::
 004F                   .dbline -1
 004F                   .dbline 202
 004F           ; }
 004F           ; 
 004F           ; // This function transmits a response to a hello command from the master.
 004F           ; void sayHello(void)
 004F           ; {     
 004F                   .dbline 203
 004F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004F 5000              mov A,0
 0051 08                push A
 0052 5002              mov A,2
 0054 08                push A
 0055 905D              xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 206
 0059           ;       
 0059           ;       // Transmit a hello response to the master node.
 0059           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TX_014_PutChar
 005F 20                pop X
 0060                   .dbline 207
 0060           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TX_014_PutChar
 0066 20                pop X
 0067                   .dbline 208
 0067           ;       TX_014_PutChar(ID);                             // My ID (source)
 0067 10                push X
 0068 62D000            mov REG[0xd0],>_ID
 006B 5100              mov A,[_ID]
 006D 7C0000            xcall _TX_014_PutChar
 0070 20                pop X
 0071                   .dbline 209
 0071           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0071 10                push X
 0072 5000              mov A,0
 0074 7C0000            xcall _TX_014_PutChar
 0077 20                pop X
 0078                   .dbline 210
 0078           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0078 10                push X
 0079 50C8              mov A,-56
 007B 7C0000            xcall _TX_014_PutChar
 007E 20                pop X
 007F                   .dbline 211
 007F           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007F 10                push X
 0080 62D000            mov REG[0xd0],>_CHILD
 0083 5100              mov A,[_CHILD]
 0085 7C0000            xcall _TX_014_PutChar
 0088 20                pop X
 0089                   .dbline 212
 0089           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0089 10                push X
 008A 50FD              mov A,-3
 008C 7C0000            xcall _TX_014_PutChar
 008F 20                pop X
 0090                   .dbline 213
 0090           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0090 10                push X
 0091 50FD              mov A,-3
 0093 7C0000            xcall _TX_014_PutChar
 0096 20                pop X
 0097           L8:
 0097                   .dbline 216
 0097           ;       
 0097           ;       // Wait for the transmission to finish.
 0097           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0097           L9:
 0097                   .dbline 216
 0097 10                push X
 0098 7C0000            xcall _TX_014_bReadTxStatus
 009B 62D000            mov REG[0xd0],>__r0
 009E 20                pop X
 009F 5300              mov [__r0],A
 00A1 470020            tst [__r0],32
 00A4 AFF2              jz L8
 00A6                   .dbline 219
 00A6           ;       
 00A6           ;       // Make completely sure we're done.
 00A6           ;       xmitWait();
 00A6 7C0FA9            xcall _xmitWait
 00A9                   .dbline 221
 00A9           ; 
 00A9           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A9 5000              mov A,0
 00AB 08                push A
 00AC 5001              mov A,1
 00AE 08                push A
 00AF 9003              xcall _configToggle
 00B1 38FE              add SP,-2
 00B3                   .dbline -2
 00B3           L7:
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e configToggle _configToggle fV
 00B4           ;           mode -> X-5
 00B4           _configToggle::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6                   .dbline 227
 00B6           ; }
 00B6           ; 
 00B6           ; // This function receives a mode flag and switches the microcontroller to the
 00B6           ; // desired hardware configuration.
 00B6           ; void configToggle(int mode)
 00B6           ; {     
 00B6                   .dbline 230
 00B6           ;       // Set the pins high and disconnect from the global bus.
 00B6           ;       // This keeps false start bits from happening while we swap configs.
 00B6           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B6 43001F            or REG[0],31
 00B9                   .dbline 231
 00B9           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B9 4102E0            and REG[0x2],-32
 00BC                   .dbline 235
 00BC           ;       
 00BC           ;       // Unload the configuration of the current state.
 00BC           ;       // If there is no state, blindly wipe all configurations.
 00BC           ;       if(STATE)
 00BC 62D000            mov REG[0xd0],>_STATE
 00BF 3C0000            cmp [_STATE],0
 00C2 B006              jnz X2
 00C4 3C0100            cmp [_STATE+1],0
 00C7 A011              jz L12
 00C9           X2:
 00C9                   .dbline 236
 00C9           ;       {
 00C9                   .dbline 237
 00C9           ;               unloadConfig(STATE);
 00C9 62D000            mov REG[0xd0],>_STATE
 00CC 5100              mov A,[_STATE]
 00CE 08                push A
 00CF 5101              mov A,[_STATE+1]
 00D1 08                push A
 00D2 7C0A95            xcall _unloadConfig
 00D5 38FE              add SP,-2
 00D7                   .dbline 238
 00D7           ;       }
 00D7 8004              xjmp L13
 00D9           L12:
 00D9                   .dbline 240
 00D9           ;       else
 00D9           ;       {
 00D9                   .dbline 241
 00D9           ;               unloadAllConfigs();
 00D9 7C0A79            xcall _unloadAllConfigs
 00DC                   .dbline 242
 00DC           ;       }
 00DC           L13:
 00DC                   .dbline 246
 00DC           ;       
 00DC           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DC           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DC           ;       if(mode == WAIT)
 00DC 3DFB00            cmp [X-5],0
 00DF B022              jnz L14
 00E1 3DFC01            cmp [X-4],1
 00E4 B01D              jnz L14
 00E6           X3:
 00E6                   .dbline 247
 00E6           ;       {
 00E6                   .dbline 250
 00E6           ;               // Load the wait receiver configuration.  This is the receiver configuration used after
 00E6           ;               // initialization is complete.  It listens and forwards everything it hears.
 00E6           ;               LoadConfig_waiting();
 00E6 7C0000            xcall _LoadConfig_waiting
 00E9                   .dbline 253
 00E9           ;               
 00E9           ;               // Start the receivers.
 00E9           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00E9 10                push X
 00EA 5000              mov A,0
 00EC 7C0000            xcall _WAIT_RECV_Start
 00EF 20                pop X
 00F0                   .dbline 254
 00F0           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F0 10                push X
 00F1 5000              mov A,0
 00F3 7C0000            xcall _RX8_2_Start
 00F6 20                pop X
 00F7                   .dbline 257
 00F7           ;               
 00F7           ;               // Set the current state.
 00F7           ;               STATE = WAIT;
 00F7 62D000            mov REG[0xd0],>_STATE
 00FA 550101            mov [_STATE+1],1
 00FD 550000            mov [_STATE],0
 0100                   .dbline 258
 0100           ;       }
 0100 81A0              xjmp L15
 0102           L14:
 0102                   .dbline 259
 0102           ;       else if(mode == MY_RESPONSE)
 0102 3DFB00            cmp [X-5],0
 0105 B04C              jnz L16
 0107 3DFC02            cmp [X-4],2
 010A B047              jnz L16
 010C           X4:
 010C                   .dbline 260
 010C           ;       {
 010C                   .dbline 262
 010C           ;               // Load the transmitter configuration.  This is for transmitting messages on all ports.
 010C           ;               LoadConfig_my_response();
 010C 7C0000            xcall _LoadConfig_my_response
 010F                   .dbline 265
 010F           ;               
 010F           ;               // Clear the timeout flag.
 010F           ;               TIMEOUT = 0;
 010F 62D000            mov REG[0xd0],>_TIMEOUT
 0112 550100            mov [_TIMEOUT+1],0
 0115 550000            mov [_TIMEOUT],0
 0118                   .dbline 268
 0118           ;               
 0118           ;               // Start the transmitters.
 0118           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0118 10                push X
 0119 5000              mov A,0
 011B 7C0000            xcall _TX_014_Start
 011E 20                pop X
 011F                   .dbline 269
 011F           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 011F 10                push X
 0120 5000              mov A,0
 0122 7C0000            xcall _TX_23_Start
 0125                   .dbline 271
 0125           ;               
 0125           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0125 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0128                   .dbline 272
 0128           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0128 7C0000            xcall _TX_01234_TIMEOUT_Start
 012B 20                pop X
 012C           L18:
 012C                   .dbline 276
 012C           ;               
 012C           ;               // Do nothing while we wait for one timeout period (1 ms).
 012C           ;               // This is to allow everyone to get in the right configuration before talking.
 012C           ;               while(!TIMEOUT) { }
 012C                   .dbline 276
 012C           L19:
 012C                   .dbline 276
 012C 62D000            mov REG[0xd0],>_TIMEOUT
 012F 3C0000            cmp [_TIMEOUT],0
 0132 B006              jnz X5
 0134 3C0100            cmp [_TIMEOUT+1],0
 0137 AFF4              jz L18
 0139           X5:
 0139                   .dbline 278
 0139           ;               
 0139           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0139 10                push X
 013A 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013D 20                pop X
 013E                   .dbline 279
 013E           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013E 62D000            mov REG[0xd0],>_TIMEOUT
 0141 550100            mov [_TIMEOUT+1],0
 0144 550000            mov [_TIMEOUT],0
 0147                   .dbline 282
 0147           ;       
 0147           ;               // Set the current state.
 0147           ;               STATE = MY_RESPONSE;
 0147 62D000            mov REG[0xd0],>_STATE
 014A 550102            mov [_STATE+1],2
 014D 550000            mov [_STATE],0
 0150                   .dbline 283
 0150           ;       }
 0150 8150              xjmp L17
 0152           L16:
 0152                   .dbline 284
 0152           ;       else if(mode == RESPONSE_1)
 0152 3DFB00            cmp [X-5],0
 0155 B02A              jnz L21
 0157 3DFC03            cmp [X-4],3
 015A B025              jnz L21
 015C           X6:
 015C                   .dbline 285
 015C           ;       {
 015C                   .dbline 287
 015C           ;               // Load the response wait on port 1.
 015C           ;               LoadConfig_response1();
 015C 7C0000            xcall _LoadConfig_response1
 015F                   .dbline 290
 015F           ;               
 015F           ;               // Clear the timeout flag.
 015F           ;               TIMEOUT = 0;
 015F 62D000            mov REG[0xd0],>_TIMEOUT
 0162 550100            mov [_TIMEOUT+1],0
 0165 550000            mov [_TIMEOUT],0
 0168                   .dbline 293
 0168           ;               
 0168           ;               // Start listening for a response through child port 1.
 0168           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0168 10                push X
 0169 5000              mov A,0
 016B 7C0000            xcall _CHILD_1_Start
 016E                   .dbline 295
 016E           ;               
 016E           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016E 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0171                   .dbline 296
 0171           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0171 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0174 20                pop X
 0175                   .dbline 299
 0175           ;               
 0175           ;               // Set the current state.
 0175           ;               STATE = RESPONSE_1;
 0175 62D000            mov REG[0xd0],>_STATE
 0178 550103            mov [_STATE+1],3
 017B 550000            mov [_STATE],0
 017E                   .dbline 300
 017E           ;       }
 017E 8122              xjmp L22
 0180           L21:
 0180                   .dbline 301
 0180           ;       else if(mode == RESPONSE_2)
 0180 3DFB00            cmp [X-5],0
 0183 B02A              jnz L23
 0185 3DFC04            cmp [X-4],4
 0188 B025              jnz L23
 018A           X7:
 018A                   .dbline 302
 018A           ;       {
 018A                   .dbline 304
 018A           ;               // Load the response wait on port 2.
 018A           ;               LoadConfig_response2();
 018A 7C0000            xcall _LoadConfig_response2
 018D                   .dbline 307
 018D           ;               
 018D           ;               // Clear the timeout flag.
 018D           ;               TIMEOUT = 0;
 018D 62D000            mov REG[0xd0],>_TIMEOUT
 0190 550100            mov [_TIMEOUT+1],0
 0193 550000            mov [_TIMEOUT],0
 0196                   .dbline 310
 0196           ;               
 0196           ;               // Start listening for a response through child port 2.
 0196           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0196 10                push X
 0197 5000              mov A,0
 0199 7C0000            xcall _CHILD_2_Start
 019C                   .dbline 312
 019C           ;               
 019C           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019C 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 019F                   .dbline 313
 019F           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 019F 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A2 20                pop X
 01A3                   .dbline 316
 01A3           ;               
 01A3           ;               // Set the current state.
 01A3           ;               STATE = RESPONSE_2;
 01A3 62D000            mov REG[0xd0],>_STATE
 01A6 550104            mov [_STATE+1],4
 01A9 550000            mov [_STATE],0
 01AC                   .dbline 317
 01AC           ;       }
 01AC 80F4              xjmp L24
 01AE           L23:
 01AE                   .dbline 318
 01AE           ;       else if(mode == RESPONSE_3)
 01AE 3DFB00            cmp [X-5],0
 01B1 B02A              jnz L25
 01B3 3DFC05            cmp [X-4],5
 01B6 B025              jnz L25
 01B8           X8:
 01B8                   .dbline 319
 01B8           ;       {
 01B8                   .dbline 321
 01B8           ;               // Load the response wait on port 3.
 01B8           ;               LoadConfig_response3();
 01B8 7C0000            xcall _LoadConfig_response3
 01BB                   .dbline 324
 01BB           ;               
 01BB           ;               // Clear the timeout flag.
 01BB           ;               TIMEOUT = 0;
 01BB 62D000            mov REG[0xd0],>_TIMEOUT
 01BE 550100            mov [_TIMEOUT+1],0
 01C1 550000            mov [_TIMEOUT],0
 01C4                   .dbline 327
 01C4           ;               
 01C4           ;               // Start listening for a response through child port 3.
 01C4           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C4 10                push X
 01C5 5000              mov A,0
 01C7 7C0000            xcall _CHILD_3_Start
 01CA                   .dbline 329
 01CA           ;               
 01CA           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CA 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CD                   .dbline 330
 01CD           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CD 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D0 20                pop X
 01D1                   .dbline 333
 01D1           ;               
 01D1           ;               // Set the current state.
 01D1           ;               STATE = RESPONSE_3;
 01D1 62D000            mov REG[0xd0],>_STATE
 01D4 550105            mov [_STATE+1],5
 01D7 550000            mov [_STATE],0
 01DA                   .dbline 334
 01DA           ;       }
 01DA 80C6              xjmp L26
 01DC           L25:
 01DC                   .dbline 335
 01DC           ;       else if(mode == RESPONSE_4)
 01DC 3DFB00            cmp [X-5],0
 01DF B02A              jnz L27
 01E1 3DFC06            cmp [X-4],6
 01E4 B025              jnz L27
 01E6           X9:
 01E6                   .dbline 336
 01E6           ;       {
 01E6                   .dbline 338
 01E6           ;               // Load the response wait on port 4.
 01E6           ;               LoadConfig_response4();
 01E6 7C0000            xcall _LoadConfig_response4
 01E9                   .dbline 341
 01E9           ;               
 01E9           ;               // Clear the timeout flag.
 01E9           ;               TIMEOUT = 0;
 01E9 62D000            mov REG[0xd0],>_TIMEOUT
 01EC 550100            mov [_TIMEOUT+1],0
 01EF 550000            mov [_TIMEOUT],0
 01F2                   .dbline 344
 01F2           ;               
 01F2           ;               // Start listening for a response through child port 4.
 01F2           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F2 10                push X
 01F3 5000              mov A,0
 01F5 7C0000            xcall _CHILD_4_Start
 01F8                   .dbline 346
 01F8           ;               
 01F8           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F8 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FB                   .dbline 347
 01FB           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FB 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FE 20                pop X
 01FF                   .dbline 350
 01FF           ;               
 01FF           ;               // Set the current state.
 01FF           ;               STATE = RESPONSE_4;
 01FF 62D000            mov REG[0xd0],>_STATE
 0202 550106            mov [_STATE+1],6
 0205 550000            mov [_STATE],0
 0208                   .dbline 351
 0208           ;       }
 0208 8098              xjmp L28
 020A           L27:
 020A                   .dbline 352
 020A           ;       else if(mode == HELLO_MODE)
 020A 3DFB00            cmp [X-5],0
 020D B03F              jnz L29
 020F 3DFC07            cmp [X-4],7
 0212 B03A              jnz L29
 0214           X10:
 0214                   .dbline 353
 0214           ;       {
 0214                   .dbline 355
 0214           ;               // Load the hello wait mode.  This is for listening on all ports for a hello response.
 0214           ;               LoadConfig_hello();
 0214 7C0000            xcall _LoadConfig_hello
 0217                   .dbline 358
 0217           ;               
 0217           ;               // Clear the timeout flag.
 0217           ;               TIMEOUT = 0;
 0217 62D000            mov REG[0xd0],>_TIMEOUT
 021A 550100            mov [_TIMEOUT+1],0
 021D 550000            mov [_TIMEOUT],0
 0220                   .dbline 362
 0220           ;               
 0220           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0220           ;       
 0220           ;               {
 0220                   .dbline 364
 0220           ;               // Start listening for a response through child port 1.
 0220           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0220 10                push X
 0221 5000              mov A,0
 0223 7C0000            xcall _HELLO_1_Start
 0226 20                pop X
 0227                   .dbline 365
 0227           ;               }
 0227                   .dbline 367
 0227           ;               
 0227           ;               {
 0227                   .dbline 369
 0227           ;               // Start listening for a response through child port 2.
 0227           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0227 10                push X
 0228 5000              mov A,0
 022A 7C0000            xcall _HELLO_2_Start
 022D 20                pop X
 022E                   .dbline 370
 022E           ;               }
 022E                   .dbline 372
 022E           ;               
 022E           ;               {
 022E                   .dbline 374
 022E           ;               // Start listening for a response through child port 3.
 022E           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022E 10                push X
 022F 5000              mov A,0
 0231 7C0000            xcall _HELLO_3_Start
 0234 20                pop X
 0235                   .dbline 375
 0235           ;               }
 0235                   .dbline 377
 0235           ;               
 0235           ;               {
 0235                   .dbline 379
 0235           ;               // Start listening for a response through child port 4.
 0235           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0235 10                push X
 0236 5000              mov A,0
 0238 7C0000            xcall _HELLO_4_Start
 023B                   .dbline 380
 023B           ;               }
 023B                   .dbline 382
 023B           ;               
 023B           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023B 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023E                   .dbline 383
 023E           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023E 7C0000            xcall _HELLO_TIMEOUT_Start
 0241 20                pop X
 0242                   .dbline 386
 0242           ;               
 0242           ;               // Set the current state.
 0242           ;               STATE = HELLO_MODE;
 0242 62D000            mov REG[0xd0],>_STATE
 0245 550107            mov [_STATE+1],7
 0248 550000            mov [_STATE],0
 024B                   .dbline 387
 024B           ;       }
 024B 8055              xjmp L30
 024D           L29:
 024D                   .dbline 388
 024D           ;       else if(mode == INITIALIZE)
 024D 3DFB00            cmp [X-5],0
 0250 B02A              jnz L31
 0252 3DFC08            cmp [X-4],8
 0255 B025              jnz L31
 0257           X11:
 0257                   .dbline 389
 0257           ;       {
 0257                   .dbline 391
 0257           ;               // Load the configuration for initialization.  This config listens but does not forward.
 0257           ;               LoadConfig_initial();
 0257 7C0000            xcall _LoadConfig_initial
 025A                   .dbline 394
 025A           ;               
 025A           ;               // Clear the timeout flag.
 025A           ;               TIMEOUT = 0;
 025A 62D000            mov REG[0xd0],>_TIMEOUT
 025D 550100            mov [_TIMEOUT+1],0
 0260 550000            mov [_TIMEOUT],0
 0263                   .dbline 397
 0263           ;               
 0263           ;               // Start the receiver.
 0263           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0263 10                push X
 0264 5000              mov A,0
 0266 7C0000            xcall _INIT_RX_Start
 0269                   .dbline 399
 0269           ;               
 0269           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0269 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026C                   .dbline 400
 026C           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026C 7C0000            xcall _INIT_TIMEOUT_Start
 026F 20                pop X
 0270                   .dbline 403
 0270           ;               
 0270           ;               // Set the current state.
 0270           ;               STATE = INITIALIZE;
 0270 62D000            mov REG[0xd0],>_STATE
 0273 550108            mov [_STATE+1],8
 0276 550000            mov [_STATE],0
 0279                   .dbline 404
 0279           ;       }
 0279 8027              xjmp L32
 027B           L31:
 027B                   .dbline 405
 027B           ;       else if(mode == SERVO_COMM)
 027B 3DFB00            cmp [X-5],0
 027E B022              jnz L33
 0280 3DFC09            cmp [X-4],9
 0283 B01D              jnz L33
 0285           X12:
 0285                   .dbline 406
 0285           ;       {
 0285                   .dbline 408
 0285           ;               // Load the configuration for servo communication.  This config only transmits on P00.
 0285           ;               LoadConfig_servo_transmit();
 0285 7C0000            xcall _LoadConfig_servo_transmit
 0288                   .dbline 411
 0288           ;               
 0288           ;               // Clear the timeout flag.
 0288           ;               TIMEOUT = 0;
 0288 62D000            mov REG[0xd0],>_TIMEOUT
 028B 550100            mov [_TIMEOUT+1],0
 028E 550000            mov [_TIMEOUT],0
 0291                   .dbline 414
 0291           ;               
 0291           ;               // Start the transmitter.
 0291           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0291 10                push X
 0292 5000              mov A,0
 0294 7C0000            xcall _SERVO_TX_Start
 0297 20                pop X
 0298                   .dbline 417
 0298           ;       
 0298           ;               // Set the current state.
 0298           ;               STATE = SERVO_COMM;
 0298 62D000            mov REG[0xd0],>_STATE
 029B 550109            mov [_STATE+1],9
 029E 550000            mov [_STATE],0
 02A1                   .dbline 418
 02A1           ;       }
 02A1           L33:
 02A1           L32:
 02A1           L30:
 02A1           L28:
 02A1           L26:
 02A1           L24:
 02A1           L22:
 02A1           L17:
 02A1           L15:
 02A1                   .dbline 421
 02A1           ;       
 02A1           ;       // If this module is configured, talk on all pins for potential children.
 02A1           ;       if(CONFIGURED)
 02A1 62D000            mov REG[0xd0],>_CONFIGURED
 02A4 3C0000            cmp [_CONFIGURED],0
 02A7 B006              jnz X13
 02A9 3C0100            cmp [_CONFIGURED+1],0
 02AC A009              jz L35
 02AE           X13:
 02AE                   .dbline 422
 02AE           ;       {
 02AE                   .dbline 423
 02AE           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AE 43021F            or REG[0x2],31
 02B1                   .dbline 424
 02B1           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B1 4108FE            and REG[0x8],-2
 02B4                   .dbline 425
 02B4           ;       }
 02B4 8007              xjmp L36
 02B6           L35:
 02B6                   .dbline 427
 02B6           ;       else
 02B6           ;       {
 02B6                   .dbline 428
 02B6           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B6 430201            or REG[0x2],1
 02B9                   .dbline 429
 02B9           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02B9 430801            or REG[0x8],1
 02BC                   .dbline 430
 02BC           ;       }
 02BC           L36:
 02BC                   .dbline -2
 02BC           L11:
 02BC 20                pop X
 02BD                   .dbline 0 ; func end
 02BD 7F                ret
 02BE                   .dbsym l mode -5 I
 02BE                   .dbend
 02BE                   .dbfunc e commandReady _commandReady fI
 02BE           ;              i -> X+1
 02BE           ;       tempByte -> X+0
 02BE           _commandReady::
 02BE                   .dbline -1
 02BE 10                push X
 02BF 4F                mov X,SP
 02C0 3803              add SP,3
 02C2                   .dbline 437
 02C2           ; }
 02C2           ; 
 02C2           ; // This function tries to peek and see if a start byte has been written to the bus.
 02C2           ; // If there is no start byte, the function exits.  If a start byte is detected, the function
 02C2           ; // blocks and waits for the transmission to finish.
 02C2           ; int commandReady(void)
 02C2           ; {
 02C2                   .dbline 438
 02C2           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C2 560200            mov [X+2],0
 02C5 560100            mov [X+1],0
 02C8                   .dbline 439
 02C8           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C8 560000            mov [X+0],0
 02CB                   .dbline 443
 02CB           ;       
 02CB           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02CB           ;       // read a transmission and store the important information from that transmission.
 02CB           ;       if(STATE == WAIT)
 02CB 62D000            mov REG[0xd0],>_STATE
 02CE 3C0000            cmp [_STATE],0
 02D1 B0D4              jnz L38
 02D3 3C0101            cmp [_STATE+1],1
 02D6 B0CF              jnz L38
 02D8           X14:
 02D8                   .dbline 444
 02D8           ;       {       
 02D8                   .dbline 447
 02D8           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02D8           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02D8           ;               tempByte = WAIT_RECV_cGetChar();
 02D8 10                push X
 02D9 7C0000            xcall _WAIT_RECV_cGetChar
 02DC 62D000            mov REG[0xd0],>__r0
 02DF 20                pop X
 02E0 5400              mov [X+0],A
 02E2                   .dbline 450
 02E2           ;               
 02E2           ;               // If a transmission has started for either a controller or a servo...
 02E2           ;               if(tempByte == START_TRANSMIT)
 02E2 3D00FC            cmp [X+0],-4
 02E5 B047              jnz L40
 02E7                   .dbline 451
 02E7           ;               {
 02E7 800B              xjmp L43
 02E9           L42:
 02E9                   .dbline 454
 02E9           ;                       // While we keep reading start bytes, sit and spin.
 02E9           ;                       while(tempByte == START_TRANSMIT)
 02E9           ;                       {
 02E9                   .dbline 455
 02E9           ;                               tempByte = WAIT_RECV_cGetChar();
 02E9 10                push X
 02EA 7C0000            xcall _WAIT_RECV_cGetChar
 02ED 62D000            mov REG[0xd0],>__r0
 02F0 20                pop X
 02F1 5400              mov [X+0],A
 02F3                   .dbline 456
 02F3           ;                       }
 02F3           L43:
 02F3                   .dbline 453
 02F3 3D00FC            cmp [X+0],-4
 02F6 AFF2              jz L42
 02F8                   .dbline 459
 02F8           ;                       
 02F8           ;                       // The tempByte variable contains the source ID.  If the source is good, store all bytes.
 02F8           ;                       if(tempByte == MASTER_ID)
 02F8 3D0000            cmp [X+0],0
 02FB B397              jnz L39
 02FD                   .dbline 460
 02FD           ;                       {
 02FD                   .dbline 461
 02FD           ;                               COMMAND_SOURCE = tempByte;
 02FD 5200              mov A,[X+0]
 02FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0302 5300              mov [_COMMAND_SOURCE],A
 0304                   .dbline 462
 0304           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 0304 10                push X
 0305 7C0000            xcall _WAIT_RECV_cGetChar
 0308 20                pop X
 0309 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 030C 5300              mov [_COMMAND_DESTINATION],A
 030E                   .dbline 463
 030E           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 030E 10                push X
 030F 7C0000            xcall _WAIT_RECV_cGetChar
 0312 20                pop X
 0313 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0316 5300              mov [_COMMAND_TYPE],A
 0318                   .dbline 464
 0318           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 0318 10                push X
 0319 7C0000            xcall _WAIT_RECV_cGetChar
 031C 20                pop X
 031D 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0320 5300              mov [_COMMAND_PARAM],A
 0322                   .dbline 466
 0322           ;                               
 0322           ;                               return 1;
 0322 62D000            mov REG[0xd0],>__r0
 0325 550001            mov [__r1],1
 0328 550000            mov [__r0],0
 032B 8370              xjmp L37
 032D           L40:
 032D                   .dbline 469
 032D           ;                       }
 032D           ;               }
 032D           ;               else if(tempByte == SERVO_START)
 032D 3D00FF            cmp [X+0],-1
 0330 B362              jnz L39
 0332                   .dbline 470
 0332           ;               {
 0332 800B              xjmp L50
 0334           L49:
 0334                   .dbline 473
 0334           ;                       // While we keep reading start bytes, sit and spin.
 0334           ;                       while(tempByte == SERVO_START)
 0334           ;                       {
 0334                   .dbline 474
 0334           ;                               tempByte = WAIT_RECV_cGetChar();
 0334 10                push X
 0335 7C0000            xcall _WAIT_RECV_cGetChar
 0338 62D000            mov REG[0xd0],>__r0
 033B 20                pop X
 033C 5400              mov [X+0],A
 033E                   .dbline 475
 033E           ;                       }
 033E           L50:
 033E                   .dbline 472
 033E 3D00FF            cmp [X+0],-1
 0341 AFF2              jz L49
 0343                   .dbline 478
 0343           ;                       
 0343           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 0343           ;                       COMMAND_SOURCE = MASTER_ID;
 0343 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0346 550000            mov [_COMMAND_SOURCE],0
 0349                   .dbline 480
 0349           ;                       // The first parameter after the servo start is the destination.
 0349           ;                       COMMAND_DESTINATION = tempByte;
 0349 5200              mov A,[X+0]
 034B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 034E 5300              mov [_COMMAND_DESTINATION],A
 0350                   .dbline 485
 0350           ;                       // The second parameter after the servo start is the command length.
 0350           ;                       // We don't need it to wait for the transmission to go through since the
 0350           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0350           ;                       // (it is already in and out by the time you read this byte).
 0350           ;                       tempByte = WAIT_RECV_cGetChar();
 0350 10                push X
 0351 7C0000            xcall _WAIT_RECV_cGetChar
 0354 62D000            mov REG[0xd0],>__r0
 0357 20                pop X
 0358 5400              mov [X+0],A
 035A                   .dbline 488
 035A           ;                       // Now we store the command type.  Depending on what the status return level
 035A           ;                       // is, we have special duties.
 035A           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 035A 10                push X
 035B 7C0000            xcall _WAIT_RECV_cGetChar
 035E 20                pop X
 035F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0362 5300              mov [_COMMAND_TYPE],A
 0364                   .dbline 491
 0364           ;                       
 0364           ;                       // This basically waits for the rest of the command to pass through.
 0364           ;                       for(i = 0; i < (tempByte - 1); i++)
 0364 560200            mov [X+2],0
 0367 560100            mov [X+1],0
 036A 800E              xjmp L55
 036C           L52:
 036C                   .dbline 492
 036C           ;                       {
 036C                   .dbline 493
 036C           ;                               WAIT_RECV_cGetChar();
 036C 10                push X
 036D 7C0000            xcall _WAIT_RECV_cGetChar
 0370 62D000            mov REG[0xd0],>__r0
 0373 20                pop X
 0374                   .dbline 494
 0374           ;                       }
 0374           L53:
 0374                   .dbline 491
 0374 7702              inc [X+2]
 0376 0F0100            adc [X+1],0
 0379           L55:
 0379                   .dbline 491
 0379 62D000            mov REG[0xd0],>__r0
 037C 5200              mov A,[X+0]
 037E 5300              mov [__r1],A
 0380 550000            mov [__r0],0
 0383 160001            sub [__r1],1
 0386 1E0000            sbb [__r0],0
 0389 5202              mov A,[X+2]
 038B 1200              sub A,[__r1]
 038D 5100              mov A,[__r0]
 038F 3180              xor A,-128
 0391 5300              mov [__rX],A
 0393 5201              mov A,[X+1]
 0395 3180              xor A,-128
 0397 1A00              sbb A,[__rX]
 0399 CFD2              jc L52
 039B           X15:
 039B                   .dbline 496
 039B           ;                               
 039B           ;                       return 1;
 039B 62D000            mov REG[0xd0],>__r0
 039E 550001            mov [__r1],1
 03A1 550000            mov [__r0],0
 03A4 82F7              xjmp L37
 03A6           L38:
 03A6                   .dbline 499
 03A6           ;               }
 03A6           ;       }
 03A6           ;       else if(STATE == HELLO_MODE)
 03A6 62D000            mov REG[0xd0],>_STATE
 03A9 3C0000            cmp [_STATE],0
 03AC B06E              jnz L56
 03AE 3C0107            cmp [_STATE+1],7
 03B1 B069              jnz L56
 03B3           X16:
 03B3                   .dbline 500
 03B3           ;       {
 03B3                   .dbline 502
 03B3           ;               // Check all of the ports for a start byte.  Only one port will produce one.
 03B3           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03B3 10                push X
 03B4 7C0000            xcall _HELLO_1_cReadChar
 03B7 20                pop X
 03B8 39FC              cmp A,-4
 03BA B012              jnz L58
 03BC                   .dbline 503
 03BC           ;               {               
 03BC                   .dbline 504
 03BC           ;                       CHILD = PORT_1;
 03BC 62D000            mov REG[0xd0],>_CHILD
 03BF 550031            mov [_CHILD],49
 03C2                   .dbline 506
 03C2           ;                       
 03C2           ;                       return 1;
 03C2 62D000            mov REG[0xd0],>__r0
 03C5 550001            mov [__r1],1
 03C8 550000            mov [__r0],0
 03CB 82D0              xjmp L37
 03CD           L58:
 03CD                   .dbline 508
 03CD           ;               }
 03CD           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03CD 10                push X
 03CE 7C0000            xcall _HELLO_2_cReadChar
 03D1 20                pop X
 03D2 39FC              cmp A,-4
 03D4 B012              jnz L60
 03D6                   .dbline 509
 03D6           ;               {               
 03D6                   .dbline 510
 03D6           ;                       CHILD = PORT_2;
 03D6 62D000            mov REG[0xd0],>_CHILD
 03D9 550032            mov [_CHILD],50
 03DC                   .dbline 512
 03DC           ;                       
 03DC           ;                       return 1;
 03DC 62D000            mov REG[0xd0],>__r0
 03DF 550001            mov [__r1],1
 03E2 550000            mov [__r0],0
 03E5 82B6              xjmp L37
 03E7           L60:
 03E7                   .dbline 514
 03E7           ;               }
 03E7           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03E7 10                push X
 03E8 7C0000            xcall _HELLO_3_cReadChar
 03EB 20                pop X
 03EC 39FC              cmp A,-4
 03EE B012              jnz L62
 03F0                   .dbline 515
 03F0           ;               {
 03F0                   .dbline 516
 03F0           ;                       CHILD = PORT_3;
 03F0 62D000            mov REG[0xd0],>_CHILD
 03F3 550033            mov [_CHILD],51
 03F6                   .dbline 518
 03F6           ;                       
 03F6           ;                       return 1;
 03F6 62D000            mov REG[0xd0],>__r0
 03F9 550001            mov [__r1],1
 03FC 550000            mov [__r0],0
 03FF 829C              xjmp L37
 0401           L62:
 0401                   .dbline 520
 0401           ;               }
 0401           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 0401 10                push X
 0402 7C0000            xcall _HELLO_4_cReadChar
 0405 20                pop X
 0406 39FC              cmp A,-4
 0408 B28A              jnz L57
 040A                   .dbline 521
 040A           ;               {
 040A                   .dbline 522
 040A           ;                       CHILD = PORT_4;
 040A 62D000            mov REG[0xd0],>_CHILD
 040D 550034            mov [_CHILD],52
 0410                   .dbline 524
 0410           ;                       
 0410           ;                       return 1;
 0410 62D000            mov REG[0xd0],>__r0
 0413 550001            mov [__r1],1
 0416 550000            mov [__r0],0
 0419 8282              xjmp L37
 041B           L56:
 041B                   .dbline 527
 041B           ;               }
 041B           ;       }
 041B           ;       else if(STATE == RESPONSE_1)
 041B 62D000            mov REG[0xd0],>_STATE
 041E 3C0000            cmp [_STATE],0
 0421 B081              jnz L66
 0423 3C0103            cmp [_STATE+1],3
 0426 B07C              jnz L66
 0428           X17:
 0428                   .dbline 528
 0428           ;       {
 0428                   .dbline 529
 0428           ;               if(tempByte = CHILD_1_cReadChar())
 0428 10                push X
 0429 7C0000            xcall _CHILD_1_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 5400              mov [X+0],A
 0432 3900              cmp A,0
 0434 A25E              jz L67
 0436                   .dbline 530
 0436           ;               {
 0436                   .dbline 531
 0436           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0436 3D00FF            cmp [X+0],-1
 0439 B050              jnz L70
 043B                   .dbline 532
 043B           ;                       {
 043B           L72:
 043B                   .dbline 534
 043B           ;                               // Burn through the rest of the start bytes and the servo length.
 043B           ;                               while(CHILD_1_cGetChar() == SERVO_START) { }
 043B                   .dbline 534
 043B           L73:
 043B                   .dbline 534
 043B 10                push X
 043C 7C0000            xcall _CHILD_1_cGetChar
 043F 62D000            mov REG[0xd0],>__r0
 0442 20                pop X
 0443 39FF              cmp A,-1
 0445 AFF5              jz L72
 0447                   .dbline 537
 0447           ;                               
 0447           ;                               // We store the length, since it is the next byte from the servo.
 0447           ;                               tempByte = CHILD_1_cGetChar();
 0447 10                push X
 0448 7C0000            xcall _CHILD_1_cGetChar
 044B 62D000            mov REG[0xd0],>__r0
 044E 20                pop X
 044F 5400              mov [X+0],A
 0451                   .dbline 540
 0451           ;                               
 0451           ;                               // This basically waits for the rest of the command to pass through.
 0451           ;                               for(i = 0; i < tempByte; i++)
 0451 560200            mov [X+2],0
 0454 560100            mov [X+1],0
 0457 800E              xjmp L78
 0459           L75:
 0459                   .dbline 541
 0459           ;                               {
 0459                   .dbline 542
 0459           ;                                       CHILD_1_cGetChar();
 0459 10                push X
 045A 7C0000            xcall _CHILD_1_cGetChar
 045D 62D000            mov REG[0xd0],>__r0
 0460 20                pop X
 0461                   .dbline 543
 0461           ;                               }
 0461           L76:
 0461                   .dbline 540
 0461 7702              inc [X+2]
 0463 0F0100            adc [X+1],0
 0466           L78:
 0466                   .dbline 540
 0466 62D000            mov REG[0xd0],>__r0
 0469 5200              mov A,[X+0]
 046B 5300              mov [__r1],A
 046D 5202              mov A,[X+2]
 046F 1200              sub A,[__r1]
 0471 5000              mov A,0
 0473 3180              xor A,-128
 0475 5300              mov [__rX],A
 0477 5201              mov A,[X+1]
 0479 3180              xor A,-128
 047B 1A00              sbb A,[__rX]
 047D CFDB              jc L75
 047F           X18:
 047F                   .dbline 545
 047F           ;                               
 047F           ;                               return 1;
 047F 62D000            mov REG[0xd0],>__r0
 0482 550001            mov [__r1],1
 0485 550000            mov [__r0],0
 0488 8213              xjmp L37
 048A           L70:
 048A                   .dbline 547
 048A           ;                       }
 048A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 048A 3D00FC            cmp [X+0],-4
 048D B205              jnz L67
 048F                   .dbline 548
 048F           ;                       {
 048F           L81:
 048F                   .dbline 550
 048F           ;                               // We simply wait for the end transmit indicator.
 048F           ;                               while(CHILD_1_cGetChar() != END_TRANSMIT) { }
 048F                   .dbline 550
 048F           L82:
 048F                   .dbline 550
 048F 10                push X
 0490 7C0000            xcall _CHILD_1_cGetChar
 0493 62D000            mov REG[0xd0],>__r0
 0496 20                pop X
 0497 39FD              cmp A,-3
 0499 BFF5              jnz L81
 049B                   .dbline 552
 049B           ;                               
 049B           ;                               return 1;
 049B 550001            mov [__r1],1
 049E 550000            mov [__r0],0
 04A1 81FA              xjmp L37
 04A3           L66:
 04A3                   .dbline 556
 04A3           ;                       }
 04A3           ;               }
 04A3           ;       }
 04A3           ;       else if(STATE == RESPONSE_2)
 04A3 62D000            mov REG[0xd0],>_STATE
 04A6 3C0000            cmp [_STATE],0
 04A9 B081              jnz L84
 04AB 3C0104            cmp [_STATE+1],4
 04AE B07C              jnz L84
 04B0           X19:
 04B0                   .dbline 557
 04B0           ;       {
 04B0                   .dbline 558
 04B0           ;               if(tempByte = CHILD_2_cReadChar())
 04B0 10                push X
 04B1 7C0000            xcall _CHILD_2_cReadChar
 04B4 62D000            mov REG[0xd0],>__r0
 04B7 20                pop X
 04B8 5400              mov [X+0],A
 04BA 3900              cmp A,0
 04BC A1D6              jz L85
 04BE                   .dbline 559
 04BE           ;               {
 04BE                   .dbline 560
 04BE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 04BE 3D00FF            cmp [X+0],-1
 04C1 B050              jnz L88
 04C3                   .dbline 561
 04C3           ;                       {
 04C3           L90:
 04C3                   .dbline 563
 04C3           ;                               // Burn through the rest of the start bytes and the servo length.
 04C3           ;                               while(CHILD_2_cGetChar() == SERVO_START) { }
 04C3                   .dbline 563
 04C3           L91:
 04C3                   .dbline 563
 04C3 10                push X
 04C4 7C0000            xcall _CHILD_2_cGetChar
 04C7 62D000            mov REG[0xd0],>__r0
 04CA 20                pop X
 04CB 39FF              cmp A,-1
 04CD AFF5              jz L90
 04CF                   .dbline 566
 04CF           ;                               
 04CF           ;                               // We store the length, since it is the next byte from the servo.
 04CF           ;                               tempByte = CHILD_2_cGetChar();
 04CF 10                push X
 04D0 7C0000            xcall _CHILD_2_cGetChar
 04D3 62D000            mov REG[0xd0],>__r0
 04D6 20                pop X
 04D7 5400              mov [X+0],A
 04D9                   .dbline 569
 04D9           ;                               
 04D9           ;                               // This basically waits for the rest of the command to pass through.
 04D9           ;                               for(i = 0; i < tempByte; i++)
 04D9 560200            mov [X+2],0
 04DC 560100            mov [X+1],0
 04DF 800E              xjmp L96
 04E1           L93:
 04E1                   .dbline 570
 04E1           ;                               {
 04E1                   .dbline 571
 04E1           ;                                       CHILD_2_cGetChar();
 04E1 10                push X
 04E2 7C0000            xcall _CHILD_2_cGetChar
 04E5 62D000            mov REG[0xd0],>__r0
 04E8 20                pop X
 04E9                   .dbline 572
 04E9           ;                               }
 04E9           L94:
 04E9                   .dbline 569
 04E9 7702              inc [X+2]
 04EB 0F0100            adc [X+1],0
 04EE           L96:
 04EE                   .dbline 569
 04EE 62D000            mov REG[0xd0],>__r0
 04F1 5200              mov A,[X+0]
 04F3 5300              mov [__r1],A
 04F5 5202              mov A,[X+2]
 04F7 1200              sub A,[__r1]
 04F9 5000              mov A,0
 04FB 3180              xor A,-128
 04FD 5300              mov [__rX],A
 04FF 5201              mov A,[X+1]
 0501 3180              xor A,-128
 0503 1A00              sbb A,[__rX]
 0505 CFDB              jc L93
 0507           X20:
 0507                   .dbline 574
 0507           ;                               
 0507           ;                               return 1;
 0507 62D000            mov REG[0xd0],>__r0
 050A 550001            mov [__r1],1
 050D 550000            mov [__r0],0
 0510 818B              xjmp L37
 0512           L88:
 0512                   .dbline 576
 0512           ;                       }
 0512           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0512 3D00FC            cmp [X+0],-4
 0515 B17D              jnz L85
 0517                   .dbline 577
 0517           ;                       {
 0517           L99:
 0517                   .dbline 579
 0517           ;                               // We simply wait for the end transmit indicator.
 0517           ;                               while(CHILD_2_cGetChar() != END_TRANSMIT) { }
 0517                   .dbline 579
 0517           L100:
 0517                   .dbline 579
 0517 10                push X
 0518 7C0000            xcall _CHILD_2_cGetChar
 051B 62D000            mov REG[0xd0],>__r0
 051E 20                pop X
 051F 39FD              cmp A,-3
 0521 BFF5              jnz L99
 0523                   .dbline 581
 0523           ;                               
 0523           ;                               return 1;
 0523 550001            mov [__r1],1
 0526 550000            mov [__r0],0
 0529 8172              xjmp L37
 052B           L84:
 052B                   .dbline 585
 052B           ;                       }
 052B           ;               }
 052B           ;       }
 052B           ;       else if(STATE == RESPONSE_3)
 052B 62D000            mov REG[0xd0],>_STATE
 052E 3C0000            cmp [_STATE],0
 0531 B081              jnz L102
 0533 3C0105            cmp [_STATE+1],5
 0536 B07C              jnz L102
 0538           X21:
 0538                   .dbline 586
 0538           ;       {
 0538                   .dbline 587
 0538           ;               if(tempByte = CHILD_3_cReadChar())
 0538 10                push X
 0539 7C0000            xcall _CHILD_3_cReadChar
 053C 62D000            mov REG[0xd0],>__r0
 053F 20                pop X
 0540 5400              mov [X+0],A
 0542 3900              cmp A,0
 0544 A14E              jz L103
 0546                   .dbline 588
 0546           ;               {
 0546                   .dbline 589
 0546           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0546 3D00FF            cmp [X+0],-1
 0549 B050              jnz L106
 054B                   .dbline 590
 054B           ;                       {
 054B           L108:
 054B                   .dbline 592
 054B           ;                               // Burn through the rest of the start bytes and the servo length.
 054B           ;                               while(CHILD_3_cGetChar() == SERVO_START) { }
 054B                   .dbline 592
 054B           L109:
 054B                   .dbline 592
 054B 10                push X
 054C 7C0000            xcall _CHILD_3_cGetChar
 054F 62D000            mov REG[0xd0],>__r0
 0552 20                pop X
 0553 39FF              cmp A,-1
 0555 AFF5              jz L108
 0557                   .dbline 595
 0557           ;                               
 0557           ;                               // We store the length, since it is the next byte from the servo.
 0557           ;                               tempByte = CHILD_3_cGetChar();
 0557 10                push X
 0558 7C0000            xcall _CHILD_3_cGetChar
 055B 62D000            mov REG[0xd0],>__r0
 055E 20                pop X
 055F 5400              mov [X+0],A
 0561                   .dbline 598
 0561           ;                               
 0561           ;                               // This basically waits for the rest of the command to pass through.
 0561           ;                               for(i = 0; i < tempByte; i++)
 0561 560200            mov [X+2],0
 0564 560100            mov [X+1],0
 0567 800E              xjmp L114
 0569           L111:
 0569                   .dbline 599
 0569           ;                               {
 0569                   .dbline 600
 0569           ;                                       CHILD_3_cGetChar();
 0569 10                push X
 056A 7C0000            xcall _CHILD_3_cGetChar
 056D 62D000            mov REG[0xd0],>__r0
 0570 20                pop X
 0571                   .dbline 601
 0571           ;                               }
 0571           L112:
 0571                   .dbline 598
 0571 7702              inc [X+2]
 0573 0F0100            adc [X+1],0
 0576           L114:
 0576                   .dbline 598
 0576 62D000            mov REG[0xd0],>__r0
 0579 5200              mov A,[X+0]
 057B 5300              mov [__r1],A
 057D 5202              mov A,[X+2]
 057F 1200              sub A,[__r1]
 0581 5000              mov A,0
 0583 3180              xor A,-128
 0585 5300              mov [__rX],A
 0587 5201              mov A,[X+1]
 0589 3180              xor A,-128
 058B 1A00              sbb A,[__rX]
 058D CFDB              jc L111
 058F           X22:
 058F                   .dbline 603
 058F           ;                               
 058F           ;                               return 1;
 058F 62D000            mov REG[0xd0],>__r0
 0592 550001            mov [__r1],1
 0595 550000            mov [__r0],0
 0598 8103              xjmp L37
 059A           L106:
 059A                   .dbline 605
 059A           ;                       }
 059A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 059A 3D00FC            cmp [X+0],-4
 059D B0F5              jnz L103
 059F                   .dbline 606
 059F           ;                       {
 059F           L117:
 059F                   .dbline 608
 059F           ;                               // We simply wait for the end transmit indicator.
 059F           ;                               while(CHILD_3_cGetChar() != END_TRANSMIT) { }
 059F                   .dbline 608
 059F           L118:
 059F                   .dbline 608
 059F 10                push X
 05A0 7C0000            xcall _CHILD_3_cGetChar
 05A3 62D000            mov REG[0xd0],>__r0
 05A6 20                pop X
 05A7 39FD              cmp A,-3
 05A9 BFF5              jnz L117
 05AB                   .dbline 610
 05AB           ;                               
 05AB           ;                               return 1;
 05AB 550001            mov [__r1],1
 05AE 550000            mov [__r0],0
 05B1 80EA              xjmp L37
 05B3           L102:
 05B3                   .dbline 614
 05B3           ;                       }
 05B3           ;               }
 05B3           ;       }
 05B3           ;       else if(STATE == RESPONSE_4)
 05B3 62D000            mov REG[0xd0],>_STATE
 05B6 3C0000            cmp [_STATE],0
 05B9 B081              jnz L120
 05BB 3C0106            cmp [_STATE+1],6
 05BE B07C              jnz L120
 05C0           X23:
 05C0                   .dbline 615
 05C0           ;       {
 05C0                   .dbline 616
 05C0           ;               if(tempByte = CHILD_4_cReadChar())
 05C0 10                push X
 05C1 7C0000            xcall _CHILD_4_cReadChar
 05C4 62D000            mov REG[0xd0],>__r0
 05C7 20                pop X
 05C8 5400              mov [X+0],A
 05CA 3900              cmp A,0
 05CC A0C6              jz L121
 05CE                   .dbline 617
 05CE           ;               {
 05CE                   .dbline 618
 05CE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 05CE 3D00FF            cmp [X+0],-1
 05D1 B050              jnz L124
 05D3                   .dbline 619
 05D3           ;                       {
 05D3           L126:
 05D3                   .dbline 621
 05D3           ;                               // Burn through the rest of the start bytes and the servo length.
 05D3           ;                               while(CHILD_4_cGetChar() == SERVO_START) { }
 05D3                   .dbline 621
 05D3           L127:
 05D3                   .dbline 621
 05D3 10                push X
 05D4 7C0000            xcall _CHILD_4_cGetChar
 05D7 62D000            mov REG[0xd0],>__r0
 05DA 20                pop X
 05DB 39FF              cmp A,-1
 05DD AFF5              jz L126
 05DF                   .dbline 624
 05DF           ;                               
 05DF           ;                               // We store the length, since it is the next byte from the servo.
 05DF           ;                               tempByte = CHILD_4_cGetChar();
 05DF 10                push X
 05E0 7C0000            xcall _CHILD_4_cGetChar
 05E3 62D000            mov REG[0xd0],>__r0
 05E6 20                pop X
 05E7 5400              mov [X+0],A
 05E9                   .dbline 627
 05E9           ;                               
 05E9           ;                               // This basically waits for the rest of the command to pass through.
 05E9           ;                               for(i = 0; i < tempByte; i++)
 05E9 560200            mov [X+2],0
 05EC 560100            mov [X+1],0
 05EF 800E              xjmp L132
 05F1           L129:
 05F1                   .dbline 628
 05F1           ;                               {
 05F1                   .dbline 629
 05F1           ;                                       CHILD_4_cGetChar();
 05F1 10                push X
 05F2 7C0000            xcall _CHILD_4_cGetChar
 05F5 62D000            mov REG[0xd0],>__r0
 05F8 20                pop X
 05F9                   .dbline 630
 05F9           ;                               }
 05F9           L130:
 05F9                   .dbline 627
 05F9 7702              inc [X+2]
 05FB 0F0100            adc [X+1],0
 05FE           L132:
 05FE                   .dbline 627
 05FE 62D000            mov REG[0xd0],>__r0
 0601 5200              mov A,[X+0]
 0603 5300              mov [__r1],A
 0605 5202              mov A,[X+2]
 0607 1200              sub A,[__r1]
 0609 5000              mov A,0
 060B 3180              xor A,-128
 060D 5300              mov [__rX],A
 060F 5201              mov A,[X+1]
 0611 3180              xor A,-128
 0613 1A00              sbb A,[__rX]
 0615 CFDB              jc L129
 0617           X24:
 0617                   .dbline 632
 0617           ;                               
 0617           ;                               return 1;
 0617 62D000            mov REG[0xd0],>__r0
 061A 550001            mov [__r1],1
 061D 550000            mov [__r0],0
 0620 807B              xjmp L37
 0622           L124:
 0622                   .dbline 634
 0622           ;                       }
 0622           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0622 3D00FC            cmp [X+0],-4
 0625 B06D              jnz L121
 0627                   .dbline 635
 0627           ;                       {
 0627           L135:
 0627                   .dbline 637
 0627           ;                               // We simply wait for the end transmit indicator.
 0627           ;                               while(CHILD_4_cGetChar() != END_TRANSMIT) { }
 0627                   .dbline 637
 0627           L136:
 0627                   .dbline 637
 0627 10                push X
 0628 7C0000            xcall _CHILD_4_cGetChar
 062B 62D000            mov REG[0xd0],>__r0
 062E 20                pop X
 062F 39FD              cmp A,-3
 0631 BFF5              jnz L135
 0633                   .dbline 639
 0633           ;                               
 0633           ;                               return 1;
 0633 550001            mov [__r1],1
 0636 550000            mov [__r0],0
 0639 8062              xjmp L37
 063B           L120:
 063B                   .dbline 643
 063B           ;                       }
 063B           ;               }
 063B           ;       }
 063B           ;       else if(STATE == INITIALIZE)
 063B 62D000            mov REG[0xd0],>_STATE
 063E 3C0000            cmp [_STATE],0
 0641 B051              jnz L138
 0643 3C0108            cmp [_STATE+1],8
 0646 B04C              jnz L138
 0648           X25:
 0648                   .dbline 644
 0648           ;       {
 0648                   .dbline 645
 0648           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0648 10                push X
 0649 7C0000            xcall _INIT_RX_cReadChar
 064C 62D000            mov REG[0xd0],>__r0
 064F 20                pop X
 0650 39FF              cmp A,-1
 0652 B040              jnz L140
 0654                   .dbline 646
 0654           ;               {
 0654                   .dbline 648
 0654           ;                       // We officially have a transmission.
 0654           ;                       if(INIT_RX_cGetChar() == SERVO_START)
 0654 10                push X
 0655 7C0000            xcall _INIT_RX_cGetChar
 0658 62D000            mov REG[0xd0],>__r0
 065B 20                pop X
 065C 39FF              cmp A,-1
 065E B034              jnz L142
 0660                   .dbline 649
 0660           ;                       {
 0660                   .dbline 652
 0660           ;                               // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0660           ;                               // and store them in the proper variables for actions to be taken later.
 0660           ;                               COMMAND_SOURCE = INIT_RX_cGetChar();
 0660 10                push X
 0661 7C0000            xcall _INIT_RX_cGetChar
 0664 20                pop X
 0665 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0668 5300              mov [_COMMAND_SOURCE],A
 066A                   .dbline 653
 066A           ;                               COMMAND_LENGTH = INIT_RX_cGetChar();
 066A 10                push X
 066B 7C0000            xcall _INIT_RX_cGetChar
 066E 20                pop X
 066F 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0672 5300              mov [_COMMAND_LENGTH],A
 0674                   .dbline 654
 0674           ;                               COMMAND_ERROR = INIT_RX_cGetChar();
 0674 10                push X
 0675 7C0000            xcall _INIT_RX_cGetChar
 0678 20                pop X
 0679 62D000            mov REG[0xd0],>_COMMAND_ERROR
 067C 5300              mov [_COMMAND_ERROR],A
 067E                   .dbline 655
 067E           ;                               COMMAND_PARAM = INIT_RX_cGetChar();
 067E 10                push X
 067F 7C0000            xcall _INIT_RX_cGetChar
 0682 20                pop X
 0683 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0686 5300              mov [_COMMAND_PARAM],A
 0688                   .dbline 657
 0688           ;                               
 0688           ;                               return 1;
 0688 62D000            mov REG[0xd0],>__r0
 068B 550001            mov [__r1],1
 068E 550000            mov [__r0],0
 0691 800A              xjmp L37
 0693           L142:
 0693                   .dbline 659
 0693           ;                       }
 0693           ;               }
 0693           L140:
 0693                   .dbline 660
 0693           ;       }
 0693           L138:
 0693           L121:
 0693           L103:
 0693           L85:
 0693           L67:
 0693           L57:
 0693           L39:
 0693                   .dbline 662
 0693           ;       
 0693           ;       return 0;
 0693 62D000            mov REG[0xd0],>__r0
 0696 550000            mov [__r1],0
 0699 550000            mov [__r0],0
 069C                   .dbline -2
 069C           L37:
 069C 38FD              add SP,-3
 069E 20                pop X
 069F                   .dbline 0 ; func end
 069F 7F                ret
 06A0                   .dbsym l i 1 I
 06A0                   .dbsym l tempByte 0 c
 06A0                   .dbend
 06A0                   .dbfunc e takeAction _takeAction fV
 06A0           ;              j -> X+4
 06A0           ;              i -> X+2
 06A0           ;              i -> X+0
 06A0           _takeAction::
 06A0                   .dbline -1
 06A0 10                push X
 06A1 4F                mov X,SP
 06A2 3806              add SP,6
 06A4                   .dbline 668
 06A4           ; }
 06A4           ; 
 06A4           ; // This function interprets what has been read by the command ready function
 06A4           ; // and performs the appropriate action.
 06A4           ; void takeAction(void)
 06A4           ; {
 06A4                   .dbline 669
 06A4           ;       int i = 0;                                                      // An index variable for looping.
 06A4 560100            mov [X+1],0
 06A7 560000            mov [X+0],0
 06AA                   .dbline 671
 06AA           ;       
 06AA           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 06AA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06AD 3C00C8            cmp [_COMMAND_TYPE],-56
 06B0 B039              jnz L145
 06B2                   .dbline 672
 06B2           ;       {
 06B2                   .dbline 673
 06B2           ;               if(!CONFIGURED)
 06B2 62D000            mov REG[0xd0],>_CONFIGURED
 06B5 3C0000            cmp [_CONFIGURED],0
 06B8 B00A              jnz L147
 06BA 3C0100            cmp [_CONFIGURED+1],0
 06BD B005              jnz L147
 06BF           X26:
 06BF                   .dbline 674
 06BF           ;               {
 06BF                   .dbline 676
 06BF           ;                       // Announce this module's presence if not configured.
 06BF           ;                       sayHello();
 06BF 998E              xcall _sayHello
 06C1                   .dbline 677
 06C1           ;               }
 06C1 820D              xjmp L146
 06C3           L147:
 06C3                   .dbline 678
 06C3           ;               else if(!CHILD)
 06C3 62D000            mov REG[0xd0],>_CHILD
 06C6 3C0000            cmp [_CHILD],0
 06C9 B014              jnz L149
 06CB                   .dbline 679
 06CB           ;               {
 06CB                   .dbline 681
 06CB           ;                       // Listen for children if we have none.
 06CB           ;                       if(childListen())
 06CB 94F0              xcall _childListen
 06CD 62D000            mov REG[0xd0],>__r0
 06D0 3C0000            cmp [__r0],0
 06D3 B006              jnz X27
 06D5 3C0000            cmp [__r1],0
 06D8 A1F6              jz L146
 06DA           X27:
 06DA                   .dbline 682
 06DA           ;                       {
 06DA                   .dbline 684
 06DA           ;                               // If a child was heard saying hello, forward the command with the port number added.
 06DA           ;                               sayHello();
 06DA 9973              xcall _sayHello
 06DC                   .dbline 685
 06DC           ;                       }
 06DC                   .dbline 686
 06DC           ;               }
 06DC 81F2              xjmp L146
 06DE           L149:
 06DE                   .dbline 687
 06DE           ;               else if(CHILD)
 06DE 62D000            mov REG[0xd0],>_CHILD
 06E1 3C0000            cmp [_CHILD],0
 06E4 A1EA              jz L146
 06E6                   .dbline 688
 06E6           ;               {
 06E6                   .dbline 690
 06E6           ;                       // If you have a child established, listen to that child.
 06E6           ;                       childResponse();
 06E6 952D              xcall _childResponse
 06E8                   .dbline 691
 06E8           ;               }
 06E8                   .dbline 692
 06E8           ;       }
 06E8 81E6              xjmp L146
 06EA           L145:
 06EA                   .dbline 693
 06EA           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 06EA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06ED 3C00CB            cmp [_COMMAND_TYPE],-53
 06F0 B021              jnz L155
 06F2                   .dbline 694
 06F2           ;       {
 06F2                   .dbline 696
 06F2           ;               // If this is to me, act accordingly.
 06F2           ;               if(COMMAND_DESTINATION == ID)
 06F2 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 06F5 5100              mov A,[_COMMAND_DESTINATION]
 06F7 62D000            mov REG[0xd0],>_ID
 06FA 3A00              cmp A,[_ID]
 06FC B005              jnz L157
 06FE                   .dbline 697
 06FE           ;               {
 06FE                   .dbline 699
 06FE           ;                       // Ping back to the master.
 06FE           ;                       pingResponse();
 06FE 9272              xcall _pingResponse
 0700                   .dbline 700
 0700           ;               }
 0700 81CE              xjmp L156
 0702           L157:
 0702                   .dbline 701
 0702           ;               else if(COMMAND_DESTINATION > ID)
 0702 62D000            mov REG[0xd0],>_ID
 0705 5100              mov A,[_ID]
 0707 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 070A 3A00              cmp A,[_COMMAND_DESTINATION]
 070C D1C2              jnc L156
 070E           X28:
 070E                   .dbline 702
 070E           ;               {
 070E                   .dbline 704
 070E           ;                       // If you have a child established, listen to that child.
 070E           ;                       childResponse();
 070E 9505              xcall _childResponse
 0710                   .dbline 705
 0710           ;               }
 0710                   .dbline 706
 0710           ;       }
 0710 81BE              xjmp L156
 0712           L155:
 0712                   .dbline 707
 0712           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 0712 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0715 3C00C9            cmp [_COMMAND_TYPE],-55
 0718 B110              jnz L161
 071A                   .dbline 708
 071A           ;       {
 071A                   .dbline 710
 071A           ;               // If this is meant for me, change my ID.
 071A           ;               if(COMMAND_DESTINATION == ID)
 071A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 071D 5100              mov A,[_COMMAND_DESTINATION]
 071F 62D000            mov REG[0xd0],>_ID
 0722 3A00              cmp A,[_ID]
 0724 B0F4              jnz L163
 0726                   .dbline 711
 0726           ;               {
 0726                   .dbline 712
 0726           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0726 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0729 5000              mov A,0
 072B 3A00              cmp A,[_COMMAND_PARAM]
 072D D1A1              jnc L162
 072F           X29:
 072F 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0732 3C00FB            cmp [_COMMAND_PARAM],-5
 0735 D199              jnc L162
 0737           X30:
 0737                   .dbline 713
 0737           ;                       {
 0737                   .dbline 715
 0737           ;                               // Assign this module the ID that has been passed by the master.
 0737           ;                               ID = COMMAND_PARAM;
 0737 62D000            mov REG[0xd0],>_COMMAND_PARAM
 073A 5100              mov A,[_COMMAND_PARAM]
 073C 62D000            mov REG[0xd0],>_ID
 073F 5300              mov [_ID],A
 0741                   .dbline 718
 0741           ;                               
 0741           ;                               // This module is now configured.
 0741           ;                               CONFIGURED = 1;
 0741 62D000            mov REG[0xd0],>_CONFIGURED
 0744 550101            mov [_CONFIGURED+1],1
 0747 550000            mov [_CONFIGURED],0
 074A                   .dbline 721
 074A           ;                               
 074A           ;                               // If the servo ID doesn't match what we want, change it to match.
 074A           ;                               if(ID != SERVO_ID)
 074A 62D000            mov REG[0xd0],>_ID
 074D 5100              mov A,[_ID]
 074F 62D000            mov REG[0xd0],>_SERVO_ID
 0752 3A00              cmp A,[_SERVO_ID]
 0754 A0A8              jz L167
 0756                   .dbline 722
 0756           ;                               {
 0756                   .dbline 729
 0756           ;                                       // These are our index variables for communication attempt timeouts.
 0756           ;                                       int i;
 0756           ;                                       int j;
 0756           ;                                       
 0756           ;                                       //while(ID != SERVO_ID)
 0756           ;                                       
 0756           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0756 560500            mov [X+5],0
 0759 560400            mov [X+4],0
 075C           L169:
 075C                   .dbline 730
 075C           ;                                       {       
 075C                   .dbline 732
 075C           ;                                               // Send a request to change the servo ID to match the controller ID.
 075C           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 075C 62D000            mov REG[0xd0],>_ID
 075F 5100              mov A,[_ID]
 0761 08                push A
 0762 5003              mov A,3
 0764 08                push A
 0765 08                push A
 0766 5004              mov A,4
 0768 08                push A
 0769 62D000            mov REG[0xd0],>_SERVO_ID
 076C 5100              mov A,[_SERVO_ID]
 076E 08                push A
 076F 975A              xcall _servoInstruction
 0771 38FB              add SP,-5
 0773                   .dbline 735
 0773           ;                                       
 0773           ;                                               // Try to read the servo's ID several times.
 0773           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0773 560300            mov [X+3],0
 0776 560200            mov [X+2],0
 0779           L173:
 0779                   .dbline 736
 0779           ;                                               {
 0779                   .dbline 738
 0779           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0779           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0779 5000              mov A,0
 077B 08                push A
 077C 08                push A
 077D 5001              mov A,1
 077F 08                push A
 0780 5002              mov A,2
 0782 08                push A
 0783 50FE              mov A,-2
 0785 08                push A
 0786 9743              xcall _servoInstruction
 0788 38FB              add SP,-5
 078A 8043              xjmp L178
 078C           L177:
 078C                   .dbline 742
 078C           ;                                                       
 078C           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 078C           ;                                                       while(!TIMEOUT)
 078C           ;                                                       {
 078C                   .dbline 744
 078C           ;                                                               // If we have a command to interpret, read it.
 078C           ;                                                               if(commandReady())
 078C 9B30              xcall _commandReady
 078E 62D000            mov REG[0xd0],>__r0
 0791 3C0000            cmp [__r0],0
 0794 B006              jnz X31
 0796 3C0000            cmp [__r1],0
 0799 A034              jz L180
 079B           X31:
 079B                   .dbline 745
 079B           ;                                                               {
 079B                   .dbline 746
 079B           ;                                                                       if(!COMMAND_ERROR)
 079B 62D000            mov REG[0xd0],>_COMMAND_ERROR
 079E 3C0000            cmp [_COMMAND_ERROR],0
 07A1 B02C              jnz L182
 07A3                   .dbline 747
 07A3           ;                                                                       {
 07A3                   .dbline 749
 07A3           ;                                                                               // If we have a valid servo ID, exit the loop.
 07A3           ;                                                                               if(COMMAND_SOURCE == ID)
 07A3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 07A6 5100              mov A,[_COMMAND_SOURCE]
 07A8 62D000            mov REG[0xd0],>_ID
 07AB 3A00              cmp A,[_ID]
 07AD B020              jnz L184
 07AF                   .dbline 750
 07AF           ;                                                                               {
 07AF                   .dbline 752
 07AF           ;                                                                                       // Set the timeout flag to exit the while loop.
 07AF           ;                                                                                       TIMEOUT = 1;
 07AF 62D000            mov REG[0xd0],>_TIMEOUT
 07B2 550101            mov [_TIMEOUT+1],1
 07B5 550000            mov [_TIMEOUT],0
 07B8                   .dbline 754
 07B8           ;                                                                                       // Set i such that the for loop is exited.
 07B8           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 07B8 56030A            mov [X+3],10
 07BB 560200            mov [X+2],0
 07BE                   .dbline 756
 07BE           ;                                                                                       // Set j such that we exit the outer loop as well.
 07BE           ;                                                                                       j = SERVO_COMM_LOOPS;
 07BE 560502            mov [X+5],2
 07C1 560400            mov [X+4],0
 07C4                   .dbline 758
 07C4           ;                                                                                       // Store the ID value.
 07C4           ;                                                                                       SERVO_ID = ID;
 07C4 62D000            mov REG[0xd0],>_ID
 07C7 5100              mov A,[_ID]
 07C9 62D000            mov REG[0xd0],>_SERVO_ID
 07CC 5300              mov [_SERVO_ID],A
 07CE                   .dbline 759
 07CE           ;                                                                               }
 07CE           L184:
 07CE                   .dbline 760
 07CE           ;                                                                       }
 07CE           L182:
 07CE                   .dbline 761
 07CE           ;                                                               }
 07CE           L180:
 07CE                   .dbline 762
 07CE           ;                                                       }
 07CE           L178:
 07CE                   .dbline 741
 07CE 62D000            mov REG[0xd0],>_TIMEOUT
 07D1 3C0000            cmp [_TIMEOUT],0
 07D4 B006              jnz X32
 07D6 3C0100            cmp [_TIMEOUT+1],0
 07D9 AFB2              jz L177
 07DB           X32:
 07DB                   .dbline 763
 07DB           ;                                               }
 07DB           L174:
 07DB                   .dbline 735
 07DB 7703              inc [X+3]
 07DD 0F0200            adc [X+2],0
 07E0                   .dbline 735
 07E0 5203              mov A,[X+3]
 07E2 110A              sub A,10
 07E4 5202              mov A,[X+2]
 07E6 3180              xor A,-128
 07E8 1980              sbb A,(0 ^ 0x80)
 07EA CF8E              jc L173
 07EC           X33:
 07EC                   .dbline 764
 07EC           ;                                       }       
 07EC           L170:
 07EC                   .dbline 729
 07EC 7705              inc [X+5]
 07EE 0F0400            adc [X+4],0
 07F1                   .dbline 729
 07F1 5205              mov A,[X+5]
 07F3 1102              sub A,2
 07F5 5204              mov A,[X+4]
 07F7 3180              xor A,-128
 07F9 1980              sbb A,(0 ^ 0x80)
 07FB CF60              jc L169
 07FD           X34:
 07FD                   .dbline 765
 07FD           ;                               }
 07FD           L167:
 07FD                   .dbline 767
 07FD           ;                               
 07FD           ;                               if(ID != SERVO_ID)
 07FD 62D000            mov REG[0xd0],>_ID
 0800 5100              mov A,[_ID]
 0802 62D000            mov REG[0xd0],>_SERVO_ID
 0805 3A00              cmp A,[_SERVO_ID]
 0807 A00D              jz L186
 0809                   .dbline 768
 0809           ;                               {
 0809                   .dbline 770
 0809           ;                                       // Toggle back to normal wait mode.
 0809           ;                                       configToggle(WAIT);
 0809 5000              mov A,0
 080B 08                push A
 080C 5001              mov A,1
 080E 08                push A
 080F 98A3              xcall _configToggle
 0811 38FE              add SP,-2
 0813                   .dbline 771
 0813           ;                               }
 0813 80BB              xjmp L162
 0815           L186:
 0815                   .dbline 773
 0815           ;                               else
 0815           ;                               {
 0815                   .dbline 775
 0815           ;                                       // Let the master node know that you got the ID assignment.
 0815           ;                                       assignedID();
 0815 9307              xcall _assignedID
 0817                   .dbline 776
 0817           ;                               }
 0817                   .dbline 777
 0817           ;                       }
 0817                   .dbline 778
 0817           ;               }
 0817 80B7              xjmp L162
 0819           L163:
 0819                   .dbline 779
 0819           ;               else if(COMMAND_DESTINATION > ID)
 0819 62D000            mov REG[0xd0],>_ID
 081C 5100              mov A,[_ID]
 081E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0821 3A00              cmp A,[_COMMAND_DESTINATION]
 0823 D0AB              jnc L162
 0825           X35:
 0825                   .dbline 780
 0825           ;               {
 0825                   .dbline 782
 0825           ;                       // Switch to listen to your child.
 0825           ;                       childResponse();
 0825 93EE              xcall _childResponse
 0827                   .dbline 783
 0827           ;               }
 0827                   .dbline 784
 0827           ;       }
 0827 80A7              xjmp L162
 0829           L161:
 0829                   .dbline 785
 0829           ;       else if(COMMAND_TYPE == CLEAR_CONFIG)   // The master wants to clear one or all configurations.
 0829 62D000            mov REG[0xd0],>_COMMAND_TYPE
 082C 3C00CC            cmp [_COMMAND_TYPE],-52
 082F B03D              jnz L190
 0831                   .dbline 786
 0831           ;       {
 0831                   .dbline 788
 0831           ;               // Only respond if this is directly to me and not a mass config clear.
 0831           ;               if(COMMAND_DESTINATION == ID)
 0831 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0834 5100              mov A,[_COMMAND_DESTINATION]
 0836 62D000            mov REG[0xd0],>_ID
 0839 3A00              cmp A,[_ID]
 083B B003              jnz L192
 083D                   .dbline 789
 083D           ;               {
 083D                   .dbline 790
 083D           ;                       configCleared();        // Notify the master that I am clearing my config.
 083D 9094              xcall _configCleared
 083F                   .dbline 791
 083F           ;               }
 083F           L192:
 083F                   .dbline 796
 083F           ;               
 083F           ;               // If this is meant for me, deconfigure.  Also, if a module ahead of you is
 083F           ;               // getting deconfigured, you have no choice but to deconfigure as well to
 083F           ;               // avoid errors on reconfiguration.
 083F           ;               if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
 083F 62D000            mov REG[0xd0],>_ID
 0842 5100              mov A,[_ID]
 0844 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0847 3A00              cmp A,[_COMMAND_DESTINATION]
 0849 D009              jnc L196
 084B           X36:
 084B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 084E 3C00FE            cmp [_COMMAND_DESTINATION],-2
 0851 B016              jnz L194
 0853           L196:
 0853                   .dbline 797
 0853           ;               {
 0853                   .dbline 798
 0853           ;                       ID = DEFAULT_ID;        // Reset my ID to the default.
 0853 62D000            mov REG[0xd0],>_ID
 0856 5500FB            mov [_ID],-5
 0859                   .dbline 799
 0859           ;                       CONFIGURED = 0;         // I am no longer configured.
 0859 62D000            mov REG[0xd0],>_CONFIGURED
 085C 550100            mov [_CONFIGURED+1],0
 085F 550000            mov [_CONFIGURED],0
 0862                   .dbline 800
 0862           ;                       CHILD = 0;                      // No one can depend on you anymore.
 0862 62D000            mov REG[0xd0],>_CHILD
 0865 550000            mov [_CHILD],0
 0868                   .dbline 801
 0868           ;               }
 0868           L194:
 0868                   .dbline 812
 0868           ; //            else if(COMMAND_DESTINATION > ID)
 0868           ; //            {
 0868           ; //                    // Switch to listen to your child.
 0868           ; //                    childResponse();
 0868           ; //                    // Switch back to wait for a master response.
 0868           ; //                    configToggle(WAIT);
 0868           ; //            }
 0868           ; //            Going to also have to take into account of this is my child.
 0868           ;               
 0868           ;               // Turn off the LED.
 0868           ;               PRT2DR |= 0b00000001;
 0868 430801            or REG[0x8],1
 086B                   .dbline 813
 086B           ;       }
 086B 8063              xjmp L191
 086D           L190:
 086D                   .dbline 814
 086D           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 086D 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0870 3C0001            cmp [_COMMAND_TYPE],1
 0873 A006              jz L199
 0875 3C0002            cmp [_COMMAND_TYPE],2
 0878 B056              jnz L197
 087A           L199:
 087A                   .dbline 815
 087A           ;       {
 087A                   .dbline 816
 087A           ;               if(COMMAND_DESTINATION > ID)
 087A 62D000            mov REG[0xd0],>_ID
 087D 5100              mov A,[_ID]
 087F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0882 3A00              cmp A,[_COMMAND_DESTINATION]
 0884 D005              jnc L200
 0886           X37:
 0886                   .dbline 817
 0886           ;               {
 0886                   .dbline 819
 0886           ;                       // Allow the child response through.
 0886           ;                       childResponse();
 0886 938D              xcall _childResponse
 0888                   .dbline 820
 0888           ;               }
 0888 8046              xjmp L201
 088A           L200:
 088A                   .dbline 821
 088A           ;               else if(COMMAND_DESTINATION <= ID)
 088A 62D000            mov REG[0xd0],>_ID
 088D 5100              mov A,[_ID]
 088F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0892 3A00              cmp A,[_COMMAND_DESTINATION]
 0894 C03A              jc L202
 0896           X38:
 0896                   .dbline 822
 0896           ;               {
 0896           L204:
 0896                   .dbline 824
 0896           ;                       // Sit and spin while we wait for the transmission to start.
 0896           ;                       while(WAIT_RECV_cReadChar() != SERVO_START) { }
 0896                   .dbline 824
 0896           L205:
 0896                   .dbline 824
 0896 10                push X
 0897 7C0000            xcall _WAIT_RECV_cReadChar
 089A 62D000            mov REG[0xd0],>__r0
 089D 20                pop X
 089E 39FF              cmp A,-1
 08A0 BFF5              jnz L204
 08A2                   .dbline 827
 08A2           ;                       
 08A2           ;                       // Reset the index variable.
 08A2           ;                       i = 0;
 08A2 560100            mov [X+1],0
 08A5 560000            mov [X+0],0
 08A8 801A              xjmp L208
 08AA           L207:
 08AA                   .dbline 832
 08AA           ;                       
 08AA           ;                       // Wait for the transmission to go through.
 08AA           ;                       // If no chars are read for RESPONSE_ITERATIONS iterations, move on.
 08AA           ;                       while(i < RESPONSE_ITERATIONS)
 08AA           ;                       {
 08AA                   .dbline 833
 08AA           ;                               if(WAIT_RECV_cReadChar())
 08AA 10                push X
 08AB 7C0000            xcall _WAIT_RECV_cReadChar
 08AE 62D000            mov REG[0xd0],>__r0
 08B1 20                pop X
 08B2 3900              cmp A,0
 08B4 A009              jz L210
 08B6                   .dbline 834
 08B6           ;                               {
 08B6                   .dbline 835
 08B6           ;                                       i = 0;
 08B6 560100            mov [X+1],0
 08B9 560000            mov [X+0],0
 08BC                   .dbline 836
 08BC           ;                               }
 08BC 8006              xjmp L211
 08BE           L210:
 08BE                   .dbline 838
 08BE           ;                               else
 08BE           ;                               {
 08BE                   .dbline 839
 08BE           ;                                       i++;
 08BE 7701              inc [X+1]
 08C0 0F0000            adc [X+0],0
 08C3                   .dbline 840
 08C3           ;                               }
 08C3           L211:
 08C3                   .dbline 841
 08C3           ;                       }
 08C3           L208:
 08C3                   .dbline 831
 08C3 5201              mov A,[X+1]
 08C5 110A              sub A,10
 08C7 5200              mov A,[X+0]
 08C9 3180              xor A,-128
 08CB 1980              sbb A,(0 ^ 0x80)
 08CD CFDC              jc L207
 08CF           X39:
 08CF                   .dbline 842
 08CF           ;               }
 08CF           L202:
 08CF           L201:
 08CF                   .dbline 843
 08CF           ;       }
 08CF           L197:
 08CF           L191:
 08CF           L162:
 08CF           L156:
 08CF           L146:
 08CF                   .dbline -2
 08CF           L144:
 08CF 38FA              add SP,-6
 08D1 20                pop X
 08D2                   .dbline 0 ; func end
 08D2 7F                ret
 08D3                   .dbsym l j 4 I
 08D3                   .dbsym l i 2 I
 08D3                   .dbsym l i 0 I
 08D3                   .dbend
 08D3                   .dbfunc e configCleared _configCleared fV
 08D3           _configCleared::
 08D3                   .dbline -1
 08D3                   .dbline 848
 08D3           ; }
 08D3           ; 
 08D3           ; // This function sends out an acknowledgement of a configuration reset.
 08D3           ; void configCleared(void)
 08D3           ; {
 08D3                   .dbline 849
 08D3           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 08D3 5000              mov A,0
 08D5 08                push A
 08D6 5002              mov A,2
 08D8 08                push A
 08D9 7C00B4            xcall _configToggle
 08DC 38FE              add SP,-2
 08DE                   .dbline 852
 08DE           ;       
 08DE           ;       // Transmit a ping to everyone.
 08DE           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 08DE 10                push X
 08DF 50FC              mov A,-4
 08E1 7C0000            xcall _TX_014_PutChar
 08E4 20                pop X
 08E5                   .dbline 853
 08E5           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 08E5 10                push X
 08E6 50FC              mov A,-4
 08E8 7C0000            xcall _TX_23_PutChar
 08EB 20                pop X
 08EC                   .dbline 854
 08EC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 08EC 10                push X
 08ED 50FC              mov A,-4
 08EF 7C0000            xcall _TX_014_PutChar
 08F2 20                pop X
 08F3                   .dbline 855
 08F3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 08F3 10                push X
 08F4 50FC              mov A,-4
 08F6 7C0000            xcall _TX_23_PutChar
 08F9 20                pop X
 08FA                   .dbline 856
 08FA           ;       TX_014_PutChar(ID);                             // My ID
 08FA 10                push X
 08FB 62D000            mov REG[0xd0],>_ID
 08FE 5100              mov A,[_ID]
 0900 7C0000            xcall _TX_014_PutChar
 0903 20                pop X
 0904                   .dbline 857
 0904           ;       TX_23_PutChar(ID);                              // My ID
 0904 10                push X
 0905 62D000            mov REG[0xd0],>_ID
 0908 5100              mov A,[_ID]
 090A 7C0000            xcall _TX_23_PutChar
 090D 20                pop X
 090E                   .dbline 858
 090E           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 090E 10                push X
 090F 5000              mov A,0
 0911 7C0000            xcall _TX_014_PutChar
 0914 20                pop X
 0915                   .dbline 859
 0915           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0915 10                push X
 0916 5000              mov A,0
 0918 7C0000            xcall _TX_23_PutChar
 091B 20                pop X
 091C                   .dbline 860
 091C           ;       TX_014_PutChar(CONFIG_CLEARED); // This is a ping response
 091C 10                push X
 091D 50CD              mov A,-51
 091F 7C0000            xcall _TX_014_PutChar
 0922 20                pop X
 0923                   .dbline 861
 0923           ;       TX_23_PutChar(CONFIG_CLEARED);  // This is a ping response
 0923 10                push X
 0924 50CD              mov A,-51
 0926 7C0000            xcall _TX_23_PutChar
 0929 20                pop X
 092A                   .dbline 862
 092A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 092A 10                push X
 092B 50FD              mov A,-3
 092D 7C0000            xcall _TX_014_PutChar
 0930 20                pop X
 0931                   .dbline 863
 0931           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0931 10                push X
 0932 50FD              mov A,-3
 0934 7C0000            xcall _TX_23_PutChar
 0937 20                pop X
 0938                   .dbline 864
 0938           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0938 10                push X
 0939 50FD              mov A,-3
 093B 7C0000            xcall _TX_014_PutChar
 093E 20                pop X
 093F                   .dbline 865
 093F           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 093F 10                push X
 0940 50FD              mov A,-3
 0942 7C0000            xcall _TX_23_PutChar
 0945 20                pop X
 0946           L213:
 0946                   .dbline 868
 0946           ;       
 0946           ;       // Wait for the transmission to finish.
 0946           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0946           L214:
 0946                   .dbline 868
 0946 10                push X
 0947 7C0000            xcall _TX_014_bReadTxStatus
 094A 62D000            mov REG[0xd0],>__r0
 094D 20                pop X
 094E 5300              mov [__r0],A
 0950 470020            tst [__r0],32
 0953 AFF2              jz L213
 0955           L216:
 0955                   .dbline 869
 0955           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0955           L217:
 0955                   .dbline 869
 0955 10                push X
 0956 7C0000            xcall _TX_23_bReadTxStatus
 0959 62D000            mov REG[0xd0],>__r0
 095C 20                pop X
 095D 5300              mov [__r0],A
 095F 470020            tst [__r0],32
 0962 AFF2              jz L216
 0964                   .dbline 872
 0964           ;       
 0964           ;       // Make completely sure we're done.
 0964           ;       xmitWait();
 0964 9643              xcall _xmitWait
 0966                   .dbline 874
 0966           ;       
 0966           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0966 5000              mov A,0
 0968 08                push A
 0969 5001              mov A,1
 096B 08                push A
 096C 7C00B4            xcall _configToggle
 096F 38FE              add SP,-2
 0971                   .dbline -2
 0971           L212:
 0971                   .dbline 0 ; func end
 0971 7F                ret
 0972                   .dbend
 0972                   .dbfunc e pingResponse _pingResponse fV
 0972           _pingResponse::
 0972                   .dbline -1
 0972                   .dbline 879
 0972           ; }
 0972           ; 
 0972           ; // This function sends out a ping response for everyone to hear.
 0972           ; void pingResponse(void)
 0972           ; {
 0972                   .dbline 880
 0972           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0972 5000              mov A,0
 0974 08                push A
 0975 5002              mov A,2
 0977 08                push A
 0978 7C00B4            xcall _configToggle
 097B 38FE              add SP,-2
 097D                   .dbline 883
 097D           ;       
 097D           ;       // Transmit a ping to everyone.
 097D           ;       TX_014_PutChar(START_TRANSMIT);         // Start byte one
 097D 10                push X
 097E 50FC              mov A,-4
 0980 7C0000            xcall _TX_014_PutChar
 0983 20                pop X
 0984                   .dbline 884
 0984           ;       TX_23_PutChar(START_TRANSMIT);          // Start byte one
 0984 10                push X
 0985 50FC              mov A,-4
 0987 7C0000            xcall _TX_23_PutChar
 098A 20                pop X
 098B                   .dbline 885
 098B           ;       TX_014_PutChar(START_TRANSMIT);         // Start byte two
 098B 10                push X
 098C 50FC              mov A,-4
 098E 7C0000            xcall _TX_014_PutChar
 0991 20                pop X
 0992                   .dbline 886
 0992           ;       TX_23_PutChar(START_TRANSMIT);          // Start byte two
 0992 10                push X
 0993 50FC              mov A,-4
 0995 7C0000            xcall _TX_23_PutChar
 0998 20                pop X
 0999                   .dbline 887
 0999           ;       TX_014_PutChar(ID);                                     // My ID
 0999 10                push X
 099A 62D000            mov REG[0xd0],>_ID
 099D 5100              mov A,[_ID]
 099F 7C0000            xcall _TX_014_PutChar
 09A2 20                pop X
 09A3                   .dbline 888
 09A3           ;       TX_23_PutChar(ID);                                      // My ID
 09A3 10                push X
 09A4 62D000            mov REG[0xd0],>_ID
 09A7 5100              mov A,[_ID]
 09A9 7C0000            xcall _TX_23_PutChar
 09AC 20                pop X
 09AD                   .dbline 889
 09AD           ;       TX_014_PutChar(MASTER_ID);                      // Destination ID (master)
 09AD 10                push X
 09AE 5000              mov A,0
 09B0 7C0000            xcall _TX_014_PutChar
 09B3 20                pop X
 09B4                   .dbline 890
 09B4           ;       TX_23_PutChar(MASTER_ID);                       // Destination ID (master)
 09B4 10                push X
 09B5 5000              mov A,0
 09B7 7C0000            xcall _TX_23_PutChar
 09BA 20                pop X
 09BB                   .dbline 891
 09BB           ;       TX_014_PutChar(PING);                           // This is a ping response
 09BB 10                push X
 09BC 50CB              mov A,-53
 09BE 7C0000            xcall _TX_014_PutChar
 09C1 20                pop X
 09C2                   .dbline 892
 09C2           ;       TX_23_PutChar(PING);                            // This is a ping response
 09C2 10                push X
 09C3 50CB              mov A,-53
 09C5 7C0000            xcall _TX_23_PutChar
 09C8 20                pop X
 09C9                   .dbline 893
 09C9           ;       TX_014_PutChar(UPSTREAM_MSB);           // Upstream MSB of length
 09C9 10                push X
 09CA 5013              mov A,19
 09CC 7C0000            xcall _TX_014_PutChar
 09CF 20                pop X
 09D0                   .dbline 894
 09D0           ;       TX_23_PutChar(UPSTREAM_MSB);            // Upstream MSB of length
 09D0 10                push X
 09D1 5013              mov A,19
 09D3 7C0000            xcall _TX_23_PutChar
 09D6 20                pop X
 09D7                   .dbline 895
 09D7           ;       TX_014_PutChar(UPSTREAM_LSB);           // Upstream LSB of length
 09D7 10                push X
 09D8 5088              mov A,-120
 09DA 7C0000            xcall _TX_014_PutChar
 09DD 20                pop X
 09DE                   .dbline 896
 09DE           ;       TX_23_PutChar(UPSTREAM_LSB);            // Upstream LSB of length
 09DE 10                push X
 09DF 5088              mov A,-120
 09E1 7C0000            xcall _TX_23_PutChar
 09E4 20                pop X
 09E5                   .dbline 897
 09E5           ;       TX_014_PutChar(DOWNSTREAM_MSB);         // Downstream MSB of length
 09E5 10                push X
 09E6 5013              mov A,19
 09E8 7C0000            xcall _TX_014_PutChar
 09EB 20                pop X
 09EC                   .dbline 898
 09EC           ;       TX_23_PutChar(DOWNSTREAM_MSB);          // Downstream MSB of length
 09EC 10                push X
 09ED 5013              mov A,19
 09EF 7C0000            xcall _TX_23_PutChar
 09F2 20                pop X
 09F3                   .dbline 899
 09F3           ;       TX_014_PutChar(DOWNSTREAM_LSB);         // Downstream LSB of length
 09F3 10                push X
 09F4 5088              mov A,-120
 09F6 7C0000            xcall _TX_014_PutChar
 09F9 20                pop X
 09FA                   .dbline 900
 09FA           ;       TX_23_PutChar(DOWNSTREAM_LSB);          // Downstream LSB of length
 09FA 10                push X
 09FB 5088              mov A,-120
 09FD 7C0000            xcall _TX_23_PutChar
 0A00 20                pop X
 0A01                   .dbline 901
 0A01           ;       TX_014_PutChar(ANGLE_OFFSET_MSB);       // Angle offset MSB
 0A01 10                push X
 0A02 5001              mov A,1
 0A04 7C0000            xcall _TX_014_PutChar
 0A07 20                pop X
 0A08                   .dbline 902
 0A08           ;       TX_23_PutChar(ANGLE_OFFSET_MSB);        // Angle offset MSB
 0A08 10                push X
 0A09 5001              mov A,1
 0A0B 7C0000            xcall _TX_23_PutChar
 0A0E 20                pop X
 0A0F                   .dbline 903
 0A0F           ;       TX_014_PutChar(ANGLE_OFFSET_LSB);       // Angle offset LSB
 0A0F 10                push X
 0A10 50FF              mov A,-1
 0A12 7C0000            xcall _TX_014_PutChar
 0A15 20                pop X
 0A16                   .dbline 904
 0A16           ;       TX_23_PutChar(ANGLE_OFFSET_LSB);        // Angle offset LSB
 0A16 10                push X
 0A17 50FF              mov A,-1
 0A19 7C0000            xcall _TX_23_PutChar
 0A1C 20                pop X
 0A1D                   .dbline 905
 0A1D           ;       TX_014_PutChar(CHILD);                          // Child value
 0A1D 10                push X
 0A1E 62D000            mov REG[0xd0],>_CHILD
 0A21 5100              mov A,[_CHILD]
 0A23 7C0000            xcall _TX_014_PutChar
 0A26 20                pop X
 0A27                   .dbline 906
 0A27           ;       TX_23_PutChar(CHILD);                           // Child value
 0A27 10                push X
 0A28 62D000            mov REG[0xd0],>_CHILD
 0A2B 5100              mov A,[_CHILD]
 0A2D 7C0000            xcall _TX_23_PutChar
 0A30 20                pop X
 0A31                   .dbline 907
 0A31           ;       TX_014_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0A31 10                push X
 0A32 50FD              mov A,-3
 0A34 7C0000            xcall _TX_014_PutChar
 0A37 20                pop X
 0A38                   .dbline 908
 0A38           ;       TX_23_PutChar(END_TRANSMIT);            // This is the end of this transmission
 0A38 10                push X
 0A39 50FD              mov A,-3
 0A3B 7C0000            xcall _TX_23_PutChar
 0A3E 20                pop X
 0A3F                   .dbline 909
 0A3F           ;       TX_014_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0A3F 10                push X
 0A40 50FD              mov A,-3
 0A42 7C0000            xcall _TX_014_PutChar
 0A45 20                pop X
 0A46                   .dbline 910
 0A46           ;       TX_23_PutChar(END_TRANSMIT);            // This is the end of this transmission
 0A46 10                push X
 0A47 50FD              mov A,-3
 0A49 7C0000            xcall _TX_23_PutChar
 0A4C 20                pop X
 0A4D           L220:
 0A4D                   .dbline 913
 0A4D           ;       
 0A4D           ;       // Wait for the transmission to finish.
 0A4D           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0A4D           L221:
 0A4D                   .dbline 913
 0A4D 10                push X
 0A4E 7C0000            xcall _TX_014_bReadTxStatus
 0A51 62D000            mov REG[0xd0],>__r0
 0A54 20                pop X
 0A55 5300              mov [__r0],A
 0A57 470020            tst [__r0],32
 0A5A AFF2              jz L220
 0A5C           L223:
 0A5C                   .dbline 914
 0A5C           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0A5C           L224:
 0A5C                   .dbline 914
 0A5C 10                push X
 0A5D 7C0000            xcall _TX_23_bReadTxStatus
 0A60 62D000            mov REG[0xd0],>__r0
 0A63 20                pop X
 0A64 5300              mov [__r0],A
 0A66 470020            tst [__r0],32
 0A69 AFF2              jz L223
 0A6B                   .dbline 917
 0A6B           ;       
 0A6B           ;       // Make completely sure we're done.
 0A6B           ;       xmitWait();
 0A6B 953C              xcall _xmitWait
 0A6D                   .dbline 919
 0A6D           ;       
 0A6D           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A6D 5000              mov A,0
 0A6F 08                push A
 0A70 5001              mov A,1
 0A72 08                push A
 0A73 7C00B4            xcall _configToggle
 0A76 38FE              add SP,-2
 0A78                   .dbline -2
 0A78           L219:
 0A78                   .dbline 0 ; func end
 0A78 7F                ret
 0A79                   .dbend
 0A79                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A79           _unloadAllConfigs::
 0A79                   .dbline -1
 0A79                   .dbline 925
 0A79           ; }
 0A79           ; 
 0A79           ; // This function blindly unloads all user configurations. This will be called once,
 0A79           ; // when the system initially has no known state.
 0A79           ; void unloadAllConfigs(void)
 0A79           ; {
 0A79                   .dbline 926
 0A79           ;       UnloadConfig_waiting();
 0A79 7C0000            xcall _UnloadConfig_waiting
 0A7C                   .dbline 927
 0A7C           ;       UnloadConfig_hello();
 0A7C 7C0000            xcall _UnloadConfig_hello
 0A7F                   .dbline 928
 0A7F           ;       UnloadConfig_my_response();
 0A7F 7C0000            xcall _UnloadConfig_my_response
 0A82                   .dbline 929
 0A82           ;       UnloadConfig_response1();
 0A82 7C0000            xcall _UnloadConfig_response1
 0A85                   .dbline 930
 0A85           ;       UnloadConfig_response2();
 0A85 7C0000            xcall _UnloadConfig_response2
 0A88                   .dbline 931
 0A88           ;       UnloadConfig_response3();
 0A88 7C0000            xcall _UnloadConfig_response3
 0A8B                   .dbline 932
 0A8B           ;       UnloadConfig_response4();
 0A8B 7C0000            xcall _UnloadConfig_response4
 0A8E                   .dbline 933
 0A8E           ;       UnloadConfig_initial();
 0A8E 7C0000            xcall _UnloadConfig_initial
 0A91                   .dbline 934
 0A91           ;       UnloadConfig_servo_transmit();
 0A91 7C0000            xcall _UnloadConfig_servo_transmit
 0A94                   .dbline -2
 0A94           L226:
 0A94                   .dbline 0 ; func end
 0A94 7F                ret
 0A95                   .dbend
 0A95                   .dbfunc e unloadConfig _unloadConfig fV
 0A95           ;     config_num -> X-5
 0A95           _unloadConfig::
 0A95                   .dbline -1
 0A95 10                push X
 0A96 4F                mov X,SP
 0A97                   .dbline 940
 0A97           ; }
 0A97           ; 
 0A97           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A97           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A97           ; void unloadConfig(int config_num)
 0A97           ; {
 0A97                   .dbline 941
 0A97           ;       if(config_num == WAIT)
 0A97 3DFB00            cmp [X-5],0
 0A9A B00B              jnz L228
 0A9C 3DFC01            cmp [X-4],1
 0A9F B006              jnz L228
 0AA1           X40:
 0AA1                   .dbline 942
 0AA1           ;       {
 0AA1                   .dbline 943
 0AA1           ;               UnloadConfig_waiting();
 0AA1 7C0000            xcall _UnloadConfig_waiting
 0AA4                   .dbline 944
 0AA4           ;       }
 0AA4 8077              xjmp L229
 0AA6           L228:
 0AA6                   .dbline 945
 0AA6           ;       else if(config_num == HELLO_MODE)
 0AA6 3DFB00            cmp [X-5],0
 0AA9 B00B              jnz L230
 0AAB 3DFC07            cmp [X-4],7
 0AAE B006              jnz L230
 0AB0           X41:
 0AB0                   .dbline 946
 0AB0           ;       {
 0AB0                   .dbline 947
 0AB0           ;               UnloadConfig_hello();
 0AB0 7C0000            xcall _UnloadConfig_hello
 0AB3                   .dbline 948
 0AB3           ;       }
 0AB3 8068              xjmp L231
 0AB5           L230:
 0AB5                   .dbline 949
 0AB5           ;       else if(config_num == MY_RESPONSE)
 0AB5 3DFB00            cmp [X-5],0
 0AB8 B00B              jnz L232
 0ABA 3DFC02            cmp [X-4],2
 0ABD B006              jnz L232
 0ABF           X42:
 0ABF                   .dbline 950
 0ABF           ;       {
 0ABF                   .dbline 951
 0ABF           ;               UnloadConfig_my_response();
 0ABF 7C0000            xcall _UnloadConfig_my_response
 0AC2                   .dbline 952
 0AC2           ;       }
 0AC2 8059              xjmp L233
 0AC4           L232:
 0AC4                   .dbline 953
 0AC4           ;       else if(config_num == RESPONSE_1)
 0AC4 3DFB00            cmp [X-5],0
 0AC7 B00B              jnz L234
 0AC9 3DFC03            cmp [X-4],3
 0ACC B006              jnz L234
 0ACE           X43:
 0ACE                   .dbline 954
 0ACE           ;       {
 0ACE                   .dbline 955
 0ACE           ;               UnloadConfig_response1();
 0ACE 7C0000            xcall _UnloadConfig_response1
 0AD1                   .dbline 956
 0AD1           ;       }
 0AD1 804A              xjmp L235
 0AD3           L234:
 0AD3                   .dbline 957
 0AD3           ;       else if(config_num == RESPONSE_2)
 0AD3 3DFB00            cmp [X-5],0
 0AD6 B00B              jnz L236
 0AD8 3DFC04            cmp [X-4],4
 0ADB B006              jnz L236
 0ADD           X44:
 0ADD                   .dbline 958
 0ADD           ;       {
 0ADD                   .dbline 959
 0ADD           ;               UnloadConfig_response2();
 0ADD 7C0000            xcall _UnloadConfig_response2
 0AE0                   .dbline 960
 0AE0           ;       }
 0AE0 803B              xjmp L237
 0AE2           L236:
 0AE2                   .dbline 961
 0AE2           ;       else if(config_num == RESPONSE_3)
 0AE2 3DFB00            cmp [X-5],0
 0AE5 B00B              jnz L238
 0AE7 3DFC05            cmp [X-4],5
 0AEA B006              jnz L238
 0AEC           X45:
 0AEC                   .dbline 962
 0AEC           ;       {
 0AEC                   .dbline 963
 0AEC           ;               UnloadConfig_response3();
 0AEC 7C0000            xcall _UnloadConfig_response3
 0AEF                   .dbline 964
 0AEF           ;       }
 0AEF 802C              xjmp L239
 0AF1           L238:
 0AF1                   .dbline 965
 0AF1           ;       else if(config_num == RESPONSE_4)
 0AF1 3DFB00            cmp [X-5],0
 0AF4 B00B              jnz L240
 0AF6 3DFC06            cmp [X-4],6
 0AF9 B006              jnz L240
 0AFB           X46:
 0AFB                   .dbline 966
 0AFB           ;       {
 0AFB                   .dbline 967
 0AFB           ;               UnloadConfig_response4();
 0AFB 7C0000            xcall _UnloadConfig_response4
 0AFE                   .dbline 968
 0AFE           ;       }
 0AFE 801D              xjmp L241
 0B00           L240:
 0B00                   .dbline 969
 0B00           ;       else if(config_num == INITIALIZE)
 0B00 3DFB00            cmp [X-5],0
 0B03 B00B              jnz L242
 0B05 3DFC08            cmp [X-4],8
 0B08 B006              jnz L242
 0B0A           X47:
 0B0A                   .dbline 970
 0B0A           ;       {
 0B0A                   .dbline 971
 0B0A           ;               UnloadConfig_initial();
 0B0A 7C0000            xcall _UnloadConfig_initial
 0B0D                   .dbline 972
 0B0D           ;       }
 0B0D 800E              xjmp L243
 0B0F           L242:
 0B0F                   .dbline 973
 0B0F           ;       else if(config_num == SERVO_COMM)
 0B0F 3DFB00            cmp [X-5],0
 0B12 B009              jnz L244
 0B14 3DFC09            cmp [X-4],9
 0B17 B004              jnz L244
 0B19           X48:
 0B19                   .dbline 974
 0B19           ;       {
 0B19                   .dbline 975
 0B19           ;               UnloadConfig_servo_transmit();
 0B19 7C0000            xcall _UnloadConfig_servo_transmit
 0B1C                   .dbline 976
 0B1C           ;       }
 0B1C           L244:
 0B1C           L243:
 0B1C           L241:
 0B1C           L239:
 0B1C           L237:
 0B1C           L235:
 0B1C           L233:
 0B1C           L231:
 0B1C           L229:
 0B1C                   .dbline -2
 0B1C           L227:
 0B1C 20                pop X
 0B1D                   .dbline 0 ; func end
 0B1D 7F                ret
 0B1E                   .dbsym l config_num -5 I
 0B1E                   .dbend
 0B1E                   .dbfunc e assignedID _assignedID fV
 0B1E           _assignedID::
 0B1E                   .dbline -1
 0B1E                   .dbline 981
 0B1E           ; }
 0B1E           ; 
 0B1E           ; // This function responds that an ID has been assigned to it.
 0B1E           ; void assignedID(void)
 0B1E           ; {
 0B1E                   .dbline 982
 0B1E           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0B1E 5000              mov A,0
 0B20 08                push A
 0B21 5002              mov A,2
 0B23 08                push A
 0B24 7C00B4            xcall _configToggle
 0B27 38FE              add SP,-2
 0B29                   .dbline 985
 0B29           ;       
 0B29           ;       // Transmit a ping to everyone.
 0B29           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0B29 10                push X
 0B2A 50FC              mov A,-4
 0B2C 7C0000            xcall _TX_014_PutChar
 0B2F 20                pop X
 0B30                   .dbline 986
 0B30           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0B30 10                push X
 0B31 50FC              mov A,-4
 0B33 7C0000            xcall _TX_23_PutChar
 0B36 20                pop X
 0B37                   .dbline 987
 0B37           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0B37 10                push X
 0B38 50FC              mov A,-4
 0B3A 7C0000            xcall _TX_014_PutChar
 0B3D 20                pop X
 0B3E                   .dbline 988
 0B3E           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0B3E 10                push X
 0B3F 50FC              mov A,-4
 0B41 7C0000            xcall _TX_23_PutChar
 0B44 20                pop X
 0B45                   .dbline 989
 0B45           ;       TX_014_PutChar(ID);                             // My ID
 0B45 10                push X
 0B46 62D000            mov REG[0xd0],>_ID
 0B49 5100              mov A,[_ID]
 0B4B 7C0000            xcall _TX_014_PutChar
 0B4E 20                pop X
 0B4F                   .dbline 990
 0B4F           ;       TX_23_PutChar(ID);                              // My ID
 0B4F 10                push X
 0B50 62D000            mov REG[0xd0],>_ID
 0B53 5100              mov A,[_ID]
 0B55 7C0000            xcall _TX_23_PutChar
 0B58 20                pop X
 0B59                   .dbline 991
 0B59           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0B59 10                push X
 0B5A 5000              mov A,0
 0B5C 7C0000            xcall _TX_014_PutChar
 0B5F 20                pop X
 0B60                   .dbline 992
 0B60           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0B60 10                push X
 0B61 5000              mov A,0
 0B63 7C0000            xcall _TX_23_PutChar
 0B66 20                pop X
 0B67                   .dbline 993
 0B67           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0B67 10                push X
 0B68 50CA              mov A,-54
 0B6A 7C0000            xcall _TX_014_PutChar
 0B6D 20                pop X
 0B6E                   .dbline 994
 0B6E           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B6E 10                push X
 0B6F 50CA              mov A,-54
 0B71 7C0000            xcall _TX_23_PutChar
 0B74 20                pop X
 0B75                   .dbline 995
 0B75           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B75 10                push X
 0B76 50FD              mov A,-3
 0B78 7C0000            xcall _TX_014_PutChar
 0B7B 20                pop X
 0B7C                   .dbline 996
 0B7C           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B7C 10                push X
 0B7D 50FD              mov A,-3
 0B7F 7C0000            xcall _TX_23_PutChar
 0B82 20                pop X
 0B83                   .dbline 997
 0B83           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B83 10                push X
 0B84 50FD              mov A,-3
 0B86 7C0000            xcall _TX_014_PutChar
 0B89 20                pop X
 0B8A                   .dbline 998
 0B8A           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B8A 10                push X
 0B8B 50FD              mov A,-3
 0B8D 7C0000            xcall _TX_23_PutChar
 0B90 20                pop X
 0B91           L247:
 0B91                   .dbline 1001
 0B91           ;       
 0B91           ;       // Wait for the transmission to finish.
 0B91           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B91           L248:
 0B91                   .dbline 1001
 0B91 10                push X
 0B92 7C0000            xcall _TX_014_bReadTxStatus
 0B95 62D000            mov REG[0xd0],>__r0
 0B98 20                pop X
 0B99 5300              mov [__r0],A
 0B9B 470020            tst [__r0],32
 0B9E AFF2              jz L247
 0BA0           L250:
 0BA0                   .dbline 1002
 0BA0           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0BA0           L251:
 0BA0                   .dbline 1002
 0BA0 10                push X
 0BA1 7C0000            xcall _TX_23_bReadTxStatus
 0BA4 62D000            mov REG[0xd0],>__r0
 0BA7 20                pop X
 0BA8 5300              mov [__r0],A
 0BAA 470020            tst [__r0],32
 0BAD AFF2              jz L250
 0BAF                   .dbline 1005
 0BAF           ;       
 0BAF           ;       // Make completely sure we're done.
 0BAF           ;       xmitWait();
 0BAF 93F8              xcall _xmitWait
 0BB1                   .dbline 1007
 0BB1           ;       
 0BB1           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0BB1 5000              mov A,0
 0BB3 08                push A
 0BB4 5001              mov A,1
 0BB6 08                push A
 0BB7 7C00B4            xcall _configToggle
 0BBA 38FE              add SP,-2
 0BBC                   .dbline -2
 0BBC           L246:
 0BBC                   .dbline 0 ; func end
 0BBC 7F                ret
 0BBD                   .dbend
 0BBD                   .dbfunc e childListen _childListen fI
 0BBD           _childListen::
 0BBD                   .dbline -1
 0BBD                   .dbline 1012
 0BBD           ; }
 0BBD           ; 
 0BBD           ; // This function listens for children and registers the port that they talk to.
 0BBD           ; int childListen(void)
 0BBD           ; {
 0BBD                   .dbline 1013
 0BBD           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0BBD 5000              mov A,0
 0BBF 08                push A
 0BC0 5007              mov A,7
 0BC2 08                push A
 0BC3 7C00B4            xcall _configToggle
 0BC6 38FE              add SP,-2
 0BC8 801C              xjmp L255
 0BCA           L254:
 0BCA                   .dbline 1017
 0BCA           ;       
 0BCA           ;       // Wait to either hear a child or time out.
 0BCA           ;       while(!TIMEOUT)
 0BCA           ;       {               
 0BCA                   .dbline 1018
 0BCA           ;               if(commandReady())
 0BCA 7C02BE            xcall _commandReady
 0BCD 62D000            mov REG[0xd0],>__r0
 0BD0 3C0000            cmp [__r0],0
 0BD3 B006              jnz X49
 0BD5 3C0000            cmp [__r1],0
 0BD8 A00C              jz L257
 0BDA           X49:
 0BDA                   .dbline 1019
 0BDA           ;               {
 0BDA                   .dbline 1020
 0BDA           ;                       return 1;
 0BDA 62D000            mov REG[0xd0],>__r0
 0BDD 550001            mov [__r1],1
 0BE0 550000            mov [__r0],0
 0BE3 8030              xjmp L253
 0BE5           L257:
 0BE5                   .dbline 1022
 0BE5           ;               }
 0BE5           ;       }
 0BE5           L255:
 0BE5                   .dbline 1016
 0BE5 62D000            mov REG[0xd0],>_TIMEOUT
 0BE8 3C0000            cmp [_TIMEOUT],0
 0BEB B006              jnz X50
 0BED 3C0100            cmp [_TIMEOUT+1],0
 0BF0 AFD9              jz L254
 0BF2           X50:
 0BF2                   .dbline 1024
 0BF2           ;       
 0BF2           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0BF2 10                push X
 0BF3 7C0000            xcall _HELLO_TIMEOUT_Stop
 0BF6 20                pop X
 0BF7                   .dbline 1025
 0BF7           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0BF7 62D000            mov REG[0xd0],>_TIMEOUT
 0BFA 550100            mov [_TIMEOUT+1],0
 0BFD 550000            mov [_TIMEOUT],0
 0C00                   .dbline 1027
 0C00           ;       
 0C00           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0C00 5000              mov A,0
 0C02 08                push A
 0C03 5001              mov A,1
 0C05 08                push A
 0C06 7C00B4            xcall _configToggle
 0C09 38FE              add SP,-2
 0C0B                   .dbline 1029
 0C0B           ;       
 0C0B           ;       return 0;                                       // Return the result of our listening session.
 0C0B 62D000            mov REG[0xd0],>__r0
 0C0E 550000            mov [__r1],0
 0C11 550000            mov [__r0],0
 0C14                   .dbline -2
 0C14           L253:
 0C14                   .dbline 0 ; func end
 0C14 7F                ret
 0C15                   .dbend
 0C15                   .dbfunc e childResponse _childResponse fI
 0C15           ; child_responded -> X+0
 0C15           _childResponse::
 0C15                   .dbline -1
 0C15 10                push X
 0C16 4F                mov X,SP
 0C17 3802              add SP,2
 0C19                   .dbline 1034
 0C19           ; }
 0C19           ; 
 0C19           ; // This function waits for a child response.
 0C19           ; int childResponse(void)
 0C19           ; {
 0C19                   .dbline 1035
 0C19           ;       int child_responded = 0;
 0C19 560100            mov [X+1],0
 0C1C 560000            mov [X+0],0
 0C1F                   .dbline 1038
 0C1F           ;       
 0C1F           ;       // Switch to the right port.
 0C1F           ;       if(CHILD == PORT_1)
 0C1F 62D000            mov REG[0xd0],>_CHILD
 0C22 3C0031            cmp [_CHILD],49
 0C25 B00E              jnz L260
 0C27                   .dbline 1039
 0C27           ;       {
 0C27                   .dbline 1040
 0C27           ;               configToggle(RESPONSE_1);
 0C27 5000              mov A,0
 0C29 08                push A
 0C2A 5003              mov A,3
 0C2C 08                push A
 0C2D 7C00B4            xcall _configToggle
 0C30 38FE              add SP,-2
 0C32                   .dbline 1041
 0C32           ;       }
 0C32 8056              xjmp L269
 0C34           L260:
 0C34                   .dbline 1042
 0C34           ;       else if(CHILD == PORT_2)
 0C34 62D000            mov REG[0xd0],>_CHILD
 0C37 3C0032            cmp [_CHILD],50
 0C3A B00E              jnz L262
 0C3C                   .dbline 1043
 0C3C           ;       {
 0C3C                   .dbline 1044
 0C3C           ;               configToggle(RESPONSE_2);
 0C3C 5000              mov A,0
 0C3E 08                push A
 0C3F 5004              mov A,4
 0C41 08                push A
 0C42 7C00B4            xcall _configToggle
 0C45 38FE              add SP,-2
 0C47                   .dbline 1045
 0C47           ;       }
 0C47 8041              xjmp L269
 0C49           L262:
 0C49                   .dbline 1046
 0C49           ;       else if(CHILD == PORT_3)
 0C49 62D000            mov REG[0xd0],>_CHILD
 0C4C 3C0033            cmp [_CHILD],51
 0C4F B00E              jnz L264
 0C51                   .dbline 1047
 0C51           ;       {
 0C51                   .dbline 1048
 0C51           ;               configToggle(RESPONSE_3);
 0C51 5000              mov A,0
 0C53 08                push A
 0C54 5005              mov A,5
 0C56 08                push A
 0C57 7C00B4            xcall _configToggle
 0C5A 38FE              add SP,-2
 0C5C                   .dbline 1049
 0C5C           ;       }
 0C5C 802C              xjmp L269
 0C5E           L264:
 0C5E                   .dbline 1050
 0C5E           ;       else if(CHILD == PORT_4)
 0C5E 62D000            mov REG[0xd0],>_CHILD
 0C61 3C0034            cmp [_CHILD],52
 0C64 B024              jnz L269
 0C66                   .dbline 1051
 0C66           ;       {
 0C66                   .dbline 1052
 0C66           ;               configToggle(RESPONSE_4);
 0C66 5000              mov A,0
 0C68 08                push A
 0C69 5006              mov A,6
 0C6B 08                push A
 0C6C 7C00B4            xcall _configToggle
 0C6F 38FE              add SP,-2
 0C71                   .dbline 1053
 0C71           ;       }
 0C71 8017              xjmp L269
 0C73           L268:
 0C73                   .dbline 1057
 0C73           ;       
 0C73           ;       // Wait for a response or a timeout.
 0C73           ;       while((!child_responded) && (!TIMEOUT))
 0C73           ;       {
 0C73                   .dbline 1058
 0C73           ;               if(commandReady())
 0C73 7C02BE            xcall _commandReady
 0C76 62D000            mov REG[0xd0],>__r0
 0C79 3C0000            cmp [__r0],0
 0C7C B006              jnz X51
 0C7E 3C0000            cmp [__r1],0
 0C81 A007              jz L271
 0C83           X51:
 0C83                   .dbline 1059
 0C83           ;               {
 0C83                   .dbline 1060
 0C83           ;                       child_responded = 1;
 0C83 560101            mov [X+1],1
 0C86 560000            mov [X+0],0
 0C89                   .dbline 1061
 0C89           ;               }
 0C89           L271:
 0C89                   .dbline 1062
 0C89           ;       }
 0C89           L269:
 0C89                   .dbline 1056
 0C89 3D0000            cmp [X+0],0
 0C8C B013              jnz L273
 0C8E 3D0100            cmp [X+1],0
 0C91 B00E              jnz L273
 0C93           X52:
 0C93 62D000            mov REG[0xd0],>_TIMEOUT
 0C96 3C0000            cmp [_TIMEOUT],0
 0C99 B006              jnz X53
 0C9B 3C0100            cmp [_TIMEOUT+1],0
 0C9E AFD4              jz L268
 0CA0           X53:
 0CA0           L273:
 0CA0                   .dbline 1065
 0CA0           ;       
 0CA0           ;       // Stop the right timer.
 0CA0           ;       if(CHILD == PORT_1)
 0CA0 62D000            mov REG[0xd0],>_CHILD
 0CA3 3C0031            cmp [_CHILD],49
 0CA6 B008              jnz L274
 0CA8                   .dbline 1066
 0CA8           ;       {
 0CA8                   .dbline 1067
 0CA8           ;               CHILD_1_TIMEOUT_Stop();
 0CA8 10                push X
 0CA9 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0CAC 20                pop X
 0CAD                   .dbline 1068
 0CAD           ;       }
 0CAD 802C              xjmp L275
 0CAF           L274:
 0CAF                   .dbline 1069
 0CAF           ;       else if(CHILD == PORT_2)
 0CAF 62D000            mov REG[0xd0],>_CHILD
 0CB2 3C0032            cmp [_CHILD],50
 0CB5 B008              jnz L276
 0CB7                   .dbline 1070
 0CB7           ;       {
 0CB7                   .dbline 1071
 0CB7           ;               CHILD_2_TIMEOUT_Stop();
 0CB7 10                push X
 0CB8 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0CBB 20                pop X
 0CBC                   .dbline 1072
 0CBC           ;       }
 0CBC 801D              xjmp L277
 0CBE           L276:
 0CBE                   .dbline 1073
 0CBE           ;       else if(CHILD == PORT_3)
 0CBE 62D000            mov REG[0xd0],>_CHILD
 0CC1 3C0033            cmp [_CHILD],51
 0CC4 B008              jnz L278
 0CC6                   .dbline 1074
 0CC6           ;       {
 0CC6                   .dbline 1075
 0CC6           ;               CHILD_3_TIMEOUT_Stop();
 0CC6 10                push X
 0CC7 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0CCA 20                pop X
 0CCB                   .dbline 1076
 0CCB           ;       }
 0CCB 800E              xjmp L279
 0CCD           L278:
 0CCD                   .dbline 1077
 0CCD           ;       else if(CHILD == PORT_4)
 0CCD 62D000            mov REG[0xd0],>_CHILD
 0CD0 3C0034            cmp [_CHILD],52
 0CD3 B006              jnz L280
 0CD5                   .dbline 1078
 0CD5           ;       {
 0CD5                   .dbline 1079
 0CD5           ;               CHILD_4_TIMEOUT_Stop();
 0CD5 10                push X
 0CD6 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0CD9 20                pop X
 0CDA                   .dbline 1080
 0CDA           ;       }
 0CDA           L280:
 0CDA           L279:
 0CDA           L277:
 0CDA           L275:
 0CDA                   .dbline 1082
 0CDA           ;       
 0CDA           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0CDA 62D000            mov REG[0xd0],>_TIMEOUT
 0CDD 550100            mov [_TIMEOUT+1],0
 0CE0 550000            mov [_TIMEOUT],0
 0CE3                   .dbline 1084
 0CE3           ;       
 0CE3           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0CE3 5000              mov A,0
 0CE5 08                push A
 0CE6 5001              mov A,1
 0CE8 08                push A
 0CE9 7C00B4            xcall _configToggle
 0CEC 38FE              add SP,-2
 0CEE                   .dbline 1086
 0CEE           ;       
 0CEE           ;       return child_responded;
 0CEE 62D000            mov REG[0xd0],>__r0
 0CF1 5201              mov A,[X+1]
 0CF3 5300              mov [__r1],A
 0CF5 5200              mov A,[X+0]
 0CF7 5300              mov [__r0],A
 0CF9                   .dbline -2
 0CF9           L259:
 0CF9 38FE              add SP,-2
 0CFB 20                pop X
 0CFC                   .dbline 0 ; func end
 0CFC 7F                ret
 0CFD                   .dbsym l child_responded 0 I
 0CFD                   .dbend
 0CFD                   .dbfunc e servoFinder _servoFinder fV
 0CFD           ;     flashWrite -> X+7
 0CFD           ; status_return_level -> X+6
 0CFD           ; total_attempts -> X+4
 0CFD           ;              j -> X+2
 0CFD           ;              i -> X+0
 0CFD           _servoFinder::
 0CFD                   .dbline -1
 0CFD 10                push X
 0CFE 4F                mov X,SP
 0CFF 3809              add SP,9
 0D01                   .dbline 1093
 0D01           ; }
 0D01           ; 
 0D01           ; // This function is used to find the servo that is directly connected to this module's controller.
 0D01           ; // After the servo ID is found, the status return level is changed so that packets are only
 0D01           ; // returned for the desired status return level defined at the top of this file.
 0D01           ; void servoFinder(void)
 0D01           ; {                             
 0D01                   .dbline 1095
 0D01           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0D01           ;       int i = 0;
 0D01 560100            mov [X+1],0
 0D04 560000            mov [X+0],0
 0D07                   .dbline 1096
 0D07           ;       int j = 0;
 0D07 560300            mov [X+3],0
 0D0A 560200            mov [X+2],0
 0D0D                   .dbline 1098
 0D0D           ;       
 0D0D           ;       int total_attempts = 0;
 0D0D 560500            mov [X+5],0
 0D10 560400            mov [X+4],0
 0D13                   .dbline 1101
 0D13           ;       
 0D13           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0D13           ;       int flashWrite = 0;
 0D13 560800            mov [X+8],0
 0D16 560700            mov [X+7],0
 0D19                   .dbline 1104
 0D19           ;       
 0D19           ;       // Create a status return level variable and set it to an out of range value initially.
 0D19           ;       char status_return_level = 3;
 0D19 560603            mov [X+6],3
 0D1C                   .dbline 1107
 0D1C           ;       
 0D1C           ;       // Start with a servo ID of 255 (out of valid range).
 0D1C           ;       SERVO_ID = SERVO_START;
 0D1C 62D000            mov REG[0xd0],>_SERVO_ID
 0D1F 5500FF            mov [_SERVO_ID],-1
 0D22                   .dbline 1116
 0D22           ; 
 0D22           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0D22           ;       // number of times in each loop (unless stopped short due to early success).  If this fails for the
 0D22           ;       // first round of pings, a broadcast reset will be performed to reset the servo.  This is done
 0D22           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0D22           ;       // fast for the controller to switch into receive mode to read the response.  The default return
 0D22           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0D22           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0D22           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0D22 560300            mov [X+3],0
 0D25 560200            mov [X+2],0
 0D28           L283:
 0D28                   .dbline 1117
 0D28           ;       {       
 0D28                   .dbline 1119
 0D28           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0D28           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0D28 560100            mov [X+1],0
 0D2B 560000            mov [X+0],0
 0D2E           L287:
 0D2E                   .dbline 1120
 0D2E           ;               {
 0D2E                   .dbline 1122
 0D2E           ;                       // Send a ping out for any servo connected to me (will only be one).
 0D2E           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0D2E 5000              mov A,0
 0D30 08                push A
 0D31 08                push A
 0D32 5001              mov A,1
 0D34 08                push A
 0D35 5002              mov A,2
 0D37 08                push A
 0D38 50FE              mov A,-2
 0D3A 08                push A
 0D3B 918E              xcall _servoInstruction
 0D3D 38FB              add SP,-5
 0D3F                   .dbline 1124
 0D3F           ;                       
 0D3F           ;                       total_attempts++;
 0D3F 7705              inc [X+5]
 0D41 0F0400            adc [X+4],0
 0D44 804C              xjmp L292
 0D46           L291:
 0D46                   .dbline 1128
 0D46           ;                       
 0D46           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0D46           ;                       while(!TIMEOUT)
 0D46           ;                       {       
 0D46                   .dbline 1129
 0D46           ;                               if(commandReady())
 0D46 7C02BE            xcall _commandReady
 0D49 62D000            mov REG[0xd0],>__r0
 0D4C 3C0000            cmp [__r0],0
 0D4F B006              jnz X54
 0D51 3C0000            cmp [__r1],0
 0D54 A03C              jz L294
 0D56           X54:
 0D56                   .dbline 1130
 0D56           ;                               {
 0D56                   .dbline 1132
 0D56           ;                                       // If we read a source ID within the range, exit the loop.
 0D56           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0D56 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D59 3C0000            cmp [_COMMAND_SOURCE],0
 0D5C C02B              jc L296
 0D5E           X55:
 0D5E 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D61 50FD              mov A,-3
 0D63 3A00              cmp A,[_COMMAND_SOURCE]
 0D65 C022              jc L296
 0D67           X56:
 0D67                   .dbline 1133
 0D67           ;                                       {       
 0D67                   .dbline 1135
 0D67           ;                                               // Exit this while loop by setting the timeout flag.
 0D67           ;                                               TIMEOUT = 1;
 0D67 62D000            mov REG[0xd0],>_TIMEOUT
 0D6A 550101            mov [_TIMEOUT+1],1
 0D6D 550000            mov [_TIMEOUT],0
 0D70                   .dbline 1137
 0D70           ;                                               // Set the servo ID variable to where the ping came from.
 0D70           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D70 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D73 5100              mov A,[_COMMAND_SOURCE]
 0D75 62D000            mov REG[0xd0],>_SERVO_ID
 0D78 5300              mov [_SERVO_ID],A
 0D7A                   .dbline 1139
 0D7A           ;                                               // Set the index variable such that the for loop exits.
 0D7A           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D7A 56010A            mov [X+1],10
 0D7D 560000            mov [X+0],0
 0D80                   .dbline 1141
 0D80           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D80           ;                                               j = SERVO_COMM_LOOPS;
 0D80 560302            mov [X+3],2
 0D83 560200            mov [X+2],0
 0D86                   .dbline 1142
 0D86           ;                                       }
 0D86 800A              xjmp L297
 0D88           L296:
 0D88                   .dbline 1144
 0D88           ;                                       else
 0D88           ;                                       {
 0D88                   .dbline 1146
 0D88           ;                                               // Exit this while loop and try to ping again.
 0D88           ;                                               TIMEOUT = 1;
 0D88 62D000            mov REG[0xd0],>_TIMEOUT
 0D8B 550101            mov [_TIMEOUT+1],1
 0D8E 550000            mov [_TIMEOUT],0
 0D91                   .dbline 1147
 0D91           ;                                       }
 0D91           L297:
 0D91                   .dbline 1148
 0D91           ;                               }
 0D91           L294:
 0D91                   .dbline 1149
 0D91           ;                       }
 0D91           L292:
 0D91                   .dbline 1127
 0D91 62D000            mov REG[0xd0],>_TIMEOUT
 0D94 3C0000            cmp [_TIMEOUT],0
 0D97 B006              jnz X57
 0D99 3C0100            cmp [_TIMEOUT+1],0
 0D9C AFA9              jz L291
 0D9E           X57:
 0D9E                   .dbline 1150
 0D9E           ;               }
 0D9E           L288:
 0D9E                   .dbline 1119
 0D9E 7701              inc [X+1]
 0DA0 0F0000            adc [X+0],0
 0DA3                   .dbline 1119
 0DA3 5201              mov A,[X+1]
 0DA5 110A              sub A,10
 0DA7 5200              mov A,[X+0]
 0DA9 3180              xor A,-128
 0DAB 1980              sbb A,(0 ^ 0x80)
 0DAD CF80              jc L287
 0DAF           X58:
 0DAF                   .dbline 1154
 0DAF           ;               
 0DAF           ;               // If we didn't get a response and haven't written to the flash of the
 0DAF           ;               // servo (first time through), send out a broadcast reset.
 0DAF           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0DAF 62D000            mov REG[0xd0],>_SERVO_ID
 0DB2 3C00FF            cmp [_SERVO_ID],-1
 0DB5 B022              jnz L298
 0DB7 3D0700            cmp [X+7],0
 0DBA B01D              jnz L298
 0DBC 3D0800            cmp [X+8],0
 0DBF B018              jnz L298
 0DC1           X59:
 0DC1                   .dbline 1155
 0DC1           ;               {
 0DC1                   .dbline 1157
 0DC1           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0DC1           ;                       flashWrite = 1;
 0DC1 560801            mov [X+8],1
 0DC4 560700            mov [X+7],0
 0DC7                   .dbline 1161
 0DC7           ;                       
 0DC7           ;                       // Send out a broadcast reset so that we know that the response time interval
 0DC7           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0DC7           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0DC7 5000              mov A,0
 0DC9 08                push A
 0DCA 08                push A
 0DCB 5006              mov A,6
 0DCD 08                push A
 0DCE 5002              mov A,2
 0DD0 08                push A
 0DD1 50FE              mov A,-2
 0DD3 08                push A
 0DD4 90F5              xcall _servoInstruction
 0DD6 38FB              add SP,-5
 0DD8                   .dbline 1162
 0DD8           ;               }
 0DD8           L298:
 0DD8                   .dbline 1163
 0DD8           ;       }
 0DD8           L284:
 0DD8                   .dbline 1116
 0DD8 7703              inc [X+3]
 0DDA 0F0200            adc [X+2],0
 0DDD                   .dbline 1116
 0DDD 5203              mov A,[X+3]
 0DDF 1102              sub A,2
 0DE1 5202              mov A,[X+2]
 0DE3 3180              xor A,-128
 0DE5 1980              sbb A,(0 ^ 0x80)
 0DE7 CF40              jc L283
 0DE9           X60:
 0DE9                   .dbline 1166
 0DE9           ; 
 0DE9           ;       // Reset flash write flag.
 0DE9           ;       flashWrite = 0;
 0DE9 560800            mov [X+8],0
 0DEC 560700            mov [X+7],0
 0DEF                   .dbline 1170
 0DEF           ;       
 0DEF           ;       // If we have a valid servo ID, set the status return level.  If we don't, just skip this
 0DEF           ;       // because all hope is lost.
 0DEF           ;       if(SERVO_ID < BROADCAST)
 0DEF 62D000            mov REG[0xd0],>_SERVO_ID
 0DF2 3C00FE            cmp [_SERVO_ID],-2
 0DF5 D0CD              jnc L327
 0DF7           X61:
 0DF7                   .dbline 1171
 0DF7           ;       {
 0DF7                   .dbline 1176
 0DF7           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0DF7           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0DF7           ;               // to early success).  If this fails for the first iteration, or we read a status return level
 0DF7           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0DF7           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DF7 560300            mov [X+3],0
 0DFA 560200            mov [X+2],0
 0DFD           L302:
 0DFD                   .dbline 1177
 0DFD           ;               {
 0DFD                   .dbline 1179
 0DFD           ;                       // Attempt to read the status return level for the defined number of attempts.
 0DFD           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DFD 560100            mov [X+1],0
 0E00 560000            mov [X+0],0
 0E03           L306:
 0E03                   .dbline 1180
 0E03           ;                       {
 0E03                   .dbline 1182
 0E03           ;                               // Send a request for the servo's status return level.
 0E03           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0E03 5001              mov A,1
 0E05 08                push A
 0E06 5010              mov A,16
 0E08 08                push A
 0E09 5002              mov A,2
 0E0B 08                push A
 0E0C 5004              mov A,4
 0E0E 08                push A
 0E0F 62D000            mov REG[0xd0],>_SERVO_ID
 0E12 5100              mov A,[_SERVO_ID]
 0E14 08                push A
 0E15 90B4              xcall _servoInstruction
 0E17 38FB              add SP,-5
 0E19 8048              xjmp L311
 0E1B           L310:
 0E1B                   .dbline 1186
 0E1B           ;                               
 0E1B           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0E1B           ;                               while(!TIMEOUT)
 0E1B           ;                               {
 0E1B                   .dbline 1188
 0E1B           ;                                       // If a valid command is ready, interpret it.
 0E1B           ;                                       if(commandReady())
 0E1B 7C02BE            xcall _commandReady
 0E1E 62D000            mov REG[0xd0],>__r0
 0E21 3C0000            cmp [__r0],0
 0E24 B006              jnz X62
 0E26 3C0000            cmp [__r1],0
 0E29 A038              jz L313
 0E2B           X62:
 0E2B                   .dbline 1189
 0E2B           ;                                       {
 0E2B                   .dbline 1190
 0E2B           ;                                               if(!COMMAND_ERROR)
 0E2B 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0E2E 3C0000            cmp [_COMMAND_ERROR],0
 0E31 B030              jnz L315
 0E33                   .dbline 1191
 0E33           ;                                               {
 0E33                   .dbline 1193
 0E33           ;                                                       // If the return level is equal to what is desired, store it.
 0E33           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0E33 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E36 3C0001            cmp [_COMMAND_PARAM],1
 0E39 B01F              jnz L317
 0E3B                   .dbline 1194
 0E3B           ;                                                       {
 0E3B                   .dbline 1196
 0E3B           ;                                                               // Set the timeout flag to exit the loop.
 0E3B           ;                                                               TIMEOUT = 1;
 0E3B 62D000            mov REG[0xd0],>_TIMEOUT
 0E3E 550101            mov [_TIMEOUT+1],1
 0E41 550000            mov [_TIMEOUT],0
 0E44                   .dbline 1198
 0E44           ;                                                               // Store the status return level.
 0E44           ;                                                               status_return_level = COMMAND_PARAM;
 0E44 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E47 5100              mov A,[_COMMAND_PARAM]
 0E49 5406              mov [X+6],A
 0E4B                   .dbline 1200
 0E4B           ;                                                               // Set i so that we exit the for loop.
 0E4B           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0E4B 56010A            mov [X+1],10
 0E4E 560000            mov [X+0],0
 0E51                   .dbline 1202
 0E51           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0E51           ;                                                               j = SERVO_COMM_LOOPS;
 0E51 560302            mov [X+3],2
 0E54 560200            mov [X+2],0
 0E57                   .dbline 1203
 0E57           ;                                                       }
 0E57 800A              xjmp L318
 0E59           L317:
 0E59                   .dbline 1205
 0E59           ;                                                       else
 0E59           ;                                                       {       
 0E59                   .dbline 1207
 0E59           ;                                                               // Set the timeout flag to exit the loop.
 0E59           ;                                                               TIMEOUT = 1;
 0E59 62D000            mov REG[0xd0],>_TIMEOUT
 0E5C 550101            mov [_TIMEOUT+1],1
 0E5F 550000            mov [_TIMEOUT],0
 0E62                   .dbline 1208
 0E62           ;                                                       }
 0E62           L318:
 0E62                   .dbline 1209
 0E62           ;                                               }
 0E62           L315:
 0E62                   .dbline 1210
 0E62           ;                                       }
 0E62           L313:
 0E62                   .dbline 1211
 0E62           ;                               }
 0E62           L311:
 0E62                   .dbline 1185
 0E62 62D000            mov REG[0xd0],>_TIMEOUT
 0E65 3C0000            cmp [_TIMEOUT],0
 0E68 B006              jnz X63
 0E6A 3C0100            cmp [_TIMEOUT+1],0
 0E6D AFAD              jz L310
 0E6F           X63:
 0E6F                   .dbline 1212
 0E6F           ;                       }
 0E6F           L307:
 0E6F                   .dbline 1179
 0E6F 7701              inc [X+1]
 0E71 0F0000            adc [X+0],0
 0E74                   .dbline 1179
 0E74 5201              mov A,[X+1]
 0E76 110A              sub A,10
 0E78 5200              mov A,[X+0]
 0E7A 3180              xor A,-128
 0E7C 1980              sbb A,(0 ^ 0x80)
 0E7E CF84              jc L306
 0E80           X64:
 0E80                   .dbline 1216
 0E80           ;               
 0E80           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E80           ;                       // force a change in the status return level with an EEPROM write.
 0E80           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E80 3D0601            cmp [X+6],1
 0E83 A027              jz L319
 0E85 3D0700            cmp [X+7],0
 0E88 B022              jnz L319
 0E8A 3D0800            cmp [X+8],0
 0E8D B01D              jnz L319
 0E8F           X65:
 0E8F                   .dbline 1217
 0E8F           ;                       {       
 0E8F                   .dbline 1218
 0E8F           ;                               flashWrite = 1;
 0E8F 560801            mov [X+8],1
 0E92 560700            mov [X+7],0
 0E95                   .dbline 1221
 0E95           ;                               
 0E95           ;                               // Try to force the return status to what we want.
 0E95           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E95 5001              mov A,1
 0E97 08                push A
 0E98 5010              mov A,16
 0E9A 08                push A
 0E9B 5003              mov A,3
 0E9D 08                push A
 0E9E 5004              mov A,4
 0EA0 08                push A
 0EA1 62D000            mov REG[0xd0],>_SERVO_ID
 0EA4 5100              mov A,[_SERVO_ID]
 0EA6 08                push A
 0EA7 9022              xcall _servoInstruction
 0EA9 38FB              add SP,-5
 0EAB                   .dbline 1222
 0EAB           ;                       }
 0EAB           L319:
 0EAB                   .dbline 1223
 0EAB           ;               }
 0EAB           L303:
 0EAB                   .dbline 1176
 0EAB 7703              inc [X+3]
 0EAD 0F0200            adc [X+2],0
 0EB0                   .dbline 1176
 0EB0 5203              mov A,[X+3]
 0EB2 1102              sub A,2
 0EB4 5202              mov A,[X+2]
 0EB6 3180              xor A,-128
 0EB8 1980              sbb A,(0 ^ 0x80)
 0EBA CF42              jc L302
 0EBC           X66:
 0EBC                   .dbline 1225
 0EBC           ;               
 0EBC           ;               if(status_return_level != STATUS_RET_LEVEL)
 0EBC 3D0601            cmp [X+6],1
 0EBF A005              jz L301
 0EC1                   .dbline 1226
 0EC1           ;               {
 0EC1           L323:
 0EC1                   .dbline 1228
 0EC1           ;                       // Break on purpose to show that the status return is not correct.
 0EC1           ;                       while(1) { }
 0EC1                   .dbline 1228
 0EC1           L324:
 0EC1                   .dbline 1228
 0EC1 8FFF              xjmp L323
 0EC3           L326:
 0EC3                   .dbline 1234
 0EC3           ;               }
 0EC3           ;       }
 0EC3           ;       else
 0EC3           ;       {
 0EC3           ;               // Purposely break the module to show that we did not resolve the communication with our servo.
 0EC3           ;               while(1) { }
 0EC3                   .dbline 1234
 0EC3           L327:
 0EC3                   .dbline 1234
 0EC3 8FFF              xjmp L326
 0EC5           L301:
 0EC5                   .dbline 1238
 0EC5           ;       }
 0EC5           ;       
 0EC5           ;       // Wait for the other controllers to find their servos.
 0EC5           ;       servoConfigWait();
 0EC5 9155              xcall _servoConfigWait
 0EC7                   .dbline -2
 0EC7           L282:
 0EC7 38F7              add SP,-9
 0EC9 20                pop X
 0ECA                   .dbline 0 ; func end
 0ECA 7F                ret
 0ECB                   .dbsym l flashWrite 7 I
 0ECB                   .dbsym l status_return_level 6 c
 0ECB                   .dbsym l total_attempts 4 I
 0ECB                   .dbsym l j 2 I
 0ECB                   .dbsym l i 0 I
 0ECB                   .dbend
 0ECB                   .dbfunc e servoInstruction _servoInstruction fV
 0ECB           ;       checksum -> X+0
 0ECB           ;          value -> X-8
 0ECB           ;        address -> X-7
 0ECB           ;    instruction -> X-6
 0ECB           ;         length -> X-5
 0ECB           ;             id -> X-4
 0ECB           _servoInstruction::
 0ECB                   .dbline -1
 0ECB 10                push X
 0ECC 4F                mov X,SP
 0ECD 3801              add SP,1
 0ECF                   .dbline 1244
 0ECF           ; }
 0ECF           ; 
 0ECF           ; // This function receives a destination, command length, instruction type, address, and value.
 0ECF           ; // With these parameters, the function sends a packet to the communication bus.
 0ECF           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0ECF           ; {
 0ECF                   .dbline 1248
 0ECF           ;       char checksum;
 0ECF           ;       
 0ECF           ;       // Toggle into transmit mode.
 0ECF           ;       configToggle(SERVO_COMM);
 0ECF 5000              mov A,0
 0ED1 08                push A
 0ED2 5009              mov A,9
 0ED4 08                push A
 0ED5 7C00B4            xcall _configToggle
 0ED8 38FE              add SP,-2
 0EDA                   .dbline 1251
 0EDA           ;       
 0EDA           ;       // Calculate the checksum value for our servo communication.
 0EDA           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0EDA 62D000            mov REG[0xd0],>__r0
 0EDD 52FB              mov A,[X-5]
 0EDF 5300              mov [__r1],A
 0EE1 550000            mov [__r0],0
 0EE4 52FC              mov A,[X-4]
 0EE6 0200              add A,[__r1]
 0EE8 5300              mov [__r1],A
 0EEA 5000              mov A,0
 0EEC 0A00              adc A,[__r0]
 0EEE 5300              mov [__r0],A
 0EF0 52FA              mov A,[X-6]
 0EF2 0400              add [__r1],A
 0EF4 0E0000            adc [__r0],0
 0EF7 52F9              mov A,[X-7]
 0EF9 0400              add [__r1],A
 0EFB 0E0000            adc [__r0],0
 0EFE 52F8              mov A,[X-8]
 0F00 0400              add [__r1],A
 0F02 0E0000            adc [__r0],0
 0F05 5001              mov A,1
 0F07 08                push A
 0F08 5000              mov A,0
 0F0A 08                push A
 0F0B 5100              mov A,[__r0]
 0F0D 08                push A
 0F0E 5100              mov A,[__r1]
 0F10 08                push A
 0F11 7C0000            xcall __divmod_16X16_16
 0F14 38FE              add SP,-2
 0F16 18                pop A
 0F17 5300              mov [__r1],A
 0F19 18                pop A
 0F1A 50FF              mov A,-1
 0F1C 1200              sub A,[__r1]
 0F1E 5400              mov [X+0],A
 0F20                   .dbline 1254
 0F20           ;       
 0F20           ;       // Talk to the servo.
 0F20           ;       if(instruction == PING_SERVO)
 0F20 3DFA01            cmp [X-6],1
 0F23 B02D              jnz L330
 0F25                   .dbline 1255
 0F25           ;       {
 0F25                   .dbline 1256
 0F25           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F25 10                push X
 0F26 50FF              mov A,-1
 0F28 7C0000            xcall _SERVO_TX_PutChar
 0F2B 20                pop X
 0F2C                   .dbline 1257
 0F2C           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F2C 10                push X
 0F2D 50FF              mov A,-1
 0F2F 7C0000            xcall _SERVO_TX_PutChar
 0F32 20                pop X
 0F33                   .dbline 1258
 0F33           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F33 10                push X
 0F34 52FC              mov A,[X-4]
 0F36 7C0000            xcall _SERVO_TX_PutChar
 0F39 20                pop X
 0F3A                   .dbline 1259
 0F3A           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F3A 10                push X
 0F3B 52FB              mov A,[X-5]
 0F3D 7C0000            xcall _SERVO_TX_PutChar
 0F40 20                pop X
 0F41                   .dbline 1260
 0F41           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F41 10                push X
 0F42 52FA              mov A,[X-6]
 0F44 7C0000            xcall _SERVO_TX_PutChar
 0F47 20                pop X
 0F48                   .dbline 1261
 0F48           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F48 10                push X
 0F49 5200              mov A,[X+0]
 0F4B 7C0000            xcall _SERVO_TX_PutChar
 0F4E 20                pop X
 0F4F                   .dbline 1262
 0F4F           ;       }
 0F4F 8039              xjmp L333
 0F51           L330:
 0F51                   .dbline 1264
 0F51           ;       else
 0F51           ;       {
 0F51                   .dbline 1265
 0F51           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F51 10                push X
 0F52 50FF              mov A,-1
 0F54 7C0000            xcall _SERVO_TX_PutChar
 0F57 20                pop X
 0F58                   .dbline 1266
 0F58           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F58 10                push X
 0F59 50FF              mov A,-1
 0F5B 7C0000            xcall _SERVO_TX_PutChar
 0F5E 20                pop X
 0F5F                   .dbline 1267
 0F5F           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F5F 10                push X
 0F60 52FC              mov A,[X-4]
 0F62 7C0000            xcall _SERVO_TX_PutChar
 0F65 20                pop X
 0F66                   .dbline 1268
 0F66           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F66 10                push X
 0F67 52FB              mov A,[X-5]
 0F69 7C0000            xcall _SERVO_TX_PutChar
 0F6C 20                pop X
 0F6D                   .dbline 1269
 0F6D           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F6D 10                push X
 0F6E 52FA              mov A,[X-6]
 0F70 7C0000            xcall _SERVO_TX_PutChar
 0F73 20                pop X
 0F74                   .dbline 1270
 0F74           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F74 10                push X
 0F75 52F9              mov A,[X-7]
 0F77 7C0000            xcall _SERVO_TX_PutChar
 0F7A 20                pop X
 0F7B                   .dbline 1271
 0F7B           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F7B 10                push X
 0F7C 52F8              mov A,[X-8]
 0F7E 7C0000            xcall _SERVO_TX_PutChar
 0F81 20                pop X
 0F82                   .dbline 1272
 0F82           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F82 10                push X
 0F83 5200              mov A,[X+0]
 0F85 7C0000            xcall _SERVO_TX_PutChar
 0F88 20                pop X
 0F89                   .dbline 1273
 0F89           ;       }
 0F89           L332:
 0F89                   .dbline 1276
 0F89           ;       
 0F89           ;       // Wait for the transmission to finish.
 0F89           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F89           L333:
 0F89                   .dbline 1276
 0F89 10                push X
 0F8A 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F8D 62D000            mov REG[0xd0],>__r0
 0F90 20                pop X
 0F91 5300              mov [__r0],A
 0F93 470020            tst [__r0],32
 0F96 AFF2              jz L332
 0F98                   .dbline 1279
 0F98           ;       
 0F98           ;       // Make completely sure we're done.
 0F98           ;       xmitWait();
 0F98 900F              xcall _xmitWait
 0F9A                   .dbline 1282
 0F9A           ;       
 0F9A           ;       // Switch back to wait for a servo response.
 0F9A           ;       configToggle(INITIALIZE);
 0F9A 5000              mov A,0
 0F9C 08                push A
 0F9D 5008              mov A,8
 0F9F 08                push A
 0FA0 7C00B4            xcall _configToggle
 0FA3 38FE              add SP,-2
 0FA5                   .dbline -2
 0FA5           L329:
 0FA5 38FF              add SP,-1
 0FA7 20                pop X
 0FA8                   .dbline 0 ; func end
 0FA8 7F                ret
 0FA9                   .dbsym l checksum 0 c
 0FA9                   .dbsym l value -8 c
 0FA9                   .dbsym l address -7 c
 0FA9                   .dbsym l instruction -6 c
 0FA9                   .dbsym l length -5 c
 0FA9                   .dbsym l id -4 c
 0FA9                   .dbend
 0FA9                   .dbfunc e xmitWait _xmitWait fV
 0FA9           ;              i -> X+0
 0FA9           _xmitWait::
 0FA9                   .dbline -1
 0FA9 10                push X
 0FAA 4F                mov X,SP
 0FAB 3802              add SP,2
 0FAD                   .dbline 1286
 0FAD           ; }
 0FAD           ; 
 0FAD           ; void xmitWait(void)
 0FAD           ; {
 0FAD                   .dbline 1289
 0FAD           ;       int i;
 0FAD           ;       
 0FAD           ;       for(i = 0; i < 25; i++)
 0FAD 560100            mov [X+1],0
 0FB0 560000            mov [X+0],0
 0FB3           L336:
 0FB3                   .dbline 1290
 0FB3           ;       {
 0FB3                   .dbline 1292
 0FB3           ;               // Does nothing and wastes approximately 50 microseconds.
 0FB3           ;       }
 0FB3           L337:
 0FB3                   .dbline 1289
 0FB3 7701              inc [X+1]
 0FB5 0F0000            adc [X+0],0
 0FB8                   .dbline 1289
 0FB8 5201              mov A,[X+1]
 0FBA 1119              sub A,25
 0FBC 5200              mov A,[X+0]
 0FBE 3180              xor A,-128
 0FC0 1980              sbb A,(0 ^ 0x80)
 0FC2 CFF0              jc L336
 0FC4           X67:
 0FC4                   .dbline -2
 0FC4           L335:
 0FC4 38FE              add SP,-2
 0FC6 20                pop X
 0FC7                   .dbline 0 ; func end
 0FC7 7F                ret
 0FC8                   .dbsym l i 0 I
 0FC8                   .dbend
 0FC8                   .dbfunc e servoBootWait _servoBootWait fV
 0FC8           ;              i -> X+0
 0FC8           _servoBootWait::
 0FC8                   .dbline -1
 0FC8 10                push X
 0FC9 4F                mov X,SP
 0FCA 3802              add SP,2
 0FCC                   .dbline 1299
 0FCC           ; }
 0FCC           ; 
 0FCC           ; // This function wastes time while the servo that is attached to this controller boots up.
 0FCC           ; // Once that happens, communications should happen quickly and reliably.  The estimated boot
 0FCC           ; // time in testing was approximately 120 ms.
 0FCC           ; void servoBootWait(void)
 0FCC           ; {
 0FCC                   .dbline 1300
 0FCC           ;       int i = 0;                                      // Index integer used for looping.
 0FCC 560100            mov [X+1],0
 0FCF 560000            mov [X+0],0
 0FD2                   .dbline 1302
 0FD2           ; 
 0FD2           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FD2 5000              mov A,0
 0FD4 08                push A
 0FD5 5008              mov A,8
 0FD7 08                push A
 0FD8 7C00B4            xcall _configToggle
 0FDB 38FE              add SP,-2
 0FDD                   .dbline 1305
 0FDD           ;       
 0FDD           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0FDD           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0FDD 560100            mov [X+1],0
 0FE0 560000            mov [X+0],0
 0FE3                   .dbline 1306
 0FE3           ;       {
 0FE3           L345:
 0FE3                   .dbline 1307
 0FE3           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FE3                   .dbline 1307
 0FE3           L346:
 0FE3                   .dbline 1307
 0FE3 62D000            mov REG[0xd0],>_TIMEOUT
 0FE6 3C0000            cmp [_TIMEOUT],0
 0FE9 B006              jnz X68
 0FEB 3C0100            cmp [_TIMEOUT+1],0
 0FEE AFF4              jz L345
 0FF0           X68:
 0FF0                   .dbline 1308
 0FF0           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FF0 62D000            mov REG[0xd0],>_TIMEOUT
 0FF3 550100            mov [_TIMEOUT+1],0
 0FF6 550000            mov [_TIMEOUT],0
 0FF9                   .dbline 1309
 0FF9           ;       }
 0FF9           L342:
 0FF9                   .dbline 1305
 0FF9 7701              inc [X+1]
 0FFB 0F0000            adc [X+0],0
 0FFE                   .dbline 1305
 0FFE 5201              mov A,[X+1]
 1000 114B              sub A,75
 1002 5200              mov A,[X+0]
 1004 3180              xor A,-128
 1006 1980              sbb A,(0 ^ 0x80)
 1008 CFDA              jc L346
 100A           X69:
 100A                   .dbline 1311
 100A           ;       
 100A           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 100A 10                push X
 100B 7C0000            xcall _INIT_TIMEOUT_Stop
 100E 20                pop X
 100F                   .dbline 1312
 100F           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 100F 62D000            mov REG[0xd0],>_TIMEOUT
 1012 550100            mov [_TIMEOUT+1],0
 1015 550000            mov [_TIMEOUT],0
 1018                   .dbline -2
 1018           L340:
 1018 38FE              add SP,-2
 101A 20                pop X
 101B                   .dbline 0 ; func end
 101B 7F                ret
 101C                   .dbsym l i 0 I
 101C                   .dbend
 101C                   .dbfunc e servoConfigWait _servoConfigWait fV
 101C           ;              i -> X+0
 101C           _servoConfigWait::
 101C                   .dbline -1
 101C 10                push X
 101D 4F                mov X,SP
 101E 3802              add SP,2
 1020                   .dbline 1318
 1020           ; }
 1020           ; 
 1020           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 1020           ; // to take place.  This allows all other modules to initialize.
 1020           ; void servoConfigWait(void)
 1020           ; {
 1020                   .dbline 1319
 1020           ;       int i = 0;                                      // Index integer for looping purposes.
 1020 560100            mov [X+1],0
 1023 560000            mov [X+0],0
 1026                   .dbline 1321
 1026           ;       
 1026           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1026 5000              mov A,0
 1028 08                push A
 1029 5008              mov A,8
 102B 08                push A
 102C 7C00B4            xcall _configToggle
 102F 38FE              add SP,-2
 1031                   .dbline 1326
 1031           ;       
 1031           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 1031           ;       // their servos.  The reason we loop this many times is to allow for a possible worst
 1031           ;       // case scenario of setup time to complete.
 1031           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 1031 560100            mov [X+1],0
 1034 560000            mov [X+0],0
 1037                   .dbline 1327
 1037           ;       {
 1037           L353:
 1037                   .dbline 1328
 1037           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1037                   .dbline 1328
 1037           L354:
 1037                   .dbline 1328
 1037 62D000            mov REG[0xd0],>_TIMEOUT
 103A 3C0000            cmp [_TIMEOUT],0
 103D B006              jnz X70
 103F 3C0100            cmp [_TIMEOUT+1],0
 1042 AFF4              jz L353
 1044           X70:
 1044                   .dbline 1329
 1044           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 1044 62D000            mov REG[0xd0],>_TIMEOUT
 1047 550100            mov [_TIMEOUT+1],0
 104A 550000            mov [_TIMEOUT],0
 104D                   .dbline 1330
 104D           ;       }
 104D           L350:
 104D                   .dbline 1326
 104D 7701              inc [X+1]
 104F 0F0000            adc [X+0],0
 1052                   .dbline 1326
 1052 5201              mov A,[X+1]
 1054 1114              sub A,20
 1056 5200              mov A,[X+0]
 1058 3180              xor A,-128
 105A 1980              sbb A,(0 ^ 0x80)
 105C CFDA              jc L354
 105E           X71:
 105E                   .dbline 1332
 105E           ;       
 105E           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 105E 10                push X
 105F 7C0000            xcall _INIT_TIMEOUT_Stop
 1062 20                pop X
 1063                   .dbline 1333
 1063           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 1063 62D000            mov REG[0xd0],>_TIMEOUT
 1066 550100            mov [_TIMEOUT+1],0
 1069 550000            mov [_TIMEOUT],0
 106C                   .dbline 1335
 106C           ; 
 106C           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 106C 5000              mov A,0
 106E 08                push A
 106F 5001              mov A,1
 1071 08                push A
 1072 7C00B4            xcall _configToggle
 1075 38FE              add SP,-2
 1077                   .dbline -2
 1077           L348:
 1077 38FE              add SP,-2
 1079 20                pop X
 107A                   .dbline 0 ; func end
 107A 7F                ret
 107B                   .dbsym l i 0 I
 107B                   .dbend
 107B                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 107B           _TX_01234_TIMEOUT_ISR::
 107B                   .dbline -1
 107B 71C0              or F,-64
 107D 08                push A
 107E 5DD0              mov A,REG[0xd0]
 1080 08                push A
 1081                   .dbline 1343
 1081           ; }
 1081           ; 
 1081           ; // This timeout ISR is for waiting before a transmission is made from this module.
 1081           ; // This is to give all the other modules a chance to set up and clear their buffers.
 1081           ; // It is currently set so that there is 1 ms of down time between the last transmission
 1081           ; // and this module's transmission.
 1081           ; void TX_01234_TIMEOUT_ISR(void)
 1081           ; {
 1081                   .dbline 1344
 1081           ;       TIMEOUT = 1;    // Set the timeout flag.
 1081 62D000            mov REG[0xd0],>_TIMEOUT
 1084 550101            mov [_TIMEOUT+1],1
 1087 550000            mov [_TIMEOUT],0
 108A                   .dbline 1345
 108A           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 108A 62DAFD            mov REG[0xda],-3
 108D                   .dbline -2
 108D           L356:
 108D 18                pop A
 108E 60D0              mov REG[208],A
 1090 18                pop A
 1091                   .dbline 0 ; func end
 1091 7E                reti
 1092                   .dbend
 1092                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 1092           _HELLO_TIMEOUT_ISR::
 1092                   .dbline -1
 1092 71C0              or F,-64
 1094 08                push A
 1095 5DD0              mov A,REG[0xd0]
 1097 08                push A
 1098                   .dbline 1350
 1098           ; }
 1098           ; 
 1098           ; // This is the ISR for a hello response timeout.
 1098           ; void HELLO_TIMEOUT_ISR(void)
 1098           ; {
 1098                   .dbline 1351
 1098           ;       TIMEOUT = 1;    // Set the timeout flag.
 1098 62D000            mov REG[0xd0],>_TIMEOUT
 109B 550101            mov [_TIMEOUT+1],1
 109E 550000            mov [_TIMEOUT],0
 10A1                   .dbline 1352
 10A1           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 10A1 62DAFD            mov REG[0xda],-3
 10A4                   .dbline -2
 10A4           L357:
 10A4 18                pop A
 10A5 60D0              mov REG[208],A
 10A7 18                pop A
 10A8                   .dbline 0 ; func end
 10A8 7E                reti
 10A9                   .dbend
 10A9                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 10A9           _CHILD_1_TIMEOUT_ISR::
 10A9                   .dbline -1
 10A9 71C0              or F,-64
 10AB 08                push A
 10AC 5DD0              mov A,REG[0xd0]
 10AE 08                push A
 10AF                   .dbline 1357
 10AF           ; }
 10AF           ; 
 10AF           ; // These remaining ISRs are for all the child timeout scenarios.
 10AF           ; void CHILD_1_TIMEOUT_ISR(void)
 10AF           ; {
 10AF                   .dbline 1358
 10AF           ;       TIMEOUT = 1;    // Set the timeout flag.
 10AF 62D000            mov REG[0xd0],>_TIMEOUT
 10B2 550101            mov [_TIMEOUT+1],1
 10B5 550000            mov [_TIMEOUT],0
 10B8                   .dbline 1359
 10B8           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 10B8 62DAFD            mov REG[0xda],-3
 10BB                   .dbline -2
 10BB           L358:
 10BB 18                pop A
 10BC 60D0              mov REG[208],A
 10BE 18                pop A
 10BF                   .dbline 0 ; func end
 10BF 7E                reti
 10C0                   .dbend
 10C0                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 10C0           _CHILD_2_TIMEOUT_ISR::
 10C0                   .dbline -1
 10C0 71C0              or F,-64
 10C2 08                push A
 10C3 5DD0              mov A,REG[0xd0]
 10C5 08                push A
 10C6                   .dbline 1363
 10C6           ; }
 10C6           ; 
 10C6           ; void CHILD_2_TIMEOUT_ISR(void)
 10C6           ; {
 10C6                   .dbline 1364
 10C6           ;       TIMEOUT = 1;    // Set the timeout flag.
 10C6 62D000            mov REG[0xd0],>_TIMEOUT
 10C9 550101            mov [_TIMEOUT+1],1
 10CC 550000            mov [_TIMEOUT],0
 10CF                   .dbline 1365
 10CF           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 10CF 62DAFD            mov REG[0xda],-3
 10D2                   .dbline -2
 10D2           L359:
 10D2 18                pop A
 10D3 60D0              mov REG[208],A
 10D5 18                pop A
 10D6                   .dbline 0 ; func end
 10D6 7E                reti
 10D7                   .dbend
 10D7                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 10D7           _CHILD_3_TIMEOUT_ISR::
 10D7                   .dbline -1
 10D7 71C0              or F,-64
 10D9 08                push A
 10DA 5DD0              mov A,REG[0xd0]
 10DC 08                push A
 10DD                   .dbline 1369
 10DD           ; }
 10DD           ; 
 10DD           ; void CHILD_3_TIMEOUT_ISR(void)
 10DD           ; {
 10DD                   .dbline 1370
 10DD           ;       TIMEOUT = 1;    // Set the timeout flag.
 10DD 62D000            mov REG[0xd0],>_TIMEOUT
 10E0 550101            mov [_TIMEOUT+1],1
 10E3 550000            mov [_TIMEOUT],0
 10E6                   .dbline 1371
 10E6           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 10E6 62DAFD            mov REG[0xda],-3
 10E9                   .dbline -2
 10E9           L360:
 10E9 18                pop A
 10EA 60D0              mov REG[208],A
 10EC 18                pop A
 10ED                   .dbline 0 ; func end
 10ED 7E                reti
 10EE                   .dbend
 10EE                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 10EE           _CHILD_4_TIMEOUT_ISR::
 10EE                   .dbline -1
 10EE 71C0              or F,-64
 10F0 08                push A
 10F1 5DD0              mov A,REG[0xd0]
 10F3 08                push A
 10F4                   .dbline 1375
 10F4           ; }
 10F4           ; 
 10F4           ; void CHILD_4_TIMEOUT_ISR(void)
 10F4           ; {
 10F4                   .dbline 1376
 10F4           ;       TIMEOUT = 1;    // Set the timeout flag.
 10F4 62D000            mov REG[0xd0],>_TIMEOUT
 10F7 550101            mov [_TIMEOUT+1],1
 10FA 550000            mov [_TIMEOUT],0
 10FD                   .dbline 1377
 10FD           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 10FD 62DAFD            mov REG[0xda],-3
 1100                   .dbline -2
 1100           L361:
 1100 18                pop A
 1101 60D0              mov REG[208],A
 1103 18                pop A
 1104                   .dbline 0 ; func end
 1104 7E                reti
 1105                   .dbend
 1105                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 1105           _INIT_TIMEOUT_ISR::
 1105                   .dbline -1
 1105 71C0              or F,-64
 1107 08                push A
 1108 5DD0              mov A,REG[0xd0]
 110A 08                push A
 110B                   .dbline 1381
 110B           ; }
 110B           ; 
 110B           ; void INIT_TIMEOUT_ISR(void)
 110B           ; {
 110B                   .dbline 1382
 110B           ;       TIMEOUT = 1;    // Set the timeout flag.
 110B 62D000            mov REG[0xd0],>_TIMEOUT
 110E 550101            mov [_TIMEOUT+1],1
 1111 550000            mov [_TIMEOUT],0
 1114                   .dbline 1383
 1114           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 1114 62DAFD            mov REG[0xda],-3
 1117                   .dbline -2
 1117           L362:
 1117 18                pop A
 1118 60D0              mov REG[208],A
 111A 18                pop A
 111B                   .dbline 0 ; func end
 111B 7E                reti
 111C                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c

 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 155
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 1-25-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Packet Structure
 0000           ; // ----------------
 0000           ; // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler WAIT_RECV_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.  Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_A                                          ('A')
 0000           ; #define               PORT_B                                          ('B')
 0000           ; #define               PORT_C                                          ('C')
 0000           ; #define               PORT_D                                          ('D')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type.  These are the only
 0000           ; // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
 0000           ; // This will be the amount of iterations we do after the last byte has been received as well.
 0000           ; #define               RESPONSE_ITERATIONS                     (10)
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations.  This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function sends out an acknowledgement of a configuration reset.
 0000           ; void configCleared(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 157
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 158
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 159
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 160
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 161
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 162
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 164
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 166
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 169
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C104B            xcall _servoBootWait
 0035                   .dbline 172
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0D80            xcall _servoFinder
 0038 8012              xjmp L3
 003A           L2:
 003A                   .dbline 176
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 177
 003A           ;               if(commandReady())
 003A 928E              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A003              jz L5
 0049           X1:
 0049                   .dbline 178
 0049           ;               {
 0049                   .dbline 180
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 9709              xcall _takeAction
 004B                   .dbline 181
 004B           ;               }
 004B           L5:
 004B                   .dbline 182
 004B           ;       }
 004B           L3:
 004B                   .dbline 175
 004B 8FEE              xjmp L2
 004D           X0:
 004D                   .dbline -2
 004D           L1:
 004D                   .dbline 0 ; func end
 004D 8FFF              jmp .
 004F                   .dbend
 004F                   .dbfunc e sayHello _sayHello fV
 004F           _sayHello::
 004F                   .dbline -1
 004F                   .dbline 187
 004F           ; }
 004F           ; 
 004F           ; // This function transmits a response to a hello command from the master.
 004F           ; void sayHello(void)
 004F           ; {     
 004F                   .dbline 188
 004F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004F 5000              mov A,0
 0051 08                push A
 0052 5002              mov A,2
 0054 08                push A
 0055 905D              xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 191
 0059           ;       
 0059           ;       // Transmit a hello response to the master node.
 0059           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TX_014_PutChar
 005F 20                pop X
 0060                   .dbline 192
 0060           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TX_014_PutChar
 0066 20                pop X
 0067                   .dbline 193
 0067           ;       TX_014_PutChar(ID);                             // My ID (source)
 0067 10                push X
 0068 62D000            mov REG[0xd0],>_ID
 006B 5100              mov A,[_ID]
 006D 7C0000            xcall _TX_014_PutChar
 0070 20                pop X
 0071                   .dbline 194
 0071           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0071 10                push X
 0072 5000              mov A,0
 0074 7C0000            xcall _TX_014_PutChar
 0077 20                pop X
 0078                   .dbline 195
 0078           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0078 10                push X
 0079 50C8              mov A,-56
 007B 7C0000            xcall _TX_014_PutChar
 007E 20                pop X
 007F                   .dbline 196
 007F           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007F 10                push X
 0080 62D000            mov REG[0xd0],>_CHILD
 0083 5100              mov A,[_CHILD]
 0085 7C0000            xcall _TX_014_PutChar
 0088 20                pop X
 0089                   .dbline 197
 0089           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0089 10                push X
 008A 50FD              mov A,-3
 008C 7C0000            xcall _TX_014_PutChar
 008F 20                pop X
 0090                   .dbline 198
 0090           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0090 10                push X
 0091 50FD              mov A,-3
 0093 7C0000            xcall _TX_014_PutChar
 0096 20                pop X
 0097           L8:
 0097                   .dbline 201
 0097           ;       
 0097           ;       // Wait for the transmission to finish.
 0097           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0097           L9:
 0097                   .dbline 201
 0097 10                push X
 0098 7C0000            xcall _TX_014_bReadTxStatus
 009B 62D000            mov REG[0xd0],>__r0
 009E 20                pop X
 009F 5300              mov [__r0],A
 00A1 470020            tst [__r0],32
 00A4 AFF2              jz L8
 00A6                   .dbline 204
 00A6           ;       
 00A6           ;       // Make completely sure we're done.
 00A6           ;       xmitWait();
 00A6 7C102C            xcall _xmitWait
 00A9                   .dbline 206
 00A9           ; 
 00A9           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A9 5000              mov A,0
 00AB 08                push A
 00AC 5001              mov A,1
 00AE 08                push A
 00AF 9003              xcall _configToggle
 00B1 38FE              add SP,-2
 00B3                   .dbline -2
 00B3           L7:
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e configToggle _configToggle fV
 00B4           ;           mode -> X-5
 00B4           _configToggle::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6                   .dbline 212
 00B6           ; }
 00B6           ; 
 00B6           ; // This function receives a mode flag and switches the microcontroller to the
 00B6           ; // desired hardware configuration.
 00B6           ; void configToggle(int mode)
 00B6           ; {     
 00B6                   .dbline 215
 00B6           ;       // Set the pins high and disconnect from the global bus.
 00B6           ;       // This keeps false start bits from happening while we swap configs.
 00B6           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B6 43001F            or REG[0],31
 00B9                   .dbline 216
 00B9           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B9 4102E0            and REG[0x2],-32
 00BC                   .dbline 220
 00BC           ;       
 00BC           ;       // Unload the configuration of the current state.
 00BC           ;       // If there is no state, blindly wipe all configurations.
 00BC           ;       if(STATE)
 00BC 62D000            mov REG[0xd0],>_STATE
 00BF 3C0000            cmp [_STATE],0
 00C2 B006              jnz X2
 00C4 3C0100            cmp [_STATE+1],0
 00C7 A011              jz L12
 00C9           X2:
 00C9                   .dbline 221
 00C9           ;       {
 00C9                   .dbline 222
 00C9           ;               unloadConfig(STATE);
 00C9 62D000            mov REG[0xd0],>_STATE
 00CC 5100              mov A,[_STATE]
 00CE 08                push A
 00CF 5101              mov A,[_STATE+1]
 00D1 08                push A
 00D2 7C0B18            xcall _unloadConfig
 00D5 38FE              add SP,-2
 00D7                   .dbline 223
 00D7           ;       }
 00D7 8004              xjmp L13
 00D9           L12:
 00D9                   .dbline 225
 00D9           ;       else
 00D9           ;       {
 00D9                   .dbline 226
 00D9           ;               unloadAllConfigs();
 00D9 7C0AFC            xcall _unloadAllConfigs
 00DC                   .dbline 227
 00DC           ;       }
 00DC           L13:
 00DC                   .dbline 231
 00DC           ;       
 00DC           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DC           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DC           ;       if(mode == WAIT)
 00DC 3DFB00            cmp [X-5],0
 00DF B02E              jnz L14
 00E1 3DFC01            cmp [X-4],1
 00E4 B029              jnz L14
 00E6           X3:
 00E6                   .dbline 232
 00E6           ;       {
 00E6                   .dbline 235
 00E6           ;               // Load the wait receiver configuration.  This is the receiver configuration used after
 00E6           ;               // initialization is complete.  It listens and forwards everything it hears.
 00E6           ;               LoadConfig_waiting();
 00E6 7C0000            xcall _LoadConfig_waiting
 00E9                   .dbline 238
 00E9           ;               
 00E9           ;               // Clear the timeout flag.
 00E9           ;               TIMEOUT = 0;
 00E9 62D000            mov REG[0xd0],>_TIMEOUT
 00EC 550100            mov [_TIMEOUT+1],0
 00EF 550000            mov [_TIMEOUT],0
 00F2                   .dbline 241
 00F2           ;               
 00F2           ;               // Start the receivers.
 00F2           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00F2 10                push X
 00F3 5000              mov A,0
 00F5 7C0000            xcall _WAIT_RECV_Start
 00F8 20                pop X
 00F9                   .dbline 242
 00F9           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F9 10                push X
 00FA 5000              mov A,0
 00FC 7C0000            xcall _RX8_2_Start
 00FF                   .dbline 244
 00FF           ;               
 00FF           ;               WAIT_RECV_TIMEOUT_EnableInt();  // Make sure interrupts are enabled.
 00FF 7C0000            xcall _WAIT_RECV_TIMEOUT_EnableInt
 0102 20                pop X
 0103                   .dbline 247
 0103           ;               
 0103           ;               // Set the current state.
 0103           ;               STATE = WAIT;
 0103 62D000            mov REG[0xd0],>_STATE
 0106 550101            mov [_STATE+1],1
 0109 550000            mov [_STATE],0
 010C                   .dbline 248
 010C           ;       }
 010C 81A0              xjmp L15
 010E           L14:
 010E                   .dbline 249
 010E           ;       else if(mode == MY_RESPONSE)
 010E 3DFB00            cmp [X-5],0
 0111 B04C              jnz L16
 0113 3DFC02            cmp [X-4],2
 0116 B047              jnz L16
 0118           X4:
 0118                   .dbline 250
 0118           ;       {
 0118                   .dbline 252
 0118           ;               // Load the transmitter configuration.  This is for transmitting messages on all ports.
 0118           ;               LoadConfig_my_response();
 0118 7C0000            xcall _LoadConfig_my_response
 011B                   .dbline 255
 011B           ;               
 011B           ;               // Clear the timeout flag.
 011B           ;               TIMEOUT = 0;
 011B 62D000            mov REG[0xd0],>_TIMEOUT
 011E 550100            mov [_TIMEOUT+1],0
 0121 550000            mov [_TIMEOUT],0
 0124                   .dbline 258
 0124           ;               
 0124           ;               // Start the transmitters.
 0124           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0124 10                push X
 0125 5000              mov A,0
 0127 7C0000            xcall _TX_014_Start
 012A 20                pop X
 012B                   .dbline 259
 012B           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 012B 10                push X
 012C 5000              mov A,0
 012E 7C0000            xcall _TX_23_Start
 0131                   .dbline 261
 0131           ;               
 0131           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0131 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0134                   .dbline 262
 0134           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0134 7C0000            xcall _TX_01234_TIMEOUT_Start
 0137 20                pop X
 0138           L18:
 0138                   .dbline 266
 0138           ;               
 0138           ;               // Do nothing while we wait for one timeout period (1 ms).
 0138           ;               // This is to allow everyone to get in the right configuration before talking.
 0138           ;               while(!TIMEOUT) { }
 0138                   .dbline 266
 0138           L19:
 0138                   .dbline 266
 0138 62D000            mov REG[0xd0],>_TIMEOUT
 013B 3C0000            cmp [_TIMEOUT],0
 013E B006              jnz X5
 0140 3C0100            cmp [_TIMEOUT+1],0
 0143 AFF4              jz L18
 0145           X5:
 0145                   .dbline 268
 0145           ;               
 0145           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0145 10                push X
 0146 7C0000            xcall _TX_01234_TIMEOUT_Stop
 0149 20                pop X
 014A                   .dbline 269
 014A           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 014A 62D000            mov REG[0xd0],>_TIMEOUT
 014D 550100            mov [_TIMEOUT+1],0
 0150 550000            mov [_TIMEOUT],0
 0153                   .dbline 272
 0153           ;       
 0153           ;               // Set the current state.
 0153           ;               STATE = MY_RESPONSE;
 0153 62D000            mov REG[0xd0],>_STATE
 0156 550102            mov [_STATE+1],2
 0159 550000            mov [_STATE],0
 015C                   .dbline 273
 015C           ;       }
 015C 8150              xjmp L17
 015E           L16:
 015E                   .dbline 274
 015E           ;       else if(mode == RESPONSE_1)
 015E 3DFB00            cmp [X-5],0
 0161 B02A              jnz L21
 0163 3DFC03            cmp [X-4],3
 0166 B025              jnz L21
 0168           X6:
 0168                   .dbline 275
 0168           ;       {
 0168                   .dbline 277
 0168           ;               // Load the response wait on port 1.
 0168           ;               LoadConfig_response1();
 0168 7C0000            xcall _LoadConfig_response1
 016B                   .dbline 280
 016B           ;               
 016B           ;               // Clear the timeout flag.
 016B           ;               TIMEOUT = 0;
 016B 62D000            mov REG[0xd0],>_TIMEOUT
 016E 550100            mov [_TIMEOUT+1],0
 0171 550000            mov [_TIMEOUT],0
 0174                   .dbline 283
 0174           ;               
 0174           ;               // Start listening for a response through child port 1.
 0174           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0174 10                push X
 0175 5000              mov A,0
 0177 7C0000            xcall _CHILD_1_Start
 017A                   .dbline 285
 017A           ;               
 017A           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 017A 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 017D                   .dbline 286
 017D           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 017D 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0180 20                pop X
 0181                   .dbline 289
 0181           ;               
 0181           ;               // Set the current state.
 0181           ;               STATE = RESPONSE_1;
 0181 62D000            mov REG[0xd0],>_STATE
 0184 550103            mov [_STATE+1],3
 0187 550000            mov [_STATE],0
 018A                   .dbline 290
 018A           ;       }
 018A 8122              xjmp L22
 018C           L21:
 018C                   .dbline 291
 018C           ;       else if(mode == RESPONSE_2)
 018C 3DFB00            cmp [X-5],0
 018F B02A              jnz L23
 0191 3DFC04            cmp [X-4],4
 0194 B025              jnz L23
 0196           X7:
 0196                   .dbline 292
 0196           ;       {
 0196                   .dbline 294
 0196           ;               // Load the response wait on port 2.
 0196           ;               LoadConfig_response2();
 0196 7C0000            xcall _LoadConfig_response2
 0199                   .dbline 297
 0199           ;               
 0199           ;               // Clear the timeout flag.
 0199           ;               TIMEOUT = 0;
 0199 62D000            mov REG[0xd0],>_TIMEOUT
 019C 550100            mov [_TIMEOUT+1],0
 019F 550000            mov [_TIMEOUT],0
 01A2                   .dbline 300
 01A2           ;               
 01A2           ;               // Start listening for a response through child port 2.
 01A2           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 01A2 10                push X
 01A3 5000              mov A,0
 01A5 7C0000            xcall _CHILD_2_Start
 01A8                   .dbline 302
 01A8           ;               
 01A8           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01A8 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 01AB                   .dbline 303
 01AB           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 01AB 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01AE 20                pop X
 01AF                   .dbline 306
 01AF           ;               
 01AF           ;               // Set the current state.
 01AF           ;               STATE = RESPONSE_2;
 01AF 62D000            mov REG[0xd0],>_STATE
 01B2 550104            mov [_STATE+1],4
 01B5 550000            mov [_STATE],0
 01B8                   .dbline 307
 01B8           ;       }
 01B8 80F4              xjmp L24
 01BA           L23:
 01BA                   .dbline 308
 01BA           ;       else if(mode == RESPONSE_3)
 01BA 3DFB00            cmp [X-5],0
 01BD B02A              jnz L25
 01BF 3DFC05            cmp [X-4],5
 01C2 B025              jnz L25
 01C4           X8:
 01C4                   .dbline 309
 01C4           ;       {
 01C4                   .dbline 311
 01C4           ;               // Load the response wait on port 3.
 01C4           ;               LoadConfig_response3();
 01C4 7C0000            xcall _LoadConfig_response3
 01C7                   .dbline 314
 01C7           ;               
 01C7           ;               // Clear the timeout flag.
 01C7           ;               TIMEOUT = 0;
 01C7 62D000            mov REG[0xd0],>_TIMEOUT
 01CA 550100            mov [_TIMEOUT+1],0
 01CD 550000            mov [_TIMEOUT],0
 01D0                   .dbline 317
 01D0           ;               
 01D0           ;               // Start listening for a response through child port 3.
 01D0           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01D0 10                push X
 01D1 5000              mov A,0
 01D3 7C0000            xcall _CHILD_3_Start
 01D6                   .dbline 319
 01D6           ;               
 01D6           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01D6 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01D9                   .dbline 320
 01D9           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01D9 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01DC 20                pop X
 01DD                   .dbline 323
 01DD           ;               
 01DD           ;               // Set the current state.
 01DD           ;               STATE = RESPONSE_3;
 01DD 62D000            mov REG[0xd0],>_STATE
 01E0 550105            mov [_STATE+1],5
 01E3 550000            mov [_STATE],0
 01E6                   .dbline 324
 01E6           ;       }
 01E6 80C6              xjmp L26
 01E8           L25:
 01E8                   .dbline 325
 01E8           ;       else if(mode == RESPONSE_4)
 01E8 3DFB00            cmp [X-5],0
 01EB B02A              jnz L27
 01ED 3DFC06            cmp [X-4],6
 01F0 B025              jnz L27
 01F2           X9:
 01F2                   .dbline 326
 01F2           ;       {
 01F2                   .dbline 328
 01F2           ;               // Load the response wait on port 4.
 01F2           ;               LoadConfig_response4();
 01F2 7C0000            xcall _LoadConfig_response4
 01F5                   .dbline 331
 01F5           ;               
 01F5           ;               // Clear the timeout flag.
 01F5           ;               TIMEOUT = 0;
 01F5 62D000            mov REG[0xd0],>_TIMEOUT
 01F8 550100            mov [_TIMEOUT+1],0
 01FB 550000            mov [_TIMEOUT],0
 01FE                   .dbline 334
 01FE           ;               
 01FE           ;               // Start listening for a response through child port 4.
 01FE           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01FE 10                push X
 01FF 5000              mov A,0
 0201 7C0000            xcall _CHILD_4_Start
 0204                   .dbline 336
 0204           ;               
 0204           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 0204 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 0207                   .dbline 337
 0207           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 0207 7C0000            xcall _CHILD_4_TIMEOUT_Start
 020A 20                pop X
 020B                   .dbline 340
 020B           ;               
 020B           ;               // Set the current state.
 020B           ;               STATE = RESPONSE_4;
 020B 62D000            mov REG[0xd0],>_STATE
 020E 550106            mov [_STATE+1],6
 0211 550000            mov [_STATE],0
 0214                   .dbline 341
 0214           ;       }
 0214 8098              xjmp L28
 0216           L27:
 0216                   .dbline 342
 0216           ;       else if(mode == HELLO_MODE)
 0216 3DFB00            cmp [X-5],0
 0219 B03F              jnz L29
 021B 3DFC07            cmp [X-4],7
 021E B03A              jnz L29
 0220           X10:
 0220                   .dbline 343
 0220           ;       {
 0220                   .dbline 345
 0220           ;               // Load the hello wait mode.  This is for listening on all ports for a hello response.
 0220           ;               LoadConfig_hello();
 0220 7C0000            xcall _LoadConfig_hello
 0223                   .dbline 348
 0223           ;               
 0223           ;               // Clear the timeout flag.
 0223           ;               TIMEOUT = 0;
 0223 62D000            mov REG[0xd0],>_TIMEOUT
 0226 550100            mov [_TIMEOUT+1],0
 0229 550000            mov [_TIMEOUT],0
 022C                   .dbline 352
 022C           ;               
 022C           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 022C           ;       
 022C           ;               {
 022C                   .dbline 354
 022C           ;               // Start listening for a response through child port 1.
 022C           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 022C 10                push X
 022D 5000              mov A,0
 022F 7C0000            xcall _HELLO_1_Start
 0232 20                pop X
 0233                   .dbline 355
 0233           ;               }
 0233                   .dbline 357
 0233           ;               
 0233           ;               {
 0233                   .dbline 359
 0233           ;               // Start listening for a response through child port 2.
 0233           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0233 10                push X
 0234 5000              mov A,0
 0236 7C0000            xcall _HELLO_2_Start
 0239 20                pop X
 023A                   .dbline 360
 023A           ;               }
 023A                   .dbline 362
 023A           ;               
 023A           ;               {
 023A                   .dbline 364
 023A           ;               // Start listening for a response through child port 3.
 023A           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 023A 10                push X
 023B 5000              mov A,0
 023D 7C0000            xcall _HELLO_3_Start
 0240 20                pop X
 0241                   .dbline 365
 0241           ;               }
 0241                   .dbline 367
 0241           ;               
 0241           ;               {
 0241                   .dbline 369
 0241           ;               // Start listening for a response through child port 4.
 0241           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0241 10                push X
 0242 5000              mov A,0
 0244 7C0000            xcall _HELLO_4_Start
 0247                   .dbline 370
 0247           ;               }
 0247                   .dbline 372
 0247           ;               
 0247           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 0247 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 024A                   .dbline 373
 024A           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 024A 7C0000            xcall _HELLO_TIMEOUT_Start
 024D 20                pop X
 024E                   .dbline 376
 024E           ;               
 024E           ;               // Set the current state.
 024E           ;               STATE = HELLO_MODE;
 024E 62D000            mov REG[0xd0],>_STATE
 0251 550107            mov [_STATE+1],7
 0254 550000            mov [_STATE],0
 0257                   .dbline 377
 0257           ;       }
 0257 8055              xjmp L30
 0259           L29:
 0259                   .dbline 378
 0259           ;       else if(mode == INITIALIZE)
 0259 3DFB00            cmp [X-5],0
 025C B02A              jnz L31
 025E 3DFC08            cmp [X-4],8
 0261 B025              jnz L31
 0263           X11:
 0263                   .dbline 379
 0263           ;       {
 0263                   .dbline 381
 0263           ;               // Load the configuration for initialization.  This config listens but does not forward.
 0263           ;               LoadConfig_initial();
 0263 7C0000            xcall _LoadConfig_initial
 0266                   .dbline 384
 0266           ;               
 0266           ;               // Clear the timeout flag.
 0266           ;               TIMEOUT = 0;
 0266 62D000            mov REG[0xd0],>_TIMEOUT
 0269 550100            mov [_TIMEOUT+1],0
 026C 550000            mov [_TIMEOUT],0
 026F                   .dbline 387
 026F           ;               
 026F           ;               // Start the receiver.
 026F           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 026F 10                push X
 0270 5000              mov A,0
 0272 7C0000            xcall _INIT_RX_Start
 0275                   .dbline 389
 0275           ;               
 0275           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0275 7C0000            xcall _INIT_TIMEOUT_EnableInt
 0278                   .dbline 390
 0278           ;               INIT_TIMEOUT_Start();           // Start the timer.
 0278 7C0000            xcall _INIT_TIMEOUT_Start
 027B 20                pop X
 027C                   .dbline 393
 027C           ;               
 027C           ;               // Set the current state.
 027C           ;               STATE = INITIALIZE;
 027C 62D000            mov REG[0xd0],>_STATE
 027F 550108            mov [_STATE+1],8
 0282 550000            mov [_STATE],0
 0285                   .dbline 394
 0285           ;       }
 0285 8027              xjmp L32
 0287           L31:
 0287                   .dbline 395
 0287           ;       else if(mode == SERVO_COMM)
 0287 3DFB00            cmp [X-5],0
 028A B022              jnz L33
 028C 3DFC09            cmp [X-4],9
 028F B01D              jnz L33
 0291           X12:
 0291                   .dbline 396
 0291           ;       {
 0291                   .dbline 398
 0291           ;               // Load the configuration for servo communication.  This config only transmits on P00.
 0291           ;               LoadConfig_servo_transmit();
 0291 7C0000            xcall _LoadConfig_servo_transmit
 0294                   .dbline 401
 0294           ;               
 0294           ;               // Clear the timeout flag.
 0294           ;               TIMEOUT = 0;
 0294 62D000            mov REG[0xd0],>_TIMEOUT
 0297 550100            mov [_TIMEOUT+1],0
 029A 550000            mov [_TIMEOUT],0
 029D                   .dbline 404
 029D           ;               
 029D           ;               // Start the transmitter.
 029D           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 029D 10                push X
 029E 5000              mov A,0
 02A0 7C0000            xcall _SERVO_TX_Start
 02A3 20                pop X
 02A4                   .dbline 407
 02A4           ;       
 02A4           ;               // Set the current state.
 02A4           ;               STATE = SERVO_COMM;
 02A4 62D000            mov REG[0xd0],>_STATE
 02A7 550109            mov [_STATE+1],9
 02AA 550000            mov [_STATE],0
 02AD                   .dbline 408
 02AD           ;       }
 02AD           L33:
 02AD           L32:
 02AD           L30:
 02AD           L28:
 02AD           L26:
 02AD           L24:
 02AD           L22:
 02AD           L17:
 02AD           L15:
 02AD                   .dbline 411
 02AD           ;       
 02AD           ;       // If this module is configured, talk on all pins for potential children.
 02AD           ;       if(CONFIGURED)
 02AD 62D000            mov REG[0xd0],>_CONFIGURED
 02B0 3C0000            cmp [_CONFIGURED],0
 02B3 B006              jnz X13
 02B5 3C0100            cmp [_CONFIGURED+1],0
 02B8 A009              jz L35
 02BA           X13:
 02BA                   .dbline 412
 02BA           ;       {
 02BA                   .dbline 413
 02BA           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02BA 43021F            or REG[0x2],31
 02BD                   .dbline 414
 02BD           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02BD 4108FE            and REG[0x8],-2
 02C0                   .dbline 415
 02C0           ;       }
 02C0 8007              xjmp L36
 02C2           L35:
 02C2                   .dbline 417
 02C2           ;       else
 02C2           ;       {
 02C2                   .dbline 418
 02C2           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02C2 430201            or REG[0x2],1
 02C5                   .dbline 419
 02C5           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02C5 430801            or REG[0x8],1
 02C8                   .dbline 420
 02C8           ;       }
 02C8           L36:
 02C8                   .dbline -2
 02C8           L11:
 02C8 20                pop X
 02C9                   .dbline 0 ; func end
 02C9 7F                ret
 02CA                   .dbsym l mode -5 I
 02CA                   .dbend
 02CA                   .dbfunc e commandReady _commandReady fI
 02CA           ;              i -> X+1
 02CA           ;       tempByte -> X+0
 02CA           _commandReady::
 02CA                   .dbline -1
 02CA 10                push X
 02CB 4F                mov X,SP
 02CC 3803              add SP,3
 02CE                   .dbline 427
 02CE           ; }
 02CE           ; 
 02CE           ; // This function tries to peek and see if a start byte has been written to the bus.
 02CE           ; // If there is no start byte, the function exits.  If a start byte is detected, the function
 02CE           ; // blocks and waits for the transmission to finish.
 02CE           ; int commandReady(void)
 02CE           ; {
 02CE                   .dbline 428
 02CE           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02CE 560200            mov [X+2],0
 02D1 560100            mov [X+1],0
 02D4                   .dbline 429
 02D4           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02D4 560000            mov [X+0],0
 02D7                   .dbline 433
 02D7           ;       
 02D7           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02D7           ;       // read a transmission and store the important information from that transmission.
 02D7           ;       if(STATE == WAIT)
 02D7 62D000            mov REG[0xd0],>_STATE
 02DA 3C0000            cmp [_STATE],0
 02DD B0D4              jnz L38
 02DF 3C0101            cmp [_STATE+1],1
 02E2 B0CF              jnz L38
 02E4           X14:
 02E4                   .dbline 434
 02E4           ;       {       
 02E4                   .dbline 437
 02E4           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02E4           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02E4           ;               tempByte = WAIT_RECV_cGetChar();
 02E4 10                push X
 02E5 7C0000            xcall _WAIT_RECV_cGetChar
 02E8 62D000            mov REG[0xd0],>__r0
 02EB 20                pop X
 02EC 5400              mov [X+0],A
 02EE                   .dbline 440
 02EE           ;               
 02EE           ;               // If a transmission has started for either a controller or a servo...
 02EE           ;               if(tempByte == START_TRANSMIT)
 02EE 3D00FC            cmp [X+0],-4
 02F1 B047              jnz L40
 02F3                   .dbline 441
 02F3           ;               {
 02F3 800B              xjmp L43
 02F5           L42:
 02F5                   .dbline 444
 02F5           ;                       // While we keep reading start bytes, sit and spin.
 02F5           ;                       while(tempByte == START_TRANSMIT)
 02F5           ;                       {
 02F5                   .dbline 445
 02F5           ;                               tempByte = WAIT_RECV_cGetChar();
 02F5 10                push X
 02F6 7C0000            xcall _WAIT_RECV_cGetChar
 02F9 62D000            mov REG[0xd0],>__r0
 02FC 20                pop X
 02FD 5400              mov [X+0],A
 02FF                   .dbline 446
 02FF           ;                       }
 02FF           L43:
 02FF                   .dbline 443
 02FF 3D00FC            cmp [X+0],-4
 0302 AFF2              jz L42
 0304                   .dbline 449
 0304           ;                       
 0304           ;                       // The tempByte variable contains the source ID.  If the source is good, store all bytes.
 0304           ;                       if(tempByte == MASTER_ID)
 0304 3D0000            cmp [X+0],0
 0307 B43F              jnz L39
 0309                   .dbline 450
 0309           ;                       {
 0309                   .dbline 451
 0309           ;                               COMMAND_SOURCE = tempByte;
 0309 5200              mov A,[X+0]
 030B 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 030E 5300              mov [_COMMAND_SOURCE],A
 0310                   .dbline 452
 0310           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 0310 10                push X
 0311 7C0000            xcall _WAIT_RECV_cGetChar
 0314 20                pop X
 0315 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0318 5300              mov [_COMMAND_DESTINATION],A
 031A                   .dbline 453
 031A           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 031A 10                push X
 031B 7C0000            xcall _WAIT_RECV_cGetChar
 031E 20                pop X
 031F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0322 5300              mov [_COMMAND_TYPE],A
 0324                   .dbline 454
 0324           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 0324 10                push X
 0325 7C0000            xcall _WAIT_RECV_cGetChar
 0328 20                pop X
 0329 62D000            mov REG[0xd0],>_COMMAND_PARAM
 032C 5300              mov [_COMMAND_PARAM],A
 032E                   .dbline 456
 032E           ;                               
 032E           ;                               return 1;
 032E 62D000            mov REG[0xd0],>__r0
 0331 550001            mov [__r1],1
 0334 550000            mov [__r0],0
 0337 8418              xjmp L37
 0339           L40:
 0339                   .dbline 459
 0339           ;                       }
 0339           ;               }
 0339           ;               else if(tempByte == SERVO_START)
 0339 3D00FF            cmp [X+0],-1
 033C B40A              jnz L39
 033E                   .dbline 460
 033E           ;               {
 033E 800B              xjmp L50
 0340           L49:
 0340                   .dbline 463
 0340           ;                       // While we keep reading start bytes, sit and spin.
 0340           ;                       while(tempByte == SERVO_START)
 0340           ;                       {
 0340                   .dbline 464
 0340           ;                               tempByte = WAIT_RECV_cGetChar();
 0340 10                push X
 0341 7C0000            xcall _WAIT_RECV_cGetChar
 0344 62D000            mov REG[0xd0],>__r0
 0347 20                pop X
 0348 5400              mov [X+0],A
 034A                   .dbline 465
 034A           ;                       }
 034A           L50:
 034A                   .dbline 462
 034A 3D00FF            cmp [X+0],-1
 034D AFF2              jz L49
 034F                   .dbline 468
 034F           ;                       
 034F           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 034F           ;                       COMMAND_SOURCE = MASTER_ID;
 034F 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0352 550000            mov [_COMMAND_SOURCE],0
 0355                   .dbline 470
 0355           ;                       // The first parameter after the servo start is the destination.
 0355           ;                       COMMAND_DESTINATION = tempByte;
 0355 5200              mov A,[X+0]
 0357 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 035A 5300              mov [_COMMAND_DESTINATION],A
 035C                   .dbline 472
 035C           ;                       // The second parameter after the servo start is the command length.
 035C           ;                       tempByte = WAIT_RECV_cGetChar();
 035C 10                push X
 035D 7C0000            xcall _WAIT_RECV_cGetChar
 0360 62D000            mov REG[0xd0],>__r0
 0363 20                pop X
 0364 5400              mov [X+0],A
 0366                   .dbline 475
 0366           ;                       // Now we store the command type.  Depending on what the status return level
 0366           ;                       // is, we have special duties.
 0366           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0366 10                push X
 0367 7C0000            xcall _WAIT_RECV_cGetChar
 036A 20                pop X
 036B 62D000            mov REG[0xd0],>_COMMAND_TYPE
 036E 5300              mov [_COMMAND_TYPE],A
 0370                   .dbline 478
 0370           ;                       
 0370           ;                       // This basically waits for the rest of the command to pass through.
 0370           ;                       for(i = 0; i < (tempByte - 1); i++)
 0370 560200            mov [X+2],0
 0373 560100            mov [X+1],0
 0376 800E              xjmp L55
 0378           L52:
 0378                   .dbline 479
 0378           ;                       {
 0378                   .dbline 480
 0378           ;                               WAIT_RECV_cGetChar();
 0378 10                push X
 0379 7C0000            xcall _WAIT_RECV_cGetChar
 037C 62D000            mov REG[0xd0],>__r0
 037F 20                pop X
 0380                   .dbline 481
 0380           ;                       }
 0380           L53:
 0380                   .dbline 478
 0380 7702              inc [X+2]
 0382 0F0100            adc [X+1],0
 0385           L55:
 0385                   .dbline 478
 0385 62D000            mov REG[0xd0],>__r0
 0388 5200              mov A,[X+0]
 038A 5300              mov [__r1],A
 038C 550000            mov [__r0],0
 038F 160001            sub [__r1],1
 0392 1E0000            sbb [__r0],0
 0395 5202              mov A,[X+2]
 0397 1200              sub A,[__r1]
 0399 5100              mov A,[__r0]
 039B 3180              xor A,-128
 039D 5300              mov [__rX],A
 039F 5201              mov A,[X+1]
 03A1 3180              xor A,-128
 03A3 1A00              sbb A,[__rX]
 03A5 CFD2              jc L52
 03A7           X15:
 03A7                   .dbline 483
 03A7           ;                               
 03A7           ;                       return 1;
 03A7 62D000            mov REG[0xd0],>__r0
 03AA 550001            mov [__r1],1
 03AD 550000            mov [__r0],0
 03B0 839F              xjmp L37
 03B2           L38:
 03B2                   .dbline 486
 03B2           ;               }
 03B2           ;       }
 03B2           ;       else if(STATE == HELLO_MODE)
 03B2 62D000            mov REG[0xd0],>_STATE
 03B5 3C0000            cmp [_STATE],0
 03B8 B06E              jnz L56
 03BA 3C0107            cmp [_STATE+1],7
 03BD B069              jnz L56
 03BF           X16:
 03BF                   .dbline 487
 03BF           ;       {
 03BF                   .dbline 489
 03BF           ;               // Check all of the ports for a start byte.  Only one port will produce one.
 03BF           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03BF 10                push X
 03C0 7C0000            xcall _HELLO_1_cReadChar
 03C3 20                pop X
 03C4 39FC              cmp A,-4
 03C6 B012              jnz L58
 03C8                   .dbline 490
 03C8           ;               {               
 03C8                   .dbline 491
 03C8           ;                       CHILD = PORT_A;
 03C8 62D000            mov REG[0xd0],>_CHILD
 03CB 550041            mov [_CHILD],65
 03CE                   .dbline 493
 03CE           ;                       
 03CE           ;                       return 1;
 03CE 62D000            mov REG[0xd0],>__r0
 03D1 550001            mov [__r1],1
 03D4 550000            mov [__r0],0
 03D7 8378              xjmp L37
 03D9           L58:
 03D9                   .dbline 495
 03D9           ;               }
 03D9           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03D9 10                push X
 03DA 7C0000            xcall _HELLO_2_cReadChar
 03DD 20                pop X
 03DE 39FC              cmp A,-4
 03E0 B012              jnz L60
 03E2                   .dbline 496
 03E2           ;               {               
 03E2                   .dbline 497
 03E2           ;                       CHILD = PORT_B;
 03E2 62D000            mov REG[0xd0],>_CHILD
 03E5 550042            mov [_CHILD],66
 03E8                   .dbline 499
 03E8           ;                       
 03E8           ;                       return 1;
 03E8 62D000            mov REG[0xd0],>__r0
 03EB 550001            mov [__r1],1
 03EE 550000            mov [__r0],0
 03F1 835E              xjmp L37
 03F3           L60:
 03F3                   .dbline 501
 03F3           ;               }
 03F3           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03F3 10                push X
 03F4 7C0000            xcall _HELLO_3_cReadChar
 03F7 20                pop X
 03F8 39FC              cmp A,-4
 03FA B012              jnz L62
 03FC                   .dbline 502
 03FC           ;               {
 03FC                   .dbline 503
 03FC           ;                       CHILD = PORT_C;
 03FC 62D000            mov REG[0xd0],>_CHILD
 03FF 550043            mov [_CHILD],67
 0402                   .dbline 505
 0402           ;                       
 0402           ;                       return 1;
 0402 62D000            mov REG[0xd0],>__r0
 0405 550001            mov [__r1],1
 0408 550000            mov [__r0],0
 040B 8344              xjmp L37
 040D           L62:
 040D                   .dbline 507
 040D           ;               }
 040D           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 040D 10                push X
 040E 7C0000            xcall _HELLO_4_cReadChar
 0411 20                pop X
 0412 39FC              cmp A,-4
 0414 B332              jnz L57
 0416                   .dbline 508
 0416           ;               {
 0416                   .dbline 509
 0416           ;                       CHILD = PORT_D;
 0416 62D000            mov REG[0xd0],>_CHILD
 0419 550044            mov [_CHILD],68
 041C                   .dbline 511
 041C           ;                       
 041C           ;                       return 1;
 041C 62D000            mov REG[0xd0],>__r0
 041F 550001            mov [__r1],1
 0422 550000            mov [__r0],0
 0425 832A              xjmp L37
 0427           L56:
 0427                   .dbline 514
 0427           ;               }
 0427           ;       }
 0427           ;       else if(STATE == RESPONSE_1)
 0427 62D000            mov REG[0xd0],>_STATE
 042A 3C0000            cmp [_STATE],0
 042D B0AB              jnz L66
 042F 3C0103            cmp [_STATE+1],3
 0432 B0A6              jnz L66
 0434           X17:
 0434                   .dbline 515
 0434           ;       {
 0434                   .dbline 516
 0434           ;               if(tempByte = CHILD_1_cReadChar())
 0434 10                push X
 0435 7C0000            xcall _CHILD_1_cReadChar
 0438 62D000            mov REG[0xd0],>__r0
 043B 20                pop X
 043C 5400              mov [X+0],A
 043E 3900              cmp A,0
 0440 A306              jz L67
 0442                   .dbline 517
 0442           ;               {
 0442                   .dbline 518
 0442           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0442 3D00FF            cmp [X+0],-1
 0445 B069              jnz L70
 0447                   .dbline 519
 0447           ;                       {
 0447 8058              xjmp L73
 0449           L72:
 0449                   .dbline 521
 0449           ;                               while(!TIMEOUT)
 0449           ;                               {
 0449                   .dbline 523
 0449           ;                                       // Check for the second start byte.
 0449           ;                                       if(CHILD_1_cReadChar() == SERVO_START)
 0449 10                push X
 044A 7C0000            xcall _CHILD_1_cReadChar
 044D 62D000            mov REG[0xd0],>__r0
 0450 20                pop X
 0451 39FF              cmp A,-1
 0453 B04C              jnz L75
 0455                   .dbline 524
 0455           ;                                       {
 0455                   .dbline 526
 0455           ;                                               // Burn the ID, since we don't care what it is.
 0455           ;                                               CHILD_1_cGetChar();
 0455 10                push X
 0456 7C0000            xcall _CHILD_1_cGetChar
 0459 62D000            mov REG[0xd0],>__r0
 045C 20                pop X
 045D                   .dbline 529
 045D           ;                                               
 045D           ;                                               // We store the length, since it is the next byte from the servo.
 045D           ;                                               tempByte = CHILD_1_cGetChar();
 045D 10                push X
 045E 7C0000            xcall _CHILD_1_cGetChar
 0461 62D000            mov REG[0xd0],>__r0
 0464 20                pop X
 0465 5400              mov [X+0],A
 0467                   .dbline 532
 0467           ;                                               
 0467           ;                                               // This basically waits for the rest of the command to pass through.
 0467           ;                                               for(i = 0; i < tempByte; i++)
 0467 560200            mov [X+2],0
 046A 560100            mov [X+1],0
 046D 800E              xjmp L80
 046F           L77:
 046F                   .dbline 533
 046F           ;                                               {
 046F                   .dbline 534
 046F           ;                                                       CHILD_1_cGetChar();
 046F 10                push X
 0470 7C0000            xcall _CHILD_1_cGetChar
 0473 62D000            mov REG[0xd0],>__r0
 0476 20                pop X
 0477                   .dbline 535
 0477           ;                                               }
 0477           L78:
 0477                   .dbline 532
 0477 7702              inc [X+2]
 0479 0F0100            adc [X+1],0
 047C           L80:
 047C                   .dbline 532
 047C 62D000            mov REG[0xd0],>__r0
 047F 5200              mov A,[X+0]
 0481 5300              mov [__r1],A
 0483 5202              mov A,[X+2]
 0485 1200              sub A,[__r1]
 0487 5000              mov A,0
 0489 3180              xor A,-128
 048B 5300              mov [__rX],A
 048D 5201              mov A,[X+1]
 048F 3180              xor A,-128
 0491 1A00              sbb A,[__rX]
 0493 CFDB              jc L77
 0495           X18:
 0495                   .dbline 537
 0495           ;                                               
 0495           ;                                               return 1;
 0495 62D000            mov REG[0xd0],>__r0
 0498 550001            mov [__r1],1
 049B 550000            mov [__r0],0
 049E 82B1              xjmp L37
 04A0           L75:
 04A0                   .dbline 539
 04A0           ;                                       }
 04A0           ;                               }
 04A0           L73:
 04A0                   .dbline 520
 04A0 62D000            mov REG[0xd0],>_TIMEOUT
 04A3 3C0000            cmp [_TIMEOUT],0
 04A6 B006              jnz X19
 04A8 3C0100            cmp [_TIMEOUT+1],0
 04AB AF9D              jz L72
 04AD           X19:
 04AD                   .dbline 540
 04AD           ;                       }
 04AD 8299              xjmp L67
 04AF           L70:
 04AF                   .dbline 541
 04AF           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 04AF 3D00FC            cmp [X+0],-4
 04B2 B294              jnz L67
 04B4                   .dbline 542
 04B4           ;                       {
 04B4 8015              xjmp L84
 04B6           L83:
 04B6                   .dbline 544
 04B6           ;                               while(!TIMEOUT)
 04B6           ;                               {
 04B6                   .dbline 546
 04B6           ;                                       // We simply wait for the end transmit indicator.
 04B6           ;                                       if(CHILD_1_cReadChar() == END_TRANSMIT)
 04B6 10                push X
 04B7 7C0000            xcall _CHILD_1_cReadChar
 04BA 62D000            mov REG[0xd0],>__r0
 04BD 20                pop X
 04BE 39FD              cmp A,-3
 04C0 B009              jnz L86
 04C2                   .dbline 547
 04C2           ;                                       {
 04C2                   .dbline 548
 04C2           ;                                               return 1;
 04C2 550001            mov [__r1],1
 04C5 550000            mov [__r0],0
 04C8 8287              xjmp L37
 04CA           L86:
 04CA                   .dbline 550
 04CA           ;                                       }
 04CA           ;                               }
 04CA           L84:
 04CA                   .dbline 543
 04CA 62D000            mov REG[0xd0],>_TIMEOUT
 04CD 3C0000            cmp [_TIMEOUT],0
 04D0 B006              jnz X20
 04D2 3C0100            cmp [_TIMEOUT+1],0
 04D5 AFE0              jz L83
 04D7           X20:
 04D7                   .dbline 551
 04D7           ;                       }
 04D7                   .dbline 552
 04D7           ;               }
 04D7                   .dbline 553
 04D7           ;       }
 04D7 826F              xjmp L67
 04D9           L66:
 04D9                   .dbline 554
 04D9           ;       else if(STATE == RESPONSE_2)
 04D9 62D000            mov REG[0xd0],>_STATE
 04DC 3C0000            cmp [_STATE],0
 04DF B0AB              jnz L88
 04E1 3C0104            cmp [_STATE+1],4
 04E4 B0A6              jnz L88
 04E6           X21:
 04E6                   .dbline 555
 04E6           ;       {
 04E6                   .dbline 556
 04E6           ;               if(tempByte = CHILD_2_cReadChar())
 04E6 10                push X
 04E7 7C0000            xcall _CHILD_2_cReadChar
 04EA 62D000            mov REG[0xd0],>__r0
 04ED 20                pop X
 04EE 5400              mov [X+0],A
 04F0 3900              cmp A,0
 04F2 A254              jz L89
 04F4                   .dbline 557
 04F4           ;               {
 04F4                   .dbline 558
 04F4           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 04F4 3D00FF            cmp [X+0],-1
 04F7 B069              jnz L92
 04F9                   .dbline 559
 04F9           ;                       {
 04F9 8058              xjmp L95
 04FB           L94:
 04FB                   .dbline 561
 04FB           ;                               while(!TIMEOUT)
 04FB           ;                               {
 04FB                   .dbline 563
 04FB           ;                                       // Check for the second start byte.
 04FB           ;                                       if(CHILD_2_cReadChar() == SERVO_START)
 04FB 10                push X
 04FC 7C0000            xcall _CHILD_2_cReadChar
 04FF 62D000            mov REG[0xd0],>__r0
 0502 20                pop X
 0503 39FF              cmp A,-1
 0505 B04C              jnz L97
 0507                   .dbline 564
 0507           ;                                       {
 0507                   .dbline 566
 0507           ;                                               // Burn the ID, since we don't care what it is.
 0507           ;                                               CHILD_2_cGetChar();
 0507 10                push X
 0508 7C0000            xcall _CHILD_2_cGetChar
 050B 62D000            mov REG[0xd0],>__r0
 050E 20                pop X
 050F                   .dbline 569
 050F           ;                                               
 050F           ;                                               // We store the length, since it is the next byte from the servo.
 050F           ;                                               tempByte = CHILD_2_cGetChar();
 050F 10                push X
 0510 7C0000            xcall _CHILD_2_cGetChar
 0513 62D000            mov REG[0xd0],>__r0
 0516 20                pop X
 0517 5400              mov [X+0],A
 0519                   .dbline 572
 0519           ;                                               
 0519           ;                                               // This basically waits for the rest of the command to pass through.
 0519           ;                                               for(i = 0; i < tempByte; i++)
 0519 560200            mov [X+2],0
 051C 560100            mov [X+1],0
 051F 800E              xjmp L102
 0521           L99:
 0521                   .dbline 573
 0521           ;                                               {
 0521                   .dbline 574
 0521           ;                                                       CHILD_2_cGetChar();
 0521 10                push X
 0522 7C0000            xcall _CHILD_2_cGetChar
 0525 62D000            mov REG[0xd0],>__r0
 0528 20                pop X
 0529                   .dbline 575
 0529           ;                                               }
 0529           L100:
 0529                   .dbline 572
 0529 7702              inc [X+2]
 052B 0F0100            adc [X+1],0
 052E           L102:
 052E                   .dbline 572
 052E 62D000            mov REG[0xd0],>__r0
 0531 5200              mov A,[X+0]
 0533 5300              mov [__r1],A
 0535 5202              mov A,[X+2]
 0537 1200              sub A,[__r1]
 0539 5000              mov A,0
 053B 3180              xor A,-128
 053D 5300              mov [__rX],A
 053F 5201              mov A,[X+1]
 0541 3180              xor A,-128
 0543 1A00              sbb A,[__rX]
 0545 CFDB              jc L99
 0547           X22:
 0547                   .dbline 577
 0547           ;                                               
 0547           ;                                               return 1;
 0547 62D000            mov REG[0xd0],>__r0
 054A 550001            mov [__r1],1
 054D 550000            mov [__r0],0
 0550 81FF              xjmp L37
 0552           L97:
 0552                   .dbline 579
 0552           ;                                       }
 0552           ;                               }
 0552           L95:
 0552                   .dbline 560
 0552 62D000            mov REG[0xd0],>_TIMEOUT
 0555 3C0000            cmp [_TIMEOUT],0
 0558 B006              jnz X23
 055A 3C0100            cmp [_TIMEOUT+1],0
 055D AF9D              jz L94
 055F           X23:
 055F                   .dbline 580
 055F           ;                       }
 055F 81E7              xjmp L89
 0561           L92:
 0561                   .dbline 581
 0561           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0561 3D00FC            cmp [X+0],-4
 0564 B1E2              jnz L89
 0566                   .dbline 582
 0566           ;                       {
 0566 8015              xjmp L106
 0568           L105:
 0568                   .dbline 584
 0568           ;                               while(!TIMEOUT)
 0568           ;                               {
 0568                   .dbline 586
 0568           ;                                       // We simply wait for the end transmit indicator.
 0568           ;                                       if(CHILD_2_cReadChar() == END_TRANSMIT)
 0568 10                push X
 0569 7C0000            xcall _CHILD_2_cReadChar
 056C 62D000            mov REG[0xd0],>__r0
 056F 20                pop X
 0570 39FD              cmp A,-3
 0572 B009              jnz L108
 0574                   .dbline 587
 0574           ;                                       {
 0574                   .dbline 588
 0574           ;                                               return 1;
 0574 550001            mov [__r1],1
 0577 550000            mov [__r0],0
 057A 81D5              xjmp L37
 057C           L108:
 057C                   .dbline 590
 057C           ;                                       }
 057C           ;                               }
 057C           L106:
 057C                   .dbline 583
 057C 62D000            mov REG[0xd0],>_TIMEOUT
 057F 3C0000            cmp [_TIMEOUT],0
 0582 B006              jnz X24
 0584 3C0100            cmp [_TIMEOUT+1],0
 0587 AFE0              jz L105
 0589           X24:
 0589                   .dbline 591
 0589           ;                       }
 0589                   .dbline 592
 0589           ;               }
 0589                   .dbline 593
 0589           ;       }
 0589 81BD              xjmp L89
 058B           L88:
 058B                   .dbline 594
 058B           ;       else if(STATE == RESPONSE_3)
 058B 62D000            mov REG[0xd0],>_STATE
 058E 3C0000            cmp [_STATE],0
 0591 B0AB              jnz L110
 0593 3C0105            cmp [_STATE+1],5
 0596 B0A6              jnz L110
 0598           X25:
 0598                   .dbline 595
 0598           ;       {
 0598                   .dbline 596
 0598           ;               if(tempByte = CHILD_3_cReadChar())
 0598 10                push X
 0599 7C0000            xcall _CHILD_3_cReadChar
 059C 62D000            mov REG[0xd0],>__r0
 059F 20                pop X
 05A0 5400              mov [X+0],A
 05A2 3900              cmp A,0
 05A4 A1A2              jz L111
 05A6                   .dbline 597
 05A6           ;               {
 05A6                   .dbline 598
 05A6           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 05A6 3D00FF            cmp [X+0],-1
 05A9 B069              jnz L114
 05AB                   .dbline 599
 05AB           ;                       {
 05AB 8058              xjmp L117
 05AD           L116:
 05AD                   .dbline 601
 05AD           ;                               while(!TIMEOUT)
 05AD           ;                               {
 05AD                   .dbline 603
 05AD           ;                                       // Check for the second start byte.
 05AD           ;                                       if(CHILD_3_cReadChar() == SERVO_START)
 05AD 10                push X
 05AE 7C0000            xcall _CHILD_3_cReadChar
 05B1 62D000            mov REG[0xd0],>__r0
 05B4 20                pop X
 05B5 39FF              cmp A,-1
 05B7 B04C              jnz L119
 05B9                   .dbline 604
 05B9           ;                                       {
 05B9                   .dbline 606
 05B9           ;                                               // Burn the ID, since we don't care what it is.
 05B9           ;                                               CHILD_3_cGetChar();
 05B9 10                push X
 05BA 7C0000            xcall _CHILD_3_cGetChar
 05BD 62D000            mov REG[0xd0],>__r0
 05C0 20                pop X
 05C1                   .dbline 609
 05C1           ;                                               
 05C1           ;                                               // We store the length, since it is the next byte from the servo.
 05C1           ;                                               tempByte = CHILD_3_cGetChar();
 05C1 10                push X
 05C2 7C0000            xcall _CHILD_3_cGetChar
 05C5 62D000            mov REG[0xd0],>__r0
 05C8 20                pop X
 05C9 5400              mov [X+0],A
 05CB                   .dbline 612
 05CB           ;                                               
 05CB           ;                                               // This basically waits for the rest of the command to pass through.
 05CB           ;                                               for(i = 0; i < tempByte; i++)
 05CB 560200            mov [X+2],0
 05CE 560100            mov [X+1],0
 05D1 800E              xjmp L124
 05D3           L121:
 05D3                   .dbline 613
 05D3           ;                                               {
 05D3                   .dbline 614
 05D3           ;                                                       CHILD_3_cGetChar();
 05D3 10                push X
 05D4 7C0000            xcall _CHILD_3_cGetChar
 05D7 62D000            mov REG[0xd0],>__r0
 05DA 20                pop X
 05DB                   .dbline 615
 05DB           ;                                               }
 05DB           L122:
 05DB                   .dbline 612
 05DB 7702              inc [X+2]
 05DD 0F0100            adc [X+1],0
 05E0           L124:
 05E0                   .dbline 612
 05E0 62D000            mov REG[0xd0],>__r0
 05E3 5200              mov A,[X+0]
 05E5 5300              mov [__r1],A
 05E7 5202              mov A,[X+2]
 05E9 1200              sub A,[__r1]
 05EB 5000              mov A,0
 05ED 3180              xor A,-128
 05EF 5300              mov [__rX],A
 05F1 5201              mov A,[X+1]
 05F3 3180              xor A,-128
 05F5 1A00              sbb A,[__rX]
 05F7 CFDB              jc L121
 05F9           X26:
 05F9                   .dbline 617
 05F9           ;                                               
 05F9           ;                                               return 1;
 05F9 62D000            mov REG[0xd0],>__r0
 05FC 550001            mov [__r1],1
 05FF 550000            mov [__r0],0
 0602 814D              xjmp L37
 0604           L119:
 0604                   .dbline 619
 0604           ;                                       }
 0604           ;                               }
 0604           L117:
 0604                   .dbline 600
 0604 62D000            mov REG[0xd0],>_TIMEOUT
 0607 3C0000            cmp [_TIMEOUT],0
 060A B006              jnz X27
 060C 3C0100            cmp [_TIMEOUT+1],0
 060F AF9D              jz L116
 0611           X27:
 0611                   .dbline 620
 0611           ;                       }
 0611 8135              xjmp L111
 0613           L114:
 0613                   .dbline 621
 0613           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0613 3D00FC            cmp [X+0],-4
 0616 B130              jnz L111
 0618                   .dbline 622
 0618           ;                       {
 0618 8015              xjmp L128
 061A           L127:
 061A                   .dbline 624
 061A           ;                               while(!TIMEOUT)
 061A           ;                               {
 061A                   .dbline 626
 061A           ;                                       // We simply wait for the end transmit indicator.
 061A           ;                                       if(CHILD_3_cReadChar() == END_TRANSMIT)
 061A 10                push X
 061B 7C0000            xcall _CHILD_3_cReadChar
 061E 62D000            mov REG[0xd0],>__r0
 0621 20                pop X
 0622 39FD              cmp A,-3
 0624 B009              jnz L130
 0626                   .dbline 627
 0626           ;                                       {
 0626                   .dbline 628
 0626           ;                                               return 1;
 0626 550001            mov [__r1],1
 0629 550000            mov [__r0],0
 062C 8123              xjmp L37
 062E           L130:
 062E                   .dbline 630
 062E           ;                                       }
 062E           ;                               }
 062E           L128:
 062E                   .dbline 623
 062E 62D000            mov REG[0xd0],>_TIMEOUT
 0631 3C0000            cmp [_TIMEOUT],0
 0634 B006              jnz X28
 0636 3C0100            cmp [_TIMEOUT+1],0
 0639 AFE0              jz L127
 063B           X28:
 063B                   .dbline 631
 063B           ;                       }
 063B                   .dbline 632
 063B           ;               }
 063B                   .dbline 633
 063B           ;       }
 063B 810B              xjmp L111
 063D           L110:
 063D                   .dbline 634
 063D           ;       else if(STATE == RESPONSE_4)
 063D 62D000            mov REG[0xd0],>_STATE
 0640 3C0000            cmp [_STATE],0
 0643 B0AB              jnz L132
 0645 3C0106            cmp [_STATE+1],6
 0648 B0A6              jnz L132
 064A           X29:
 064A                   .dbline 635
 064A           ;       {
 064A                   .dbline 636
 064A           ;               if(tempByte = CHILD_4_cReadChar())
 064A 10                push X
 064B 7C0000            xcall _CHILD_4_cReadChar
 064E 62D000            mov REG[0xd0],>__r0
 0651 20                pop X
 0652 5400              mov [X+0],A
 0654 3900              cmp A,0
 0656 A0F0              jz L133
 0658                   .dbline 637
 0658           ;               {
 0658                   .dbline 638
 0658           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0658 3D00FF            cmp [X+0],-1
 065B B069              jnz L136
 065D                   .dbline 639
 065D           ;                       {
 065D 8058              xjmp L139
 065F           L138:
 065F                   .dbline 641
 065F           ;                               while(!TIMEOUT)
 065F           ;                               {
 065F                   .dbline 643
 065F           ;                                       // Check for the second start byte.
 065F           ;                                       if(CHILD_4_cReadChar() == SERVO_START)
 065F 10                push X
 0660 7C0000            xcall _CHILD_4_cReadChar
 0663 62D000            mov REG[0xd0],>__r0
 0666 20                pop X
 0667 39FF              cmp A,-1
 0669 B04C              jnz L141
 066B                   .dbline 644
 066B           ;                                       {
 066B                   .dbline 646
 066B           ;                                               // Burn the ID, since we don't care what it is.
 066B           ;                                               CHILD_4_cGetChar();
 066B 10                push X
 066C 7C0000            xcall _CHILD_4_cGetChar
 066F 62D000            mov REG[0xd0],>__r0
 0672 20                pop X
 0673                   .dbline 649
 0673           ;                                               
 0673           ;                                               // We store the length, since it is the next byte from the servo.
 0673           ;                                               tempByte = CHILD_4_cGetChar();
 0673 10                push X
 0674 7C0000            xcall _CHILD_4_cGetChar
 0677 62D000            mov REG[0xd0],>__r0
 067A 20                pop X
 067B 5400              mov [X+0],A
 067D                   .dbline 652
 067D           ;                                               
 067D           ;                                               // This basically waits for the rest of the command to pass through.
 067D           ;                                               for(i = 0; i < tempByte; i++)
 067D 560200            mov [X+2],0
 0680 560100            mov [X+1],0
 0683 800E              xjmp L146
 0685           L143:
 0685                   .dbline 653
 0685           ;                                               {
 0685                   .dbline 654
 0685           ;                                                       CHILD_4_cGetChar();
 0685 10                push X
 0686 7C0000            xcall _CHILD_4_cGetChar
 0689 62D000            mov REG[0xd0],>__r0
 068C 20                pop X
 068D                   .dbline 655
 068D           ;                                               }
 068D           L144:
 068D                   .dbline 652
 068D 7702              inc [X+2]
 068F 0F0100            adc [X+1],0
 0692           L146:
 0692                   .dbline 652
 0692 62D000            mov REG[0xd0],>__r0
 0695 5200              mov A,[X+0]
 0697 5300              mov [__r1],A
 0699 5202              mov A,[X+2]
 069B 1200              sub A,[__r1]
 069D 5000              mov A,0
 069F 3180              xor A,-128
 06A1 5300              mov [__rX],A
 06A3 5201              mov A,[X+1]
 06A5 3180              xor A,-128
 06A7 1A00              sbb A,[__rX]
 06A9 CFDB              jc L143
 06AB           X30:
 06AB                   .dbline 657
 06AB           ;                                               
 06AB           ;                                               return 1;
 06AB 62D000            mov REG[0xd0],>__r0
 06AE 550001            mov [__r1],1
 06B1 550000            mov [__r0],0
 06B4 809B              xjmp L37
 06B6           L141:
 06B6                   .dbline 659
 06B6           ;                                       }
 06B6           ;                               }
 06B6           L139:
 06B6                   .dbline 640
 06B6 62D000            mov REG[0xd0],>_TIMEOUT
 06B9 3C0000            cmp [_TIMEOUT],0
 06BC B006              jnz X31
 06BE 3C0100            cmp [_TIMEOUT+1],0
 06C1 AF9D              jz L138
 06C3           X31:
 06C3                   .dbline 660
 06C3           ;                       }
 06C3 8083              xjmp L133
 06C5           L136:
 06C5                   .dbline 661
 06C5           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 06C5 3D00FC            cmp [X+0],-4
 06C8 B07E              jnz L133
 06CA                   .dbline 662
 06CA           ;                       {
 06CA 8015              xjmp L150
 06CC           L149:
 06CC                   .dbline 664
 06CC           ;                               while(!TIMEOUT)
 06CC           ;                               {
 06CC                   .dbline 666
 06CC           ;                                       // We simply wait for the end transmit indicator.
 06CC           ;                                       if(CHILD_4_cReadChar() == END_TRANSMIT)
 06CC 10                push X
 06CD 7C0000            xcall _CHILD_4_cReadChar
 06D0 62D000            mov REG[0xd0],>__r0
 06D3 20                pop X
 06D4 39FD              cmp A,-3
 06D6 B009              jnz L152
 06D8                   .dbline 667
 06D8           ;                                       {
 06D8                   .dbline 668
 06D8           ;                                               return 1;
 06D8 550001            mov [__r1],1
 06DB 550000            mov [__r0],0
 06DE 8071              xjmp L37
 06E0           L152:
 06E0                   .dbline 670
 06E0           ;                                       }
 06E0           ;                               }
 06E0           L150:
 06E0                   .dbline 663
 06E0 62D000            mov REG[0xd0],>_TIMEOUT
 06E3 3C0000            cmp [_TIMEOUT],0
 06E6 B006              jnz X32
 06E8 3C0100            cmp [_TIMEOUT+1],0
 06EB AFE0              jz L149
 06ED           X32:
 06ED                   .dbline 671
 06ED           ;                       }
 06ED                   .dbline 672
 06ED           ;               }
 06ED                   .dbline 673
 06ED           ;       }
 06ED 8059              xjmp L133
 06EF           L132:
 06EF                   .dbline 674
 06EF           ;       else if(STATE == INITIALIZE)
 06EF 62D000            mov REG[0xd0],>_STATE
 06F2 3C0000            cmp [_STATE],0
 06F5 B051              jnz L154
 06F7 3C0108            cmp [_STATE+1],8
 06FA B04C              jnz L154
 06FC           X33:
 06FC                   .dbline 675
 06FC           ;       {
 06FC                   .dbline 676
 06FC           ;               if(INIT_RX_cReadChar() == SERVO_START)
 06FC 10                push X
 06FD 7C0000            xcall _INIT_RX_cReadChar
 0700 62D000            mov REG[0xd0],>__r0
 0703 20                pop X
 0704 39FF              cmp A,-1
 0706 B040              jnz L156
 0708                   .dbline 677
 0708           ;               {
 0708                   .dbline 679
 0708           ;                       // We officially have a transmission.
 0708           ;                       if(INIT_RX_cGetChar() == SERVO_START)
 0708 10                push X
 0709 7C0000            xcall _INIT_RX_cGetChar
 070C 62D000            mov REG[0xd0],>__r0
 070F 20                pop X
 0710 39FF              cmp A,-1
 0712 B034              jnz L158
 0714                   .dbline 680
 0714           ;                       {
 0714                   .dbline 683
 0714           ;                               // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0714           ;                               // and store them in the proper variables for actions to be taken later.
 0714           ;                               COMMAND_SOURCE = INIT_RX_cGetChar();
 0714 10                push X
 0715 7C0000            xcall _INIT_RX_cGetChar
 0718 20                pop X
 0719 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 071C 5300              mov [_COMMAND_SOURCE],A
 071E                   .dbline 684
 071E           ;                               COMMAND_LENGTH = INIT_RX_cGetChar();
 071E 10                push X
 071F 7C0000            xcall _INIT_RX_cGetChar
 0722 20                pop X
 0723 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0726 5300              mov [_COMMAND_LENGTH],A
 0728                   .dbline 685
 0728           ;                               COMMAND_ERROR = INIT_RX_cGetChar();
 0728 10                push X
 0729 7C0000            xcall _INIT_RX_cGetChar
 072C 20                pop X
 072D 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0730 5300              mov [_COMMAND_ERROR],A
 0732                   .dbline 686
 0732           ;                               COMMAND_PARAM = INIT_RX_cGetChar();
 0732 10                push X
 0733 7C0000            xcall _INIT_RX_cGetChar
 0736 20                pop X
 0737 62D000            mov REG[0xd0],>_COMMAND_PARAM
 073A 5300              mov [_COMMAND_PARAM],A
 073C                   .dbline 688
 073C           ;                               
 073C           ;                               return 1;
 073C 62D000            mov REG[0xd0],>__r0
 073F 550001            mov [__r1],1
 0742 550000            mov [__r0],0
 0745 800A              xjmp L37
 0747           L158:
 0747                   .dbline 690
 0747           ;                       }
 0747           ;               }
 0747           L156:
 0747                   .dbline 691
 0747           ;       }
 0747           L154:
 0747           L133:
 0747           L111:
 0747           L89:
 0747           L67:
 0747           L57:
 0747           L39:
 0747                   .dbline 693
 0747           ;       
 0747           ;       return 0;
 0747 62D000            mov REG[0xd0],>__r0
 074A 550000            mov [__r1],0
 074D 550000            mov [__r0],0
 0750                   .dbline -2
 0750           L37:
 0750 38FD              add SP,-3
 0752 20                pop X
 0753                   .dbline 0 ; func end
 0753 7F                ret
 0754                   .dbsym l i 1 I
 0754                   .dbsym l tempByte 0 c
 0754                   .dbend
 0754                   .dbfunc e takeAction _takeAction fV
 0754           ;              j -> X+5
 0754           ;              i -> X+3
 0754           ;       tempByte -> X+2
 0754           ;              i -> X+0
 0754           _takeAction::
 0754                   .dbline -1
 0754 10                push X
 0755 4F                mov X,SP
 0756 3807              add SP,7
 0758                   .dbline 699
 0758           ; }
 0758           ; 
 0758           ; // This function interprets what has been read by the command ready function
 0758           ; // and performs the appropriate action.
 0758           ; void takeAction(void)
 0758           ; {
 0758                   .dbline 700
 0758           ;       int i = 0;                                                      // An index variable for looping.
 0758 560100            mov [X+1],0
 075B 560000            mov [X+0],0
 075E                   .dbline 701
 075E           ;       char tempByte = 0;                                      // Empty character for storing data temporarily.
 075E 560200            mov [X+2],0
 0761                   .dbline 703
 0761           ;       
 0761           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 0761 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0764 3C00C8            cmp [_COMMAND_TYPE],-56
 0767 B039              jnz L161
 0769                   .dbline 704
 0769           ;       {
 0769                   .dbline 705
 0769           ;               if(!CONFIGURED)
 0769 62D000            mov REG[0xd0],>_CONFIGURED
 076C 3C0000            cmp [_CONFIGURED],0
 076F B00A              jnz L163
 0771 3C0100            cmp [_CONFIGURED+1],0
 0774 B005              jnz L163
 0776           X34:
 0776                   .dbline 706
 0776           ;               {
 0776                   .dbline 708
 0776           ;                       // Announce this module's presence if not configured.
 0776           ;                       sayHello();
 0776 98D7              xcall _sayHello
 0778                   .dbline 709
 0778           ;               }
 0778 8241              xjmp L162
 077A           L163:
 077A                   .dbline 710
 077A           ;               else if(!CHILD)
 077A 62D000            mov REG[0xd0],>_CHILD
 077D 3C0000            cmp [_CHILD],0
 0780 B014              jnz L165
 0782                   .dbline 711
 0782           ;               {
 0782                   .dbline 713
 0782           ;                       // Listen for children if we have none.
 0782           ;                       if(childListen())
 0782 94BC              xcall _childListen
 0784 62D000            mov REG[0xd0],>__r0
 0787 3C0000            cmp [__r0],0
 078A B006              jnz X35
 078C 3C0000            cmp [__r1],0
 078F A22A              jz L162
 0791           X35:
 0791                   .dbline 714
 0791           ;                       {
 0791                   .dbline 716
 0791           ;                               // If a child was heard saying hello, forward the command with the port number added.
 0791           ;                               sayHello();
 0791 98BC              xcall _sayHello
 0793                   .dbline 717
 0793           ;                       }
 0793                   .dbline 718
 0793           ;               }
 0793 8226              xjmp L162
 0795           L165:
 0795                   .dbline 719
 0795           ;               else if(CHILD)
 0795 62D000            mov REG[0xd0],>_CHILD
 0798 3C0000            cmp [_CHILD],0
 079B A21E              jz L162
 079D                   .dbline 720
 079D           ;               {
 079D                   .dbline 722
 079D           ;                       // If you have a child established, listen to that child.
 079D           ;                       childResponse();
 079D 94F9              xcall _childResponse
 079F                   .dbline 723
 079F           ;               }
 079F                   .dbline 724
 079F           ;       }
 079F 821A              xjmp L162
 07A1           L161:
 07A1                   .dbline 725
 07A1           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 07A1 62D000            mov REG[0xd0],>_COMMAND_TYPE
 07A4 3C00CB            cmp [_COMMAND_TYPE],-53
 07A7 B021              jnz L171
 07A9                   .dbline 726
 07A9           ;       {
 07A9                   .dbline 728
 07A9           ;               // If this is to me, act accordingly.
 07A9           ;               if(COMMAND_DESTINATION == ID)
 07A9 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 07AC 5100              mov A,[_COMMAND_DESTINATION]
 07AE 62D000            mov REG[0xd0],>_ID
 07B1 3A00              cmp A,[_ID]
 07B3 B005              jnz L173
 07B5                   .dbline 729
 07B5           ;               {
 07B5                   .dbline 731
 07B5           ;                       // Ping back to the master.
 07B5           ;                       pingResponse();
 07B5 92A6              xcall _pingResponse
 07B7                   .dbline 732
 07B7           ;               }
 07B7 8202              xjmp L172
 07B9           L173:
 07B9                   .dbline 733
 07B9           ;               else if(COMMAND_DESTINATION > ID)
 07B9 62D000            mov REG[0xd0],>_ID
 07BC 5100              mov A,[_ID]
 07BE 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 07C1 3A00              cmp A,[_COMMAND_DESTINATION]
 07C3 D1F6              jnc L172
 07C5           X36:
 07C5                   .dbline 734
 07C5           ;               {
 07C5                   .dbline 736
 07C5           ;                       // If you have a child established, listen to that child.
 07C5           ;                       childResponse();
 07C5 94D1              xcall _childResponse
 07C7                   .dbline 737
 07C7           ;               }
 07C7                   .dbline 738
 07C7           ;       }
 07C7 81F2              xjmp L172
 07C9           L171:
 07C9                   .dbline 739
 07C9           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 07C9 62D000            mov REG[0xd0],>_COMMAND_TYPE
 07CC 3C00C9            cmp [_COMMAND_TYPE],-55
 07CF B111              jnz L177
 07D1                   .dbline 740
 07D1           ;       {
 07D1                   .dbline 742
 07D1           ;               // If this is meant for me, change my ID.
 07D1           ;               if(COMMAND_DESTINATION == ID)
 07D1 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 07D4 5100              mov A,[_COMMAND_DESTINATION]
 07D6 62D000            mov REG[0xd0],>_ID
 07D9 3A00              cmp A,[_ID]
 07DB B0F5              jnz L179
 07DD                   .dbline 743
 07DD           ;               {
 07DD                   .dbline 744
 07DD           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 07DD 62D000            mov REG[0xd0],>_COMMAND_PARAM
 07E0 5000              mov A,0
 07E2 3A00              cmp A,[_COMMAND_PARAM]
 07E4 D1D5              jnc L178
 07E6           X37:
 07E6 62D000            mov REG[0xd0],>_COMMAND_PARAM
 07E9 3C00FB            cmp [_COMMAND_PARAM],-5
 07EC D1CD              jnc L178
 07EE           X38:
 07EE                   .dbline 745
 07EE           ;                       {
 07EE                   .dbline 747
 07EE           ;                               // Assign this module the ID that has been passed by the master.
 07EE           ;                               ID = COMMAND_PARAM;
 07EE 62D000            mov REG[0xd0],>_COMMAND_PARAM
 07F1 5100              mov A,[_COMMAND_PARAM]
 07F3 62D000            mov REG[0xd0],>_ID
 07F6 5300              mov [_ID],A
 07F8                   .dbline 750
 07F8           ;                               
 07F8           ;                               // This module is now configured.
 07F8           ;                               CONFIGURED = 1;
 07F8 62D000            mov REG[0xd0],>_CONFIGURED
 07FB 550101            mov [_CONFIGURED+1],1
 07FE 550000            mov [_CONFIGURED],0
 0801                   .dbline 753
 0801           ;                               
 0801           ;                               // If the servo ID doesn't match what we want, change it to match.
 0801           ;                               if(ID != SERVO_ID)
 0801 62D000            mov REG[0xd0],>_ID
 0804 5100              mov A,[_ID]
 0806 62D000            mov REG[0xd0],>_SERVO_ID
 0809 3A00              cmp A,[_SERVO_ID]
 080B A0A8              jz L183
 080D                   .dbline 754
 080D           ;                               {
 080D                   .dbline 761
 080D           ;                                       // These are our index variables for communication attempt timeouts.
 080D           ;                                       int i;
 080D           ;                                       int j;
 080D           ;                                       
 080D           ;                                       //while(ID != SERVO_ID)
 080D           ;                                       
 080D           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 080D 560600            mov [X+6],0
 0810 560500            mov [X+5],0
 0813           L185:
 0813                   .dbline 762
 0813           ;                                       {       
 0813                   .dbline 764
 0813           ;                                               // Send a request to change the servo ID to match the controller ID.
 0813           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 0813 62D000            mov REG[0xd0],>_ID
 0816 5100              mov A,[_ID]
 0818 08                push A
 0819 5003              mov A,3
 081B 08                push A
 081C 08                push A
 081D 5004              mov A,4
 081F 08                push A
 0820 62D000            mov REG[0xd0],>_SERVO_ID
 0823 5100              mov A,[_SERVO_ID]
 0825 08                push A
 0826 9726              xcall _servoInstruction
 0828 38FB              add SP,-5
 082A                   .dbline 767
 082A           ;                                       
 082A           ;                                               // Try to read the servo's ID several times.
 082A           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 082A 560400            mov [X+4],0
 082D 560300            mov [X+3],0
 0830           L189:
 0830                   .dbline 768
 0830           ;                                               {
 0830                   .dbline 770
 0830           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0830           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0830 5000              mov A,0
 0832 08                push A
 0833 08                push A
 0834 5001              mov A,1
 0836 08                push A
 0837 5002              mov A,2
 0839 08                push A
 083A 50FE              mov A,-2
 083C 08                push A
 083D 970F              xcall _servoInstruction
 083F 38FB              add SP,-5
 0841 8043              xjmp L194
 0843           L193:
 0843                   .dbline 774
 0843           ;                                                       
 0843           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 0843           ;                                                       while(!TIMEOUT)
 0843           ;                                                       {
 0843                   .dbline 776
 0843           ;                                                               // If we have a command to interpret, read it.
 0843           ;                                                               if(commandReady())
 0843 9A85              xcall _commandReady
 0845 62D000            mov REG[0xd0],>__r0
 0848 3C0000            cmp [__r0],0
 084B B006              jnz X39
 084D 3C0000            cmp [__r1],0
 0850 A034              jz L196
 0852           X39:
 0852                   .dbline 777
 0852           ;                                                               {
 0852                   .dbline 778
 0852           ;                                                                       if(!COMMAND_ERROR)
 0852 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0855 3C0000            cmp [_COMMAND_ERROR],0
 0858 B02C              jnz L198
 085A                   .dbline 779
 085A           ;                                                                       {
 085A                   .dbline 781
 085A           ;                                                                               // If we have a valid servo ID, exit the loop.
 085A           ;                                                                               if(COMMAND_SOURCE == ID)
 085A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 085D 5100              mov A,[_COMMAND_SOURCE]
 085F 62D000            mov REG[0xd0],>_ID
 0862 3A00              cmp A,[_ID]
 0864 B020              jnz L200
 0866                   .dbline 782
 0866           ;                                                                               {
 0866                   .dbline 784
 0866           ;                                                                                       // Set the timeout flag to exit the while loop.
 0866           ;                                                                                       TIMEOUT = 1;
 0866 62D000            mov REG[0xd0],>_TIMEOUT
 0869 550101            mov [_TIMEOUT+1],1
 086C 550000            mov [_TIMEOUT],0
 086F                   .dbline 786
 086F           ;                                                                                       // Set i such that the for loop is exited.
 086F           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 086F 56040A            mov [X+4],10
 0872 560300            mov [X+3],0
 0875                   .dbline 788
 0875           ;                                                                                       // Set j such that we exit the outer loop as well.
 0875           ;                                                                                       j = SERVO_COMM_LOOPS;
 0875 560602            mov [X+6],2
 0878 560500            mov [X+5],0
 087B                   .dbline 790
 087B           ;                                                                                       // Store the ID value.
 087B           ;                                                                                       SERVO_ID = ID;
 087B 62D000            mov REG[0xd0],>_ID
 087E 5100              mov A,[_ID]
 0880 62D000            mov REG[0xd0],>_SERVO_ID
 0883 5300              mov [_SERVO_ID],A
 0885                   .dbline 791
 0885           ;                                                                               }
 0885           L200:
 0885                   .dbline 792
 0885           ;                                                                       }
 0885           L198:
 0885                   .dbline 793
 0885           ;                                                               }
 0885           L196:
 0885                   .dbline 794
 0885           ;                                                       }
 0885           L194:
 0885                   .dbline 773
 0885 62D000            mov REG[0xd0],>_TIMEOUT
 0888 3C0000            cmp [_TIMEOUT],0
 088B B006              jnz X40
 088D 3C0100            cmp [_TIMEOUT+1],0
 0890 AFB2              jz L193
 0892           X40:
 0892                   .dbline 795
 0892           ;                                               }
 0892           L190:
 0892                   .dbline 767
 0892 7704              inc [X+4]
 0894 0F0300            adc [X+3],0
 0897                   .dbline 767
 0897 5204              mov A,[X+4]
 0899 110A              sub A,10
 089B 5203              mov A,[X+3]
 089D 3180              xor A,-128
 089F 1980              sbb A,(0 ^ 0x80)
 08A1 CF8E              jc L189
 08A3           X41:
 08A3                   .dbline 796
 08A3           ;                                       }       
 08A3           L186:
 08A3                   .dbline 761
 08A3 7706              inc [X+6]
 08A5 0F0500            adc [X+5],0
 08A8                   .dbline 761
 08A8 5206              mov A,[X+6]
 08AA 1102              sub A,2
 08AC 5205              mov A,[X+5]
 08AE 3180              xor A,-128
 08B0 1980              sbb A,(0 ^ 0x80)
 08B2 CF60              jc L185
 08B4           X42:
 08B4                   .dbline 797
 08B4           ;                               }
 08B4           L183:
 08B4                   .dbline 799
 08B4           ;                               
 08B4           ;                               if(ID != SERVO_ID)
 08B4 62D000            mov REG[0xd0],>_ID
 08B7 5100              mov A,[_ID]
 08B9 62D000            mov REG[0xd0],>_SERVO_ID
 08BC 3A00              cmp A,[_SERVO_ID]
 08BE A00E              jz L202
 08C0                   .dbline 800
 08C0           ;                               {
 08C0                   .dbline 802
 08C0           ;                                       // Toggle back to normal wait mode.
 08C0           ;                                       configToggle(WAIT);
 08C0 5000              mov A,0
 08C2 08                push A
 08C3 5001              mov A,1
 08C5 08                push A
 08C6 7C00B4            xcall _configToggle
 08C9 38FE              add SP,-2
 08CB                   .dbline 803
 08CB           ;                               }
 08CB 80EE              xjmp L178
 08CD           L202:
 08CD                   .dbline 805
 08CD           ;                               else
 08CD           ;                               {
 08CD                   .dbline 807
 08CD           ;                                       // Let the master node know that you got the ID assignment.
 08CD           ;                                       assignedID();
 08CD 92D2              xcall _assignedID
 08CF                   .dbline 808
 08CF           ;                               }
 08CF                   .dbline 809
 08CF           ;                       }
 08CF                   .dbline 810
 08CF           ;               }
 08CF 80EA              xjmp L178
 08D1           L179:
 08D1                   .dbline 811
 08D1           ;               else if(COMMAND_DESTINATION > ID)
 08D1 62D000            mov REG[0xd0],>_ID
 08D4 5100              mov A,[_ID]
 08D6 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08D9 3A00              cmp A,[_COMMAND_DESTINATION]
 08DB D0DE              jnc L178
 08DD           X43:
 08DD                   .dbline 812
 08DD           ;               {
 08DD                   .dbline 814
 08DD           ;                       // Switch to listen to your child.
 08DD           ;                       childResponse();
 08DD 93B9              xcall _childResponse
 08DF                   .dbline 815
 08DF           ;               }
 08DF                   .dbline 816
 08DF           ;       }
 08DF 80DA              xjmp L178
 08E1           L177:
 08E1                   .dbline 817
 08E1           ;       else if(COMMAND_TYPE == CLEAR_CONFIG)   // The master wants to clear one or all configurations.
 08E1 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08E4 3C00CC            cmp [_COMMAND_TYPE],-52
 08E7 B03D              jnz L206
 08E9                   .dbline 818
 08E9           ;       {
 08E9                   .dbline 820
 08E9           ;               // Only respond if this is directly to me and not a mass config clear.
 08E9           ;               if(COMMAND_DESTINATION == ID)
 08E9 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08EC 5100              mov A,[_COMMAND_DESTINATION]
 08EE 62D000            mov REG[0xd0],>_ID
 08F1 3A00              cmp A,[_ID]
 08F3 B003              jnz L208
 08F5                   .dbline 821
 08F5           ;               {
 08F5                   .dbline 822
 08F5           ;                       configCleared();        // Notify the master that I am clearing my config.
 08F5 90C7              xcall _configCleared
 08F7                   .dbline 823
 08F7           ;               }
 08F7           L208:
 08F7                   .dbline 828
 08F7           ;               
 08F7           ;               // If this is meant for me, deconfigure.  Also, if a module ahead of you is
 08F7           ;               // getting deconfigured, you have no choice but to deconfigure as well to
 08F7           ;               // avoid errors on reconfiguration.
 08F7           ;               if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
 08F7 62D000            mov REG[0xd0],>_ID
 08FA 5100              mov A,[_ID]
 08FC 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08FF 3A00              cmp A,[_COMMAND_DESTINATION]
 0901 D009              jnc L212
 0903           X44:
 0903 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0906 3C00FE            cmp [_COMMAND_DESTINATION],-2
 0909 B016              jnz L210
 090B           L212:
 090B                   .dbline 829
 090B           ;               {
 090B                   .dbline 830
 090B           ;                       ID = DEFAULT_ID;        // Reset my ID to the default.
 090B 62D000            mov REG[0xd0],>_ID
 090E 5500FB            mov [_ID],-5
 0911                   .dbline 831
 0911           ;                       CONFIGURED = 0;         // I am no longer configured.
 0911 62D000            mov REG[0xd0],>_CONFIGURED
 0914 550100            mov [_CONFIGURED+1],0
 0917 550000            mov [_CONFIGURED],0
 091A                   .dbline 832
 091A           ;                       CHILD = 0;                      // No one can depend on you anymore.
 091A 62D000            mov REG[0xd0],>_CHILD
 091D 550000            mov [_CHILD],0
 0920                   .dbline 833
 0920           ;               }
 0920           L210:
 0920                   .dbline 844
 0920           ; //            else if(COMMAND_DESTINATION > ID)
 0920           ; //            {
 0920           ; //                    // Switch to listen to your child.
 0920           ; //                    childResponse();
 0920           ; //                    // Switch back to wait for a master response.
 0920           ; //                    configToggle(WAIT);
 0920           ; //            }
 0920           ; //            Going to also have to take into account of this is my child.
 0920           ;               
 0920           ;               // Turn off the LED.
 0920           ;               PRT2DR |= 0b00000001;
 0920 430801            or REG[0x8],1
 0923                   .dbline 845
 0923           ;       }
 0923 8096              xjmp L207
 0925           L206:
 0925                   .dbline 846
 0925           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 0925 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0928 3C0001            cmp [_COMMAND_TYPE],1
 092B A006              jz L215
 092D 3C0002            cmp [_COMMAND_TYPE],2
 0930 B089              jnz L213
 0932           L215:
 0932                   .dbline 847
 0932           ;       {
 0932                   .dbline 848
 0932           ;               if(COMMAND_DESTINATION > ID)
 0932 62D000            mov REG[0xd0],>_ID
 0935 5100              mov A,[_ID]
 0937 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 093A 3A00              cmp A,[_COMMAND_DESTINATION]
 093C D005              jnc L216
 093E           X45:
 093E                   .dbline 849
 093E           ;               {
 093E                   .dbline 851
 093E           ;                       // Allow the child response through.
 093E           ;                       childResponse();
 093E 9358              xcall _childResponse
 0940                   .dbline 852
 0940           ;               }
 0940 8079              xjmp L217
 0942           L216:
 0942                   .dbline 853
 0942           ;               else if(COMMAND_DESTINATION <= ID)
 0942 62D000            mov REG[0xd0],>_ID
 0945 5100              mov A,[_ID]
 0947 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 094A 3A00              cmp A,[_COMMAND_DESTINATION]
 094C C06D              jc L218
 094E           X46:
 094E                   .dbline 854
 094E           ;               {
 094E                   .dbline 855
 094E           ;                       WAIT_RECV_TIMEOUT_Start();              // Start the timer.
 094E 10                push X
 094F 7C0000            xcall _WAIT_RECV_TIMEOUT_Start
 0952 20                pop X
 0953 8059              xjmp L221
 0955           L220:
 0955                   .dbline 858
 0955           ;                       
 0955           ;                       while(!TIMEOUT)
 0955           ;                       {
 0955                   .dbline 860
 0955           ;                               // Sit and spin while we wait for the transmission to start.
 0955           ;                               if(WAIT_RECV_cReadChar() == SERVO_START)
 0955 10                push X
 0956 7C0000            xcall _WAIT_RECV_cReadChar
 0959 62D000            mov REG[0xd0],>__r0
 095C 20                pop X
 095D 39FF              cmp A,-1
 095F B04D              jnz L223
 0961                   .dbline 861
 0961           ;                               {
 0961                   .dbline 863
 0961           ;                                       // Find the second servo start byte.
 0961           ;                                       if(WAIT_RECV_cGetChar() == SERVO_START)
 0961 10                push X
 0962 7C0000            xcall _WAIT_RECV_cGetChar
 0965 62D000            mov REG[0xd0],>__r0
 0968 20                pop X
 0969 39FF              cmp A,-1
 096B B041              jnz L225
 096D                   .dbline 864
 096D           ;                                       {
 096D                   .dbline 866
 096D           ;                                               // Burn the ID.
 096D           ;                                               WAIT_RECV_cGetChar();
 096D 10                push X
 096E 7C0000            xcall _WAIT_RECV_cGetChar
 0971 62D000            mov REG[0xd0],>__r0
 0974 20                pop X
 0975                   .dbline 869
 0975           ;                                               
 0975           ;                                               // The second parameter after the servo start is the remaining command length.
 0975           ;                                               tempByte = WAIT_RECV_cGetChar();
 0975 10                push X
 0976 7C0000            xcall _WAIT_RECV_cGetChar
 0979 62D000            mov REG[0xd0],>__r0
 097C 20                pop X
 097D 5402              mov [X+2],A
 097F                   .dbline 872
 097F           ;                                               
 097F           ;                                               // This basically waits for the rest of the command to pass through.
 097F           ;                                               for(i = 0; i < tempByte; i++)
 097F 560100            mov [X+1],0
 0982 560000            mov [X+0],0
 0985 800E              xjmp L230
 0987           L227:
 0987                   .dbline 873
 0987           ;                                               {
 0987                   .dbline 874
 0987           ;                                                       WAIT_RECV_cGetChar();
 0987 10                push X
 0988 7C0000            xcall _WAIT_RECV_cGetChar
 098B 62D000            mov REG[0xd0],>__r0
 098E 20                pop X
 098F                   .dbline 875
 098F           ;                                               }
 098F           L228:
 098F                   .dbline 872
 098F 7701              inc [X+1]
 0991 0F0000            adc [X+0],0
 0994           L230:
 0994                   .dbline 872
 0994 62D000            mov REG[0xd0],>__r0
 0997 5202              mov A,[X+2]
 0999 5300              mov [__r1],A
 099B 5201              mov A,[X+1]
 099D 1200              sub A,[__r1]
 099F 5000              mov A,0
 09A1 3180              xor A,-128
 09A3 5300              mov [__rX],A
 09A5 5200              mov A,[X+0]
 09A7 3180              xor A,-128
 09A9 1A00              sbb A,[__rX]
 09AB CFDB              jc L227
 09AD           X47:
 09AD                   .dbline 876
 09AD           ;                                       }
 09AD           L225:
 09AD                   .dbline 877
 09AD           ;                               }
 09AD           L223:
 09AD                   .dbline 878
 09AD           ;                       }
 09AD           L221:
 09AD                   .dbline 857
 09AD 62D000            mov REG[0xd0],>_TIMEOUT
 09B0 3C0000            cmp [_TIMEOUT],0
 09B3 B006              jnz X48
 09B5 3C0100            cmp [_TIMEOUT+1],0
 09B8 AF9C              jz L220
 09BA           X48:
 09BA                   .dbline 879
 09BA           ;               }
 09BA           L218:
 09BA           L217:
 09BA                   .dbline 880
 09BA           ;       }
 09BA           L213:
 09BA           L207:
 09BA           L178:
 09BA           L172:
 09BA           L162:
 09BA                   .dbline -2
 09BA           L160:
 09BA 38F9              add SP,-7
 09BC 20                pop X
 09BD                   .dbline 0 ; func end
 09BD 7F                ret
 09BE                   .dbsym l j 5 I
 09BE                   .dbsym l i 3 I
 09BE                   .dbsym l tempByte 2 c
 09BE                   .dbsym l i 0 I
 09BE                   .dbend
 09BE                   .dbfunc e configCleared _configCleared fV
 09BE           _configCleared::
 09BE                   .dbline -1
 09BE                   .dbline 885
 09BE           ; }
 09BE           ; 
 09BE           ; // This function sends out an acknowledgement of a configuration reset.
 09BE           ; void configCleared(void)
 09BE           ; {
 09BE                   .dbline 886
 09BE           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 09BE 5000              mov A,0
 09C0 08                push A
 09C1 5002              mov A,2
 09C3 08                push A
 09C4 7C00B4            xcall _configToggle
 09C7 38FE              add SP,-2
 09C9                   .dbline 889
 09C9           ;       
 09C9           ;       // Transmit a ping to everyone.
 09C9           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 09C9 10                push X
 09CA 50FC              mov A,-4
 09CC 7C0000            xcall _TX_014_PutChar
 09CF 20                pop X
 09D0                   .dbline 890
 09D0           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 09D0 10                push X
 09D1 50FC              mov A,-4
 09D3 7C0000            xcall _TX_23_PutChar
 09D6 20                pop X
 09D7                   .dbline 891
 09D7           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 09D7 10                push X
 09D8 50FC              mov A,-4
 09DA 7C0000            xcall _TX_014_PutChar
 09DD 20                pop X
 09DE                   .dbline 892
 09DE           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 09DE 10                push X
 09DF 50FC              mov A,-4
 09E1 7C0000            xcall _TX_23_PutChar
 09E4 20                pop X
 09E5                   .dbline 893
 09E5           ;       TX_014_PutChar(ID);                             // My ID
 09E5 10                push X
 09E6 62D000            mov REG[0xd0],>_ID
 09E9 5100              mov A,[_ID]
 09EB 7C0000            xcall _TX_014_PutChar
 09EE 20                pop X
 09EF                   .dbline 894
 09EF           ;       TX_23_PutChar(ID);                              // My ID
 09EF 10                push X
 09F0 62D000            mov REG[0xd0],>_ID
 09F3 5100              mov A,[_ID]
 09F5 7C0000            xcall _TX_23_PutChar
 09F8 20                pop X
 09F9                   .dbline 895
 09F9           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09F9 10                push X
 09FA 5000              mov A,0
 09FC 7C0000            xcall _TX_014_PutChar
 09FF 20                pop X
 0A00                   .dbline 896
 0A00           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0A00 10                push X
 0A01 5000              mov A,0
 0A03 7C0000            xcall _TX_23_PutChar
 0A06 20                pop X
 0A07                   .dbline 897
 0A07           ;       TX_014_PutChar(CONFIG_CLEARED); // This is a ping response
 0A07 10                push X
 0A08 50CD              mov A,-51
 0A0A 7C0000            xcall _TX_014_PutChar
 0A0D 20                pop X
 0A0E                   .dbline 898
 0A0E           ;       TX_23_PutChar(CONFIG_CLEARED);  // This is a ping response
 0A0E 10                push X
 0A0F 50CD              mov A,-51
 0A11 7C0000            xcall _TX_23_PutChar
 0A14 20                pop X
 0A15                   .dbline 899
 0A15           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A15 10                push X
 0A16 50FD              mov A,-3
 0A18 7C0000            xcall _TX_014_PutChar
 0A1B 20                pop X
 0A1C                   .dbline 900
 0A1C           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A1C 10                push X
 0A1D 50FD              mov A,-3
 0A1F 7C0000            xcall _TX_23_PutChar
 0A22 20                pop X
 0A23                   .dbline 901
 0A23           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A23 10                push X
 0A24 50FD              mov A,-3
 0A26 7C0000            xcall _TX_014_PutChar
 0A29 20                pop X
 0A2A                   .dbline 902
 0A2A           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A2A 10                push X
 0A2B 50FD              mov A,-3
 0A2D 7C0000            xcall _TX_23_PutChar
 0A30 20                pop X
 0A31           L232:
 0A31                   .dbline 905
 0A31           ;       
 0A31           ;       // Wait for the transmission to finish.
 0A31           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0A31           L233:
 0A31                   .dbline 905
 0A31 10                push X
 0A32 7C0000            xcall _TX_014_bReadTxStatus
 0A35 62D000            mov REG[0xd0],>__r0
 0A38 20                pop X
 0A39 5300              mov [__r0],A
 0A3B 470020            tst [__r0],32
 0A3E AFF2              jz L232
 0A40           L235:
 0A40                   .dbline 906
 0A40           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0A40           L236:
 0A40                   .dbline 906
 0A40 10                push X
 0A41 7C0000            xcall _TX_23_bReadTxStatus
 0A44 62D000            mov REG[0xd0],>__r0
 0A47 20                pop X
 0A48 5300              mov [__r0],A
 0A4A 470020            tst [__r0],32
 0A4D AFF2              jz L235
 0A4F                   .dbline 909
 0A4F           ;       
 0A4F           ;       // Make completely sure we're done.
 0A4F           ;       xmitWait();
 0A4F 95DB              xcall _xmitWait
 0A51                   .dbline 911
 0A51           ;       
 0A51           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A51 5000              mov A,0
 0A53 08                push A
 0A54 5001              mov A,1
 0A56 08                push A
 0A57 7C00B4            xcall _configToggle
 0A5A 38FE              add SP,-2
 0A5C                   .dbline -2
 0A5C           L231:
 0A5C                   .dbline 0 ; func end
 0A5C 7F                ret
 0A5D                   .dbend
 0A5D                   .dbfunc e pingResponse _pingResponse fV
 0A5D           _pingResponse::
 0A5D                   .dbline -1
 0A5D                   .dbline 916
 0A5D           ; }
 0A5D           ; 
 0A5D           ; // This function sends out a ping response for everyone to hear.
 0A5D           ; void pingResponse(void)
 0A5D           ; {
 0A5D                   .dbline 917
 0A5D           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0A5D 5000              mov A,0
 0A5F 08                push A
 0A60 5002              mov A,2
 0A62 08                push A
 0A63 7C00B4            xcall _configToggle
 0A66 38FE              add SP,-2
 0A68                   .dbline 920
 0A68           ;       
 0A68           ;       // Transmit a ping to everyone.
 0A68           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0A68 10                push X
 0A69 50FC              mov A,-4
 0A6B 7C0000            xcall _TX_014_PutChar
 0A6E 20                pop X
 0A6F                   .dbline 921
 0A6F           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0A6F 10                push X
 0A70 50FC              mov A,-4
 0A72 7C0000            xcall _TX_23_PutChar
 0A75 20                pop X
 0A76                   .dbline 922
 0A76           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0A76 10                push X
 0A77 50FC              mov A,-4
 0A79 7C0000            xcall _TX_014_PutChar
 0A7C 20                pop X
 0A7D                   .dbline 923
 0A7D           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0A7D 10                push X
 0A7E 50FC              mov A,-4
 0A80 7C0000            xcall _TX_23_PutChar
 0A83 20                pop X
 0A84                   .dbline 924
 0A84           ;       TX_014_PutChar(ID);                             // My ID
 0A84 10                push X
 0A85 62D000            mov REG[0xd0],>_ID
 0A88 5100              mov A,[_ID]
 0A8A 7C0000            xcall _TX_014_PutChar
 0A8D 20                pop X
 0A8E                   .dbline 925
 0A8E           ;       TX_23_PutChar(ID);                              // My ID
 0A8E 10                push X
 0A8F 62D000            mov REG[0xd0],>_ID
 0A92 5100              mov A,[_ID]
 0A94 7C0000            xcall _TX_23_PutChar
 0A97 20                pop X
 0A98                   .dbline 926
 0A98           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0A98 10                push X
 0A99 5000              mov A,0
 0A9B 7C0000            xcall _TX_014_PutChar
 0A9E 20                pop X
 0A9F                   .dbline 927
 0A9F           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0A9F 10                push X
 0AA0 5000              mov A,0
 0AA2 7C0000            xcall _TX_23_PutChar
 0AA5 20                pop X
 0AA6                   .dbline 928
 0AA6           ;       TX_014_PutChar(PING);                   // This is a ping response
 0AA6 10                push X
 0AA7 50CB              mov A,-53
 0AA9 7C0000            xcall _TX_014_PutChar
 0AAC 20                pop X
 0AAD                   .dbline 929
 0AAD           ;       TX_23_PutChar(PING);                    // This is a ping response
 0AAD 10                push X
 0AAE 50CB              mov A,-53
 0AB0 7C0000            xcall _TX_23_PutChar
 0AB3 20                pop X
 0AB4                   .dbline 930
 0AB4           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0AB4 10                push X
 0AB5 50FD              mov A,-3
 0AB7 7C0000            xcall _TX_014_PutChar
 0ABA 20                pop X
 0ABB                   .dbline 931
 0ABB           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0ABB 10                push X
 0ABC 50FD              mov A,-3
 0ABE 7C0000            xcall _TX_23_PutChar
 0AC1 20                pop X
 0AC2                   .dbline 932
 0AC2           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0AC2 10                push X
 0AC3 50FD              mov A,-3
 0AC5 7C0000            xcall _TX_014_PutChar
 0AC8 20                pop X
 0AC9                   .dbline 933
 0AC9           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0AC9 10                push X
 0ACA 50FD              mov A,-3
 0ACC 7C0000            xcall _TX_23_PutChar
 0ACF 20                pop X
 0AD0           L239:
 0AD0                   .dbline 936
 0AD0           ;       
 0AD0           ;       // Wait for the transmission to finish.
 0AD0           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0AD0           L240:
 0AD0                   .dbline 936
 0AD0 10                push X
 0AD1 7C0000            xcall _TX_014_bReadTxStatus
 0AD4 62D000            mov REG[0xd0],>__r0
 0AD7 20                pop X
 0AD8 5300              mov [__r0],A
 0ADA 470020            tst [__r0],32
 0ADD AFF2              jz L239
 0ADF           L242:
 0ADF                   .dbline 937
 0ADF           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0ADF           L243:
 0ADF                   .dbline 937
 0ADF 10                push X
 0AE0 7C0000            xcall _TX_23_bReadTxStatus
 0AE3 62D000            mov REG[0xd0],>__r0
 0AE6 20                pop X
 0AE7 5300              mov [__r0],A
 0AE9 470020            tst [__r0],32
 0AEC AFF2              jz L242
 0AEE                   .dbline 940
 0AEE           ;       
 0AEE           ;       // Make completely sure we're done.
 0AEE           ;       xmitWait();
 0AEE 953C              xcall _xmitWait
 0AF0                   .dbline 942
 0AF0           ;       
 0AF0           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0AF0 5000              mov A,0
 0AF2 08                push A
 0AF3 5001              mov A,1
 0AF5 08                push A
 0AF6 7C00B4            xcall _configToggle
 0AF9 38FE              add SP,-2
 0AFB                   .dbline -2
 0AFB           L238:
 0AFB                   .dbline 0 ; func end
 0AFB 7F                ret
 0AFC                   .dbend
 0AFC                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0AFC           _unloadAllConfigs::
 0AFC                   .dbline -1
 0AFC                   .dbline 948
 0AFC           ; }
 0AFC           ; 
 0AFC           ; // This function blindly unloads all user configurations. This will be called once,
 0AFC           ; // when the system initially has no known state.
 0AFC           ; void unloadAllConfigs(void)
 0AFC           ; {
 0AFC                   .dbline 949
 0AFC           ;       UnloadConfig_waiting();
 0AFC 7C0000            xcall _UnloadConfig_waiting
 0AFF                   .dbline 950
 0AFF           ;       UnloadConfig_hello();
 0AFF 7C0000            xcall _UnloadConfig_hello
 0B02                   .dbline 951
 0B02           ;       UnloadConfig_my_response();
 0B02 7C0000            xcall _UnloadConfig_my_response
 0B05                   .dbline 952
 0B05           ;       UnloadConfig_response1();
 0B05 7C0000            xcall _UnloadConfig_response1
 0B08                   .dbline 953
 0B08           ;       UnloadConfig_response2();
 0B08 7C0000            xcall _UnloadConfig_response2
 0B0B                   .dbline 954
 0B0B           ;       UnloadConfig_response3();
 0B0B 7C0000            xcall _UnloadConfig_response3
 0B0E                   .dbline 955
 0B0E           ;       UnloadConfig_response4();
 0B0E 7C0000            xcall _UnloadConfig_response4
 0B11                   .dbline 956
 0B11           ;       UnloadConfig_initial();
 0B11 7C0000            xcall _UnloadConfig_initial
 0B14                   .dbline 957
 0B14           ;       UnloadConfig_servo_transmit();
 0B14 7C0000            xcall _UnloadConfig_servo_transmit
 0B17                   .dbline -2
 0B17           L245:
 0B17                   .dbline 0 ; func end
 0B17 7F                ret
 0B18                   .dbend
 0B18                   .dbfunc e unloadConfig _unloadConfig fV
 0B18           ;     config_num -> X-5
 0B18           _unloadConfig::
 0B18                   .dbline -1
 0B18 10                push X
 0B19 4F                mov X,SP
 0B1A                   .dbline 963
 0B1A           ; }
 0B1A           ; 
 0B1A           ; // This function unloads the configuration corresponding to the config number passed to it.
 0B1A           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0B1A           ; void unloadConfig(int config_num)
 0B1A           ; {
 0B1A                   .dbline 964
 0B1A           ;       if(config_num == WAIT)
 0B1A 3DFB00            cmp [X-5],0
 0B1D B00B              jnz L247
 0B1F 3DFC01            cmp [X-4],1
 0B22 B006              jnz L247
 0B24           X49:
 0B24                   .dbline 965
 0B24           ;       {
 0B24                   .dbline 966
 0B24           ;               UnloadConfig_waiting();
 0B24 7C0000            xcall _UnloadConfig_waiting
 0B27                   .dbline 967
 0B27           ;       }
 0B27 8077              xjmp L248
 0B29           L247:
 0B29                   .dbline 968
 0B29           ;       else if(config_num == HELLO_MODE)
 0B29 3DFB00            cmp [X-5],0
 0B2C B00B              jnz L249
 0B2E 3DFC07            cmp [X-4],7
 0B31 B006              jnz L249
 0B33           X50:
 0B33                   .dbline 969
 0B33           ;       {
 0B33                   .dbline 970
 0B33           ;               UnloadConfig_hello();
 0B33 7C0000            xcall _UnloadConfig_hello
 0B36                   .dbline 971
 0B36           ;       }
 0B36 8068              xjmp L250
 0B38           L249:
 0B38                   .dbline 972
 0B38           ;       else if(config_num == MY_RESPONSE)
 0B38 3DFB00            cmp [X-5],0
 0B3B B00B              jnz L251
 0B3D 3DFC02            cmp [X-4],2
 0B40 B006              jnz L251
 0B42           X51:
 0B42                   .dbline 973
 0B42           ;       {
 0B42                   .dbline 974
 0B42           ;               UnloadConfig_my_response();
 0B42 7C0000            xcall _UnloadConfig_my_response
 0B45                   .dbline 975
 0B45           ;       }
 0B45 8059              xjmp L252
 0B47           L251:
 0B47                   .dbline 976
 0B47           ;       else if(config_num == RESPONSE_1)
 0B47 3DFB00            cmp [X-5],0
 0B4A B00B              jnz L253
 0B4C 3DFC03            cmp [X-4],3
 0B4F B006              jnz L253
 0B51           X52:
 0B51                   .dbline 977
 0B51           ;       {
 0B51                   .dbline 978
 0B51           ;               UnloadConfig_response1();
 0B51 7C0000            xcall _UnloadConfig_response1
 0B54                   .dbline 979
 0B54           ;       }
 0B54 804A              xjmp L254
 0B56           L253:
 0B56                   .dbline 980
 0B56           ;       else if(config_num == RESPONSE_2)
 0B56 3DFB00            cmp [X-5],0
 0B59 B00B              jnz L255
 0B5B 3DFC04            cmp [X-4],4
 0B5E B006              jnz L255
 0B60           X53:
 0B60                   .dbline 981
 0B60           ;       {
 0B60                   .dbline 982
 0B60           ;               UnloadConfig_response2();
 0B60 7C0000            xcall _UnloadConfig_response2
 0B63                   .dbline 983
 0B63           ;       }
 0B63 803B              xjmp L256
 0B65           L255:
 0B65                   .dbline 984
 0B65           ;       else if(config_num == RESPONSE_3)
 0B65 3DFB00            cmp [X-5],0
 0B68 B00B              jnz L257
 0B6A 3DFC05            cmp [X-4],5
 0B6D B006              jnz L257
 0B6F           X54:
 0B6F                   .dbline 985
 0B6F           ;       {
 0B6F                   .dbline 986
 0B6F           ;               UnloadConfig_response3();
 0B6F 7C0000            xcall _UnloadConfig_response3
 0B72                   .dbline 987
 0B72           ;       }
 0B72 802C              xjmp L258
 0B74           L257:
 0B74                   .dbline 988
 0B74           ;       else if(config_num == RESPONSE_4)
 0B74 3DFB00            cmp [X-5],0
 0B77 B00B              jnz L259
 0B79 3DFC06            cmp [X-4],6
 0B7C B006              jnz L259
 0B7E           X55:
 0B7E                   .dbline 989
 0B7E           ;       {
 0B7E                   .dbline 990
 0B7E           ;               UnloadConfig_response4();
 0B7E 7C0000            xcall _UnloadConfig_response4
 0B81                   .dbline 991
 0B81           ;       }
 0B81 801D              xjmp L260
 0B83           L259:
 0B83                   .dbline 992
 0B83           ;       else if(config_num == INITIALIZE)
 0B83 3DFB00            cmp [X-5],0
 0B86 B00B              jnz L261
 0B88 3DFC08            cmp [X-4],8
 0B8B B006              jnz L261
 0B8D           X56:
 0B8D                   .dbline 993
 0B8D           ;       {
 0B8D                   .dbline 994
 0B8D           ;               UnloadConfig_initial();
 0B8D 7C0000            xcall _UnloadConfig_initial
 0B90                   .dbline 995
 0B90           ;       }
 0B90 800E              xjmp L262
 0B92           L261:
 0B92                   .dbline 996
 0B92           ;       else if(config_num == SERVO_COMM)
 0B92 3DFB00            cmp [X-5],0
 0B95 B009              jnz L263
 0B97 3DFC09            cmp [X-4],9
 0B9A B004              jnz L263
 0B9C           X57:
 0B9C                   .dbline 997
 0B9C           ;       {
 0B9C                   .dbline 998
 0B9C           ;               UnloadConfig_servo_transmit();
 0B9C 7C0000            xcall _UnloadConfig_servo_transmit
 0B9F                   .dbline 999
 0B9F           ;       }
 0B9F           L263:
 0B9F           L262:
 0B9F           L260:
 0B9F           L258:
 0B9F           L256:
 0B9F           L254:
 0B9F           L252:
 0B9F           L250:
 0B9F           L248:
 0B9F                   .dbline -2
 0B9F           L246:
 0B9F 20                pop X
 0BA0                   .dbline 0 ; func end
 0BA0 7F                ret
 0BA1                   .dbsym l config_num -5 I
 0BA1                   .dbend
 0BA1                   .dbfunc e assignedID _assignedID fV
 0BA1           _assignedID::
 0BA1                   .dbline -1
 0BA1                   .dbline 1004
 0BA1           ; }
 0BA1           ; 
 0BA1           ; // This function responds that an ID has been assigned to it.
 0BA1           ; void assignedID(void)
 0BA1           ; {
 0BA1                   .dbline 1005
 0BA1           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0BA1 5000              mov A,0
 0BA3 08                push A
 0BA4 5002              mov A,2
 0BA6 08                push A
 0BA7 7C00B4            xcall _configToggle
 0BAA 38FE              add SP,-2
 0BAC                   .dbline 1008
 0BAC           ;       
 0BAC           ;       // Transmit a ping to everyone.
 0BAC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0BAC 10                push X
 0BAD 50FC              mov A,-4
 0BAF 7C0000            xcall _TX_014_PutChar
 0BB2 20                pop X
 0BB3                   .dbline 1009
 0BB3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0BB3 10                push X
 0BB4 50FC              mov A,-4
 0BB6 7C0000            xcall _TX_23_PutChar
 0BB9 20                pop X
 0BBA                   .dbline 1010
 0BBA           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0BBA 10                push X
 0BBB 50FC              mov A,-4
 0BBD 7C0000            xcall _TX_014_PutChar
 0BC0 20                pop X
 0BC1                   .dbline 1011
 0BC1           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0BC1 10                push X
 0BC2 50FC              mov A,-4
 0BC4 7C0000            xcall _TX_23_PutChar
 0BC7 20                pop X
 0BC8                   .dbline 1012
 0BC8           ;       TX_014_PutChar(ID);                             // My ID
 0BC8 10                push X
 0BC9 62D000            mov REG[0xd0],>_ID
 0BCC 5100              mov A,[_ID]
 0BCE 7C0000            xcall _TX_014_PutChar
 0BD1 20                pop X
 0BD2                   .dbline 1013
 0BD2           ;       TX_23_PutChar(ID);                              // My ID
 0BD2 10                push X
 0BD3 62D000            mov REG[0xd0],>_ID
 0BD6 5100              mov A,[_ID]
 0BD8 7C0000            xcall _TX_23_PutChar
 0BDB 20                pop X
 0BDC                   .dbline 1014
 0BDC           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0BDC 10                push X
 0BDD 5000              mov A,0
 0BDF 7C0000            xcall _TX_014_PutChar
 0BE2 20                pop X
 0BE3                   .dbline 1015
 0BE3           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0BE3 10                push X
 0BE4 5000              mov A,0
 0BE6 7C0000            xcall _TX_23_PutChar
 0BE9 20                pop X
 0BEA                   .dbline 1016
 0BEA           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0BEA 10                push X
 0BEB 50CA              mov A,-54
 0BED 7C0000            xcall _TX_014_PutChar
 0BF0 20                pop X
 0BF1                   .dbline 1017
 0BF1           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0BF1 10                push X
 0BF2 50CA              mov A,-54
 0BF4 7C0000            xcall _TX_23_PutChar
 0BF7 20                pop X
 0BF8                   .dbline 1018
 0BF8           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0BF8 10                push X
 0BF9 50FD              mov A,-3
 0BFB 7C0000            xcall _TX_014_PutChar
 0BFE 20                pop X
 0BFF                   .dbline 1019
 0BFF           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0BFF 10                push X
 0C00 50FD              mov A,-3
 0C02 7C0000            xcall _TX_23_PutChar
 0C05 20                pop X
 0C06                   .dbline 1020
 0C06           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0C06 10                push X
 0C07 50FD              mov A,-3
 0C09 7C0000            xcall _TX_014_PutChar
 0C0C 20                pop X
 0C0D                   .dbline 1021
 0C0D           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0C0D 10                push X
 0C0E 50FD              mov A,-3
 0C10 7C0000            xcall _TX_23_PutChar
 0C13 20                pop X
 0C14           L266:
 0C14                   .dbline 1024
 0C14           ;       
 0C14           ;       // Wait for the transmission to finish.
 0C14           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0C14           L267:
 0C14                   .dbline 1024
 0C14 10                push X
 0C15 7C0000            xcall _TX_014_bReadTxStatus
 0C18 62D000            mov REG[0xd0],>__r0
 0C1B 20                pop X
 0C1C 5300              mov [__r0],A
 0C1E 470020            tst [__r0],32
 0C21 AFF2              jz L266
 0C23           L269:
 0C23                   .dbline 1025
 0C23           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0C23           L270:
 0C23                   .dbline 1025
 0C23 10                push X
 0C24 7C0000            xcall _TX_23_bReadTxStatus
 0C27 62D000            mov REG[0xd0],>__r0
 0C2A 20                pop X
 0C2B 5300              mov [__r0],A
 0C2D 470020            tst [__r0],32
 0C30 AFF2              jz L269
 0C32                   .dbline 1028
 0C32           ;       
 0C32           ;       // Make completely sure we're done.
 0C32           ;       xmitWait();
 0C32 93F8              xcall _xmitWait
 0C34                   .dbline 1030
 0C34           ;       
 0C34           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C34 5000              mov A,0
 0C36 08                push A
 0C37 5001              mov A,1
 0C39 08                push A
 0C3A 7C00B4            xcall _configToggle
 0C3D 38FE              add SP,-2
 0C3F                   .dbline -2
 0C3F           L265:
 0C3F                   .dbline 0 ; func end
 0C3F 7F                ret
 0C40                   .dbend
 0C40                   .dbfunc e childListen _childListen fI
 0C40           _childListen::
 0C40                   .dbline -1
 0C40                   .dbline 1035
 0C40           ; }
 0C40           ; 
 0C40           ; // This function listens for children and registers the port that they talk to.
 0C40           ; int childListen(void)
 0C40           ; {
 0C40                   .dbline 1036
 0C40           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0C40 5000              mov A,0
 0C42 08                push A
 0C43 5007              mov A,7
 0C45 08                push A
 0C46 7C00B4            xcall _configToggle
 0C49 38FE              add SP,-2
 0C4B 801C              xjmp L274
 0C4D           L273:
 0C4D                   .dbline 1040
 0C4D           ;       
 0C4D           ;       // Wait to either hear a child or time out.
 0C4D           ;       while(!TIMEOUT)
 0C4D           ;       {               
 0C4D                   .dbline 1041
 0C4D           ;               if(commandReady())
 0C4D 7C02CA            xcall _commandReady
 0C50 62D000            mov REG[0xd0],>__r0
 0C53 3C0000            cmp [__r0],0
 0C56 B006              jnz X58
 0C58 3C0000            cmp [__r1],0
 0C5B A00C              jz L276
 0C5D           X58:
 0C5D                   .dbline 1042
 0C5D           ;               {
 0C5D                   .dbline 1043
 0C5D           ;                       return 1;
 0C5D 62D000            mov REG[0xd0],>__r0
 0C60 550001            mov [__r1],1
 0C63 550000            mov [__r0],0
 0C66 8030              xjmp L272
 0C68           L276:
 0C68                   .dbline 1045
 0C68           ;               }
 0C68           ;       }
 0C68           L274:
 0C68                   .dbline 1039
 0C68 62D000            mov REG[0xd0],>_TIMEOUT
 0C6B 3C0000            cmp [_TIMEOUT],0
 0C6E B006              jnz X59
 0C70 3C0100            cmp [_TIMEOUT+1],0
 0C73 AFD9              jz L273
 0C75           X59:
 0C75                   .dbline 1047
 0C75           ;       
 0C75           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0C75 10                push X
 0C76 7C0000            xcall _HELLO_TIMEOUT_Stop
 0C79 20                pop X
 0C7A                   .dbline 1048
 0C7A           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0C7A 62D000            mov REG[0xd0],>_TIMEOUT
 0C7D 550100            mov [_TIMEOUT+1],0
 0C80 550000            mov [_TIMEOUT],0
 0C83                   .dbline 1050
 0C83           ;       
 0C83           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0C83 5000              mov A,0
 0C85 08                push A
 0C86 5001              mov A,1
 0C88 08                push A
 0C89 7C00B4            xcall _configToggle
 0C8C 38FE              add SP,-2
 0C8E                   .dbline 1052
 0C8E           ;       
 0C8E           ;       return 0;                                       // Return the result of our listening session.
 0C8E 62D000            mov REG[0xd0],>__r0
 0C91 550000            mov [__r1],0
 0C94 550000            mov [__r0],0
 0C97                   .dbline -2
 0C97           L272:
 0C97                   .dbline 0 ; func end
 0C97 7F                ret
 0C98                   .dbend
 0C98                   .dbfunc e childResponse _childResponse fI
 0C98           ; child_responded -> X+0
 0C98           _childResponse::
 0C98                   .dbline -1
 0C98 10                push X
 0C99 4F                mov X,SP
 0C9A 3802              add SP,2
 0C9C                   .dbline 1057
 0C9C           ; }
 0C9C           ; 
 0C9C           ; // This function waits for a child response.
 0C9C           ; int childResponse(void)
 0C9C           ; {
 0C9C                   .dbline 1058
 0C9C           ;       int child_responded = 0;
 0C9C 560100            mov [X+1],0
 0C9F 560000            mov [X+0],0
 0CA2                   .dbline 1061
 0CA2           ;       
 0CA2           ;       // Switch to the right port.
 0CA2           ;       if(CHILD == PORT_A)
 0CA2 62D000            mov REG[0xd0],>_CHILD
 0CA5 3C0041            cmp [_CHILD],65
 0CA8 B00E              jnz L279
 0CAA                   .dbline 1062
 0CAA           ;       {
 0CAA                   .dbline 1063
 0CAA           ;               configToggle(RESPONSE_1);
 0CAA 5000              mov A,0
 0CAC 08                push A
 0CAD 5003              mov A,3
 0CAF 08                push A
 0CB0 7C00B4            xcall _configToggle
 0CB3 38FE              add SP,-2
 0CB5                   .dbline 1064
 0CB5           ;       }
 0CB5 8056              xjmp L288
 0CB7           L279:
 0CB7                   .dbline 1065
 0CB7           ;       else if(CHILD == PORT_B)
 0CB7 62D000            mov REG[0xd0],>_CHILD
 0CBA 3C0042            cmp [_CHILD],66
 0CBD B00E              jnz L281
 0CBF                   .dbline 1066
 0CBF           ;       {
 0CBF                   .dbline 1067
 0CBF           ;               configToggle(RESPONSE_2);
 0CBF 5000              mov A,0
 0CC1 08                push A
 0CC2 5004              mov A,4
 0CC4 08                push A
 0CC5 7C00B4            xcall _configToggle
 0CC8 38FE              add SP,-2
 0CCA                   .dbline 1068
 0CCA           ;       }
 0CCA 8041              xjmp L288
 0CCC           L281:
 0CCC                   .dbline 1069
 0CCC           ;       else if(CHILD == PORT_C)
 0CCC 62D000            mov REG[0xd0],>_CHILD
 0CCF 3C0043            cmp [_CHILD],67
 0CD2 B00E              jnz L283
 0CD4                   .dbline 1070
 0CD4           ;       {
 0CD4                   .dbline 1071
 0CD4           ;               configToggle(RESPONSE_3);
 0CD4 5000              mov A,0
 0CD6 08                push A
 0CD7 5005              mov A,5
 0CD9 08                push A
 0CDA 7C00B4            xcall _configToggle
 0CDD 38FE              add SP,-2
 0CDF                   .dbline 1072
 0CDF           ;       }
 0CDF 802C              xjmp L288
 0CE1           L283:
 0CE1                   .dbline 1073
 0CE1           ;       else if(CHILD == PORT_D)
 0CE1 62D000            mov REG[0xd0],>_CHILD
 0CE4 3C0044            cmp [_CHILD],68
 0CE7 B024              jnz L288
 0CE9                   .dbline 1074
 0CE9           ;       {
 0CE9                   .dbline 1075
 0CE9           ;               configToggle(RESPONSE_4);
 0CE9 5000              mov A,0
 0CEB 08                push A
 0CEC 5006              mov A,6
 0CEE 08                push A
 0CEF 7C00B4            xcall _configToggle
 0CF2 38FE              add SP,-2
 0CF4                   .dbline 1076
 0CF4           ;       }
 0CF4 8017              xjmp L288
 0CF6           L287:
 0CF6                   .dbline 1080
 0CF6           ;       
 0CF6           ;       // Wait for a response or a timeout.
 0CF6           ;       while((!child_responded) && (!TIMEOUT))
 0CF6           ;       {
 0CF6                   .dbline 1081
 0CF6           ;               if(commandReady())
 0CF6 7C02CA            xcall _commandReady
 0CF9 62D000            mov REG[0xd0],>__r0
 0CFC 3C0000            cmp [__r0],0
 0CFF B006              jnz X60
 0D01 3C0000            cmp [__r1],0
 0D04 A007              jz L290
 0D06           X60:
 0D06                   .dbline 1082
 0D06           ;               {
 0D06                   .dbline 1083
 0D06           ;                       child_responded = 1;
 0D06 560101            mov [X+1],1
 0D09 560000            mov [X+0],0
 0D0C                   .dbline 1084
 0D0C           ;               }
 0D0C           L290:
 0D0C                   .dbline 1085
 0D0C           ;       }
 0D0C           L288:
 0D0C                   .dbline 1079
 0D0C 3D0000            cmp [X+0],0
 0D0F B013              jnz L292
 0D11 3D0100            cmp [X+1],0
 0D14 B00E              jnz L292
 0D16           X61:
 0D16 62D000            mov REG[0xd0],>_TIMEOUT
 0D19 3C0000            cmp [_TIMEOUT],0
 0D1C B006              jnz X62
 0D1E 3C0100            cmp [_TIMEOUT+1],0
 0D21 AFD4              jz L287
 0D23           X62:
 0D23           L292:
 0D23                   .dbline 1088
 0D23           ;       
 0D23           ;       // Stop the right timer.
 0D23           ;       if(CHILD == PORT_A)
 0D23 62D000            mov REG[0xd0],>_CHILD
 0D26 3C0041            cmp [_CHILD],65
 0D29 B008              jnz L293
 0D2B                   .dbline 1089
 0D2B           ;       {
 0D2B                   .dbline 1090
 0D2B           ;               CHILD_1_TIMEOUT_Stop();
 0D2B 10                push X
 0D2C 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0D2F 20                pop X
 0D30                   .dbline 1091
 0D30           ;       }
 0D30 802C              xjmp L294
 0D32           L293:
 0D32                   .dbline 1092
 0D32           ;       else if(CHILD == PORT_B)
 0D32 62D000            mov REG[0xd0],>_CHILD
 0D35 3C0042            cmp [_CHILD],66
 0D38 B008              jnz L295
 0D3A                   .dbline 1093
 0D3A           ;       {
 0D3A                   .dbline 1094
 0D3A           ;               CHILD_2_TIMEOUT_Stop();
 0D3A 10                push X
 0D3B 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0D3E 20                pop X
 0D3F                   .dbline 1095
 0D3F           ;       }
 0D3F 801D              xjmp L296
 0D41           L295:
 0D41                   .dbline 1096
 0D41           ;       else if(CHILD == PORT_C)
 0D41 62D000            mov REG[0xd0],>_CHILD
 0D44 3C0043            cmp [_CHILD],67
 0D47 B008              jnz L297
 0D49                   .dbline 1097
 0D49           ;       {
 0D49                   .dbline 1098
 0D49           ;               CHILD_3_TIMEOUT_Stop();
 0D49 10                push X
 0D4A 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0D4D 20                pop X
 0D4E                   .dbline 1099
 0D4E           ;       }
 0D4E 800E              xjmp L298
 0D50           L297:
 0D50                   .dbline 1100
 0D50           ;       else if(CHILD == PORT_D)
 0D50 62D000            mov REG[0xd0],>_CHILD
 0D53 3C0044            cmp [_CHILD],68
 0D56 B006              jnz L299
 0D58                   .dbline 1101
 0D58           ;       {
 0D58                   .dbline 1102
 0D58           ;               CHILD_4_TIMEOUT_Stop();
 0D58 10                push X
 0D59 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0D5C 20                pop X
 0D5D                   .dbline 1103
 0D5D           ;       }
 0D5D           L299:
 0D5D           L298:
 0D5D           L296:
 0D5D           L294:
 0D5D                   .dbline 1105
 0D5D           ;       
 0D5D           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0D5D 62D000            mov REG[0xd0],>_TIMEOUT
 0D60 550100            mov [_TIMEOUT+1],0
 0D63 550000            mov [_TIMEOUT],0
 0D66                   .dbline 1107
 0D66           ;       
 0D66           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0D66 5000              mov A,0
 0D68 08                push A
 0D69 5001              mov A,1
 0D6B 08                push A
 0D6C 7C00B4            xcall _configToggle
 0D6F 38FE              add SP,-2
 0D71                   .dbline 1109
 0D71           ;       
 0D71           ;       return child_responded;
 0D71 62D000            mov REG[0xd0],>__r0
 0D74 5201              mov A,[X+1]
 0D76 5300              mov [__r1],A
 0D78 5200              mov A,[X+0]
 0D7A 5300              mov [__r0],A
 0D7C                   .dbline -2
 0D7C           L278:
 0D7C 38FE              add SP,-2
 0D7E 20                pop X
 0D7F                   .dbline 0 ; func end
 0D7F 7F                ret
 0D80                   .dbsym l child_responded 0 I
 0D80                   .dbend
 0D80                   .dbfunc e servoFinder _servoFinder fV
 0D80           ;     flashWrite -> X+7
 0D80           ; status_return_level -> X+6
 0D80           ; total_attempts -> X+4
 0D80           ;              j -> X+2
 0D80           ;              i -> X+0
 0D80           _servoFinder::
 0D80                   .dbline -1
 0D80 10                push X
 0D81 4F                mov X,SP
 0D82 3809              add SP,9
 0D84                   .dbline 1116
 0D84           ; }
 0D84           ; 
 0D84           ; // This function is used to find the servo that is directly connected to this module's controller.
 0D84           ; // After the servo ID is found, the status return level is changed so that packets are only
 0D84           ; // returned for the desired status return level defined at the top of this file.
 0D84           ; void servoFinder(void)
 0D84           ; {                             
 0D84                   .dbline 1118
 0D84           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0D84           ;       int i = 0;
 0D84 560100            mov [X+1],0
 0D87 560000            mov [X+0],0
 0D8A                   .dbline 1119
 0D8A           ;       int j = 0;
 0D8A 560300            mov [X+3],0
 0D8D 560200            mov [X+2],0
 0D90                   .dbline 1121
 0D90           ;       
 0D90           ;       int total_attempts = 0;
 0D90 560500            mov [X+5],0
 0D93 560400            mov [X+4],0
 0D96                   .dbline 1124
 0D96           ;       
 0D96           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0D96           ;       int flashWrite = 0;
 0D96 560800            mov [X+8],0
 0D99 560700            mov [X+7],0
 0D9C                   .dbline 1127
 0D9C           ;       
 0D9C           ;       // Create a status return level variable and set it to an out of range value initially.
 0D9C           ;       char status_return_level = 3;
 0D9C 560603            mov [X+6],3
 0D9F                   .dbline 1130
 0D9F           ;       
 0D9F           ;       // Start with a servo ID of 255 (out of valid range).
 0D9F           ;       SERVO_ID = SERVO_START;
 0D9F 62D000            mov REG[0xd0],>_SERVO_ID
 0DA2 5500FF            mov [_SERVO_ID],-1
 0DA5                   .dbline 1139
 0DA5           ; 
 0DA5           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0DA5           ;       // number of times in each loop (unless stopped short due to early success).  If this fails for the
 0DA5           ;       // first round of pings, a broadcast reset will be performed to reset the servo.  This is done
 0DA5           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0DA5           ;       // fast for the controller to switch into receive mode to read the response.  The default return
 0DA5           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0DA5           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0DA5           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DA5 560300            mov [X+3],0
 0DA8 560200            mov [X+2],0
 0DAB           L302:
 0DAB                   .dbline 1140
 0DAB           ;       {       
 0DAB                   .dbline 1142
 0DAB           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0DAB           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DAB 560100            mov [X+1],0
 0DAE 560000            mov [X+0],0
 0DB1           L306:
 0DB1                   .dbline 1143
 0DB1           ;               {
 0DB1                   .dbline 1145
 0DB1           ;                       // Send a ping out for any servo connected to me (will only be one).
 0DB1           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0DB1 5000              mov A,0
 0DB3 08                push A
 0DB4 08                push A
 0DB5 5001              mov A,1
 0DB7 08                push A
 0DB8 5002              mov A,2
 0DBA 08                push A
 0DBB 50FE              mov A,-2
 0DBD 08                push A
 0DBE 918E              xcall _servoInstruction
 0DC0 38FB              add SP,-5
 0DC2                   .dbline 1147
 0DC2           ;                       
 0DC2           ;                       total_attempts++;
 0DC2 7705              inc [X+5]
 0DC4 0F0400            adc [X+4],0
 0DC7 804C              xjmp L311
 0DC9           L310:
 0DC9                   .dbline 1151
 0DC9           ;                       
 0DC9           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0DC9           ;                       while(!TIMEOUT)
 0DC9           ;                       {       
 0DC9                   .dbline 1152
 0DC9           ;                               if(commandReady())
 0DC9 7C02CA            xcall _commandReady
 0DCC 62D000            mov REG[0xd0],>__r0
 0DCF 3C0000            cmp [__r0],0
 0DD2 B006              jnz X63
 0DD4 3C0000            cmp [__r1],0
 0DD7 A03C              jz L313
 0DD9           X63:
 0DD9                   .dbline 1153
 0DD9           ;                               {
 0DD9                   .dbline 1155
 0DD9           ;                                       // If we read a source ID within the range, exit the loop.
 0DD9           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0DD9 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DDC 3C0000            cmp [_COMMAND_SOURCE],0
 0DDF C02B              jc L315
 0DE1           X64:
 0DE1 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DE4 50FD              mov A,-3
 0DE6 3A00              cmp A,[_COMMAND_SOURCE]
 0DE8 C022              jc L315
 0DEA           X65:
 0DEA                   .dbline 1156
 0DEA           ;                                       {       
 0DEA                   .dbline 1158
 0DEA           ;                                               // Exit this while loop by setting the timeout flag.
 0DEA           ;                                               TIMEOUT = 1;
 0DEA 62D000            mov REG[0xd0],>_TIMEOUT
 0DED 550101            mov [_TIMEOUT+1],1
 0DF0 550000            mov [_TIMEOUT],0
 0DF3                   .dbline 1160
 0DF3           ;                                               // Set the servo ID variable to where the ping came from.
 0DF3           ;                                               SERVO_ID = COMMAND_SOURCE;
 0DF3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DF6 5100              mov A,[_COMMAND_SOURCE]
 0DF8 62D000            mov REG[0xd0],>_SERVO_ID
 0DFB 5300              mov [_SERVO_ID],A
 0DFD                   .dbline 1162
 0DFD           ;                                               // Set the index variable such that the for loop exits.
 0DFD           ;                                               i = SERVO_COMM_ATTEMPTS;
 0DFD 56010A            mov [X+1],10
 0E00 560000            mov [X+0],0
 0E03                   .dbline 1164
 0E03           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0E03           ;                                               j = SERVO_COMM_LOOPS;
 0E03 560302            mov [X+3],2
 0E06 560200            mov [X+2],0
 0E09                   .dbline 1165
 0E09           ;                                       }
 0E09 800A              xjmp L316
 0E0B           L315:
 0E0B                   .dbline 1167
 0E0B           ;                                       else
 0E0B           ;                                       {
 0E0B                   .dbline 1169
 0E0B           ;                                               // Exit this while loop and try to ping again.
 0E0B           ;                                               TIMEOUT = 1;
 0E0B 62D000            mov REG[0xd0],>_TIMEOUT
 0E0E 550101            mov [_TIMEOUT+1],1
 0E11 550000            mov [_TIMEOUT],0
 0E14                   .dbline 1170
 0E14           ;                                       }
 0E14           L316:
 0E14                   .dbline 1171
 0E14           ;                               }
 0E14           L313:
 0E14                   .dbline 1172
 0E14           ;                       }
 0E14           L311:
 0E14                   .dbline 1150
 0E14 62D000            mov REG[0xd0],>_TIMEOUT
 0E17 3C0000            cmp [_TIMEOUT],0
 0E1A B006              jnz X66
 0E1C 3C0100            cmp [_TIMEOUT+1],0
 0E1F AFA9              jz L310
 0E21           X66:
 0E21                   .dbline 1173
 0E21           ;               }
 0E21           L307:
 0E21                   .dbline 1142
 0E21 7701              inc [X+1]
 0E23 0F0000            adc [X+0],0
 0E26                   .dbline 1142
 0E26 5201              mov A,[X+1]
 0E28 110A              sub A,10
 0E2A 5200              mov A,[X+0]
 0E2C 3180              xor A,-128
 0E2E 1980              sbb A,(0 ^ 0x80)
 0E30 CF80              jc L306
 0E32           X67:
 0E32                   .dbline 1177
 0E32           ;               
 0E32           ;               // If we didn't get a response and haven't written to the flash of the
 0E32           ;               // servo (first time through), send out a broadcast reset.
 0E32           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0E32 62D000            mov REG[0xd0],>_SERVO_ID
 0E35 3C00FF            cmp [_SERVO_ID],-1
 0E38 B022              jnz L317
 0E3A 3D0700            cmp [X+7],0
 0E3D B01D              jnz L317
 0E3F 3D0800            cmp [X+8],0
 0E42 B018              jnz L317
 0E44           X68:
 0E44                   .dbline 1178
 0E44           ;               {
 0E44                   .dbline 1180
 0E44           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0E44           ;                       flashWrite = 1;
 0E44 560801            mov [X+8],1
 0E47 560700            mov [X+7],0
 0E4A                   .dbline 1184
 0E4A           ;                       
 0E4A           ;                       // Send out a broadcast reset so that we know that the response time interval
 0E4A           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0E4A           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0E4A 5000              mov A,0
 0E4C 08                push A
 0E4D 08                push A
 0E4E 5006              mov A,6
 0E50 08                push A
 0E51 5002              mov A,2
 0E53 08                push A
 0E54 50FE              mov A,-2
 0E56 08                push A
 0E57 90F5              xcall _servoInstruction
 0E59 38FB              add SP,-5
 0E5B                   .dbline 1185
 0E5B           ;               }
 0E5B           L317:
 0E5B                   .dbline 1186
 0E5B           ;       }
 0E5B           L303:
 0E5B                   .dbline 1139
 0E5B 7703              inc [X+3]
 0E5D 0F0200            adc [X+2],0
 0E60                   .dbline 1139
 0E60 5203              mov A,[X+3]
 0E62 1102              sub A,2
 0E64 5202              mov A,[X+2]
 0E66 3180              xor A,-128
 0E68 1980              sbb A,(0 ^ 0x80)
 0E6A CF40              jc L302
 0E6C           X69:
 0E6C                   .dbline 1189
 0E6C           ; 
 0E6C           ;       // Reset flash write flag.
 0E6C           ;       flashWrite = 0;
 0E6C 560800            mov [X+8],0
 0E6F 560700            mov [X+7],0
 0E72                   .dbline 1193
 0E72           ;       
 0E72           ;       // If we have a valid servo ID, set the status return level.  If we don't, just skip this
 0E72           ;       // because all hope is lost.
 0E72           ;       if(SERVO_ID < BROADCAST)
 0E72 62D000            mov REG[0xd0],>_SERVO_ID
 0E75 3C00FE            cmp [_SERVO_ID],-2
 0E78 D0CD              jnc L346
 0E7A           X70:
 0E7A                   .dbline 1194
 0E7A           ;       {
 0E7A                   .dbline 1199
 0E7A           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0E7A           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0E7A           ;               // to early success).  If this fails for the first iteration, or we read a status return level
 0E7A           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0E7A           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0E7A 560300            mov [X+3],0
 0E7D 560200            mov [X+2],0
 0E80           L321:
 0E80                   .dbline 1200
 0E80           ;               {
 0E80                   .dbline 1202
 0E80           ;                       // Attempt to read the status return level for the defined number of attempts.
 0E80           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0E80 560100            mov [X+1],0
 0E83 560000            mov [X+0],0
 0E86           L325:
 0E86                   .dbline 1203
 0E86           ;                       {
 0E86                   .dbline 1205
 0E86           ;                               // Send a request for the servo's status return level.
 0E86           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0E86 5001              mov A,1
 0E88 08                push A
 0E89 5010              mov A,16
 0E8B 08                push A
 0E8C 5002              mov A,2
 0E8E 08                push A
 0E8F 5004              mov A,4
 0E91 08                push A
 0E92 62D000            mov REG[0xd0],>_SERVO_ID
 0E95 5100              mov A,[_SERVO_ID]
 0E97 08                push A
 0E98 90B4              xcall _servoInstruction
 0E9A 38FB              add SP,-5
 0E9C 8048              xjmp L330
 0E9E           L329:
 0E9E                   .dbline 1209
 0E9E           ;                               
 0E9E           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0E9E           ;                               while(!TIMEOUT)
 0E9E           ;                               {
 0E9E                   .dbline 1211
 0E9E           ;                                       // If a valid command is ready, interpret it.
 0E9E           ;                                       if(commandReady())
 0E9E 7C02CA            xcall _commandReady
 0EA1 62D000            mov REG[0xd0],>__r0
 0EA4 3C0000            cmp [__r0],0
 0EA7 B006              jnz X71
 0EA9 3C0000            cmp [__r1],0
 0EAC A038              jz L332
 0EAE           X71:
 0EAE                   .dbline 1212
 0EAE           ;                                       {
 0EAE                   .dbline 1213
 0EAE           ;                                               if(!COMMAND_ERROR)
 0EAE 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0EB1 3C0000            cmp [_COMMAND_ERROR],0
 0EB4 B030              jnz L334
 0EB6                   .dbline 1214
 0EB6           ;                                               {
 0EB6                   .dbline 1216
 0EB6           ;                                                       // If the return level is equal to what is desired, store it.
 0EB6           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0EB6 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0EB9 3C0001            cmp [_COMMAND_PARAM],1
 0EBC B01F              jnz L336
 0EBE                   .dbline 1217
 0EBE           ;                                                       {
 0EBE                   .dbline 1219
 0EBE           ;                                                               // Set the timeout flag to exit the loop.
 0EBE           ;                                                               TIMEOUT = 1;
 0EBE 62D000            mov REG[0xd0],>_TIMEOUT
 0EC1 550101            mov [_TIMEOUT+1],1
 0EC4 550000            mov [_TIMEOUT],0
 0EC7                   .dbline 1221
 0EC7           ;                                                               // Store the status return level.
 0EC7           ;                                                               status_return_level = COMMAND_PARAM;
 0EC7 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0ECA 5100              mov A,[_COMMAND_PARAM]
 0ECC 5406              mov [X+6],A
 0ECE                   .dbline 1223
 0ECE           ;                                                               // Set i so that we exit the for loop.
 0ECE           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0ECE 56010A            mov [X+1],10
 0ED1 560000            mov [X+0],0
 0ED4                   .dbline 1225
 0ED4           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0ED4           ;                                                               j = SERVO_COMM_LOOPS;
 0ED4 560302            mov [X+3],2
 0ED7 560200            mov [X+2],0
 0EDA                   .dbline 1226
 0EDA           ;                                                       }
 0EDA 800A              xjmp L337
 0EDC           L336:
 0EDC                   .dbline 1228
 0EDC           ;                                                       else
 0EDC           ;                                                       {       
 0EDC                   .dbline 1230
 0EDC           ;                                                               // Set the timeout flag to exit the loop.
 0EDC           ;                                                               TIMEOUT = 1;
 0EDC 62D000            mov REG[0xd0],>_TIMEOUT
 0EDF 550101            mov [_TIMEOUT+1],1
 0EE2 550000            mov [_TIMEOUT],0
 0EE5                   .dbline 1231
 0EE5           ;                                                       }
 0EE5           L337:
 0EE5                   .dbline 1232
 0EE5           ;                                               }
 0EE5           L334:
 0EE5                   .dbline 1233
 0EE5           ;                                       }
 0EE5           L332:
 0EE5                   .dbline 1234
 0EE5           ;                               }
 0EE5           L330:
 0EE5                   .dbline 1208
 0EE5 62D000            mov REG[0xd0],>_TIMEOUT
 0EE8 3C0000            cmp [_TIMEOUT],0
 0EEB B006              jnz X72
 0EED 3C0100            cmp [_TIMEOUT+1],0
 0EF0 AFAD              jz L329
 0EF2           X72:
 0EF2                   .dbline 1235
 0EF2           ;                       }
 0EF2           L326:
 0EF2                   .dbline 1202
 0EF2 7701              inc [X+1]
 0EF4 0F0000            adc [X+0],0
 0EF7                   .dbline 1202
 0EF7 5201              mov A,[X+1]
 0EF9 110A              sub A,10
 0EFB 5200              mov A,[X+0]
 0EFD 3180              xor A,-128
 0EFF 1980              sbb A,(0 ^ 0x80)
 0F01 CF84              jc L325
 0F03           X73:
 0F03                   .dbline 1239
 0F03           ;               
 0F03           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0F03           ;                       // force a change in the status return level with an EEPROM write.
 0F03           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0F03 3D0601            cmp [X+6],1
 0F06 A027              jz L338
 0F08 3D0700            cmp [X+7],0
 0F0B B022              jnz L338
 0F0D 3D0800            cmp [X+8],0
 0F10 B01D              jnz L338
 0F12           X74:
 0F12                   .dbline 1240
 0F12           ;                       {       
 0F12                   .dbline 1241
 0F12           ;                               flashWrite = 1;
 0F12 560801            mov [X+8],1
 0F15 560700            mov [X+7],0
 0F18                   .dbline 1244
 0F18           ;                               
 0F18           ;                               // Try to force the return status to what we want.
 0F18           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0F18 5001              mov A,1
 0F1A 08                push A
 0F1B 5010              mov A,16
 0F1D 08                push A
 0F1E 5003              mov A,3
 0F20 08                push A
 0F21 5004              mov A,4
 0F23 08                push A
 0F24 62D000            mov REG[0xd0],>_SERVO_ID
 0F27 5100              mov A,[_SERVO_ID]
 0F29 08                push A
 0F2A 9022              xcall _servoInstruction
 0F2C 38FB              add SP,-5
 0F2E                   .dbline 1245
 0F2E           ;                       }
 0F2E           L338:
 0F2E                   .dbline 1246
 0F2E           ;               }
 0F2E           L322:
 0F2E                   .dbline 1199
 0F2E 7703              inc [X+3]
 0F30 0F0200            adc [X+2],0
 0F33                   .dbline 1199
 0F33 5203              mov A,[X+3]
 0F35 1102              sub A,2
 0F37 5202              mov A,[X+2]
 0F39 3180              xor A,-128
 0F3B 1980              sbb A,(0 ^ 0x80)
 0F3D CF42              jc L321
 0F3F           X75:
 0F3F                   .dbline 1248
 0F3F           ;               
 0F3F           ;               if(status_return_level != STATUS_RET_LEVEL)
 0F3F 3D0601            cmp [X+6],1
 0F42 A005              jz L320
 0F44                   .dbline 1249
 0F44           ;               {
 0F44           L342:
 0F44                   .dbline 1251
 0F44           ;                       // Break on purpose to show that the status return is not correct.
 0F44           ;                       while(1) { }
 0F44                   .dbline 1251
 0F44           L343:
 0F44                   .dbline 1251
 0F44 8FFF              xjmp L342
 0F46           L345:
 0F46                   .dbline 1257
 0F46           ;               }
 0F46           ;       }
 0F46           ;       else
 0F46           ;       {
 0F46           ;               // Purposely break the module to show that we did not resolve the communication with our servo.
 0F46           ;               while(1) { }
 0F46                   .dbline 1257
 0F46           L346:
 0F46                   .dbline 1257
 0F46 8FFF              xjmp L345
 0F48           L320:
 0F48                   .dbline 1261
 0F48           ;       }
 0F48           ;       
 0F48           ;       // Wait for the other controllers to find their servos.
 0F48           ;       servoConfigWait();
 0F48 9155              xcall _servoConfigWait
 0F4A                   .dbline -2
 0F4A           L301:
 0F4A 38F7              add SP,-9
 0F4C 20                pop X
 0F4D                   .dbline 0 ; func end
 0F4D 7F                ret
 0F4E                   .dbsym l flashWrite 7 I
 0F4E                   .dbsym l status_return_level 6 c
 0F4E                   .dbsym l total_attempts 4 I
 0F4E                   .dbsym l j 2 I
 0F4E                   .dbsym l i 0 I
 0F4E                   .dbend
 0F4E                   .dbfunc e servoInstruction _servoInstruction fV
 0F4E           ;       checksum -> X+0
 0F4E           ;          value -> X-8
 0F4E           ;        address -> X-7
 0F4E           ;    instruction -> X-6
 0F4E           ;         length -> X-5
 0F4E           ;             id -> X-4
 0F4E           _servoInstruction::
 0F4E                   .dbline -1
 0F4E 10                push X
 0F4F 4F                mov X,SP
 0F50 3801              add SP,1
 0F52                   .dbline 1267
 0F52           ; }
 0F52           ; 
 0F52           ; // This function receives a destination, command length, instruction type, address, and value.
 0F52           ; // With these parameters, the function sends a packet to the communication bus.
 0F52           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0F52           ; {
 0F52                   .dbline 1271
 0F52           ;       char checksum;
 0F52           ;       
 0F52           ;       // Toggle into transmit mode.
 0F52           ;       configToggle(SERVO_COMM);
 0F52 5000              mov A,0
 0F54 08                push A
 0F55 5009              mov A,9
 0F57 08                push A
 0F58 7C00B4            xcall _configToggle
 0F5B 38FE              add SP,-2
 0F5D                   .dbline 1274
 0F5D           ;       
 0F5D           ;       // Calculate the checksum value for our servo communication.
 0F5D           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0F5D 62D000            mov REG[0xd0],>__r0
 0F60 52FB              mov A,[X-5]
 0F62 5300              mov [__r1],A
 0F64 550000            mov [__r0],0
 0F67 52FC              mov A,[X-4]
 0F69 0200              add A,[__r1]
 0F6B 5300              mov [__r1],A
 0F6D 5000              mov A,0
 0F6F 0A00              adc A,[__r0]
 0F71 5300              mov [__r0],A
 0F73 52FA              mov A,[X-6]
 0F75 0400              add [__r1],A
 0F77 0E0000            adc [__r0],0
 0F7A 52F9              mov A,[X-7]
 0F7C 0400              add [__r1],A
 0F7E 0E0000            adc [__r0],0
 0F81 52F8              mov A,[X-8]
 0F83 0400              add [__r1],A
 0F85 0E0000            adc [__r0],0
 0F88 5001              mov A,1
 0F8A 08                push A
 0F8B 5000              mov A,0
 0F8D 08                push A
 0F8E 5100              mov A,[__r0]
 0F90 08                push A
 0F91 5100              mov A,[__r1]
 0F93 08                push A
 0F94 7C0000            xcall __divmod_16X16_16
 0F97 38FE              add SP,-2
 0F99 18                pop A
 0F9A 5300              mov [__r1],A
 0F9C 18                pop A
 0F9D 50FF              mov A,-1
 0F9F 1200              sub A,[__r1]
 0FA1 5400              mov [X+0],A
 0FA3                   .dbline 1277
 0FA3           ;       
 0FA3           ;       // Talk to the servo.
 0FA3           ;       if(instruction == PING_SERVO)
 0FA3 3DFA01            cmp [X-6],1
 0FA6 B02D              jnz L349
 0FA8                   .dbline 1278
 0FA8           ;       {
 0FA8                   .dbline 1279
 0FA8           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0FA8 10                push X
 0FA9 50FF              mov A,-1
 0FAB 7C0000            xcall _SERVO_TX_PutChar
 0FAE 20                pop X
 0FAF                   .dbline 1280
 0FAF           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0FAF 10                push X
 0FB0 50FF              mov A,-1
 0FB2 7C0000            xcall _SERVO_TX_PutChar
 0FB5 20                pop X
 0FB6                   .dbline 1281
 0FB6           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0FB6 10                push X
 0FB7 52FC              mov A,[X-4]
 0FB9 7C0000            xcall _SERVO_TX_PutChar
 0FBC 20                pop X
 0FBD                   .dbline 1282
 0FBD           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0FBD 10                push X
 0FBE 52FB              mov A,[X-5]
 0FC0 7C0000            xcall _SERVO_TX_PutChar
 0FC3 20                pop X
 0FC4                   .dbline 1283
 0FC4           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0FC4 10                push X
 0FC5 52FA              mov A,[X-6]
 0FC7 7C0000            xcall _SERVO_TX_PutChar
 0FCA 20                pop X
 0FCB                   .dbline 1284
 0FCB           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0FCB 10                push X
 0FCC 5200              mov A,[X+0]
 0FCE 7C0000            xcall _SERVO_TX_PutChar
 0FD1 20                pop X
 0FD2                   .dbline 1285
 0FD2           ;       }
 0FD2 8039              xjmp L352
 0FD4           L349:
 0FD4                   .dbline 1287
 0FD4           ;       else
 0FD4           ;       {
 0FD4                   .dbline 1288
 0FD4           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0FD4 10                push X
 0FD5 50FF              mov A,-1
 0FD7 7C0000            xcall _SERVO_TX_PutChar
 0FDA 20                pop X
 0FDB                   .dbline 1289
 0FDB           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0FDB 10                push X
 0FDC 50FF              mov A,-1
 0FDE 7C0000            xcall _SERVO_TX_PutChar
 0FE1 20                pop X
 0FE2                   .dbline 1290
 0FE2           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0FE2 10                push X
 0FE3 52FC              mov A,[X-4]
 0FE5 7C0000            xcall _SERVO_TX_PutChar
 0FE8 20                pop X
 0FE9                   .dbline 1291
 0FE9           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0FE9 10                push X
 0FEA 52FB              mov A,[X-5]
 0FEC 7C0000            xcall _SERVO_TX_PutChar
 0FEF 20                pop X
 0FF0                   .dbline 1292
 0FF0           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0FF0 10                push X
 0FF1 52FA              mov A,[X-6]
 0FF3 7C0000            xcall _SERVO_TX_PutChar
 0FF6 20                pop X
 0FF7                   .dbline 1293
 0FF7           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0FF7 10                push X
 0FF8 52F9              mov A,[X-7]
 0FFA 7C0000            xcall _SERVO_TX_PutChar
 0FFD 20                pop X
 0FFE                   .dbline 1294
 0FFE           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0FFE 10                push X
 0FFF 52F8              mov A,[X-8]
 1001 7C0000            xcall _SERVO_TX_PutChar
 1004 20                pop X
 1005                   .dbline 1295
 1005           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 1005 10                push X
 1006 5200              mov A,[X+0]
 1008 7C0000            xcall _SERVO_TX_PutChar
 100B 20                pop X
 100C                   .dbline 1296
 100C           ;       }
 100C           L351:
 100C                   .dbline 1299
 100C           ;       
 100C           ;       // Wait for the transmission to finish.
 100C           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 100C           L352:
 100C                   .dbline 1299
 100C 10                push X
 100D 7C0000            xcall _SERVO_TX_bReadTxStatus
 1010 62D000            mov REG[0xd0],>__r0
 1013 20                pop X
 1014 5300              mov [__r0],A
 1016 470020            tst [__r0],32
 1019 AFF2              jz L351
 101B                   .dbline 1302
 101B           ;       
 101B           ;       // Make completely sure we're done.
 101B           ;       xmitWait();
 101B 900F              xcall _xmitWait
 101D                   .dbline 1305
 101D           ;       
 101D           ;       // Switch back to wait for a servo response.
 101D           ;       configToggle(INITIALIZE);
 101D 5000              mov A,0
 101F 08                push A
 1020 5008              mov A,8
 1022 08                push A
 1023 7C00B4            xcall _configToggle
 1026 38FE              add SP,-2
 1028                   .dbline -2
 1028           L348:
 1028 38FF              add SP,-1
 102A 20                pop X
 102B                   .dbline 0 ; func end
 102B 7F                ret
 102C                   .dbsym l checksum 0 c
 102C                   .dbsym l value -8 c
 102C                   .dbsym l address -7 c
 102C                   .dbsym l instruction -6 c
 102C                   .dbsym l length -5 c
 102C                   .dbsym l id -4 c
 102C                   .dbend
 102C                   .dbfunc e xmitWait _xmitWait fV
 102C           ;              i -> X+0
 102C           _xmitWait::
 102C                   .dbline -1
 102C 10                push X
 102D 4F                mov X,SP
 102E 3802              add SP,2
 1030                   .dbline 1309
 1030           ; }
 1030           ; 
 1030           ; void xmitWait(void)
 1030           ; {
 1030                   .dbline 1312
 1030           ;       int i;
 1030           ;       
 1030           ;       for(i = 0; i < 25; i++)
 1030 560100            mov [X+1],0
 1033 560000            mov [X+0],0
 1036           L355:
 1036                   .dbline 1313
 1036           ;       {
 1036                   .dbline 1315
 1036           ;               // Does nothing and wastes approximately 50 microseconds.
 1036           ;       }
 1036           L356:
 1036                   .dbline 1312
 1036 7701              inc [X+1]
 1038 0F0000            adc [X+0],0
 103B                   .dbline 1312
 103B 5201              mov A,[X+1]
 103D 1119              sub A,25
 103F 5200              mov A,[X+0]
 1041 3180              xor A,-128
 1043 1980              sbb A,(0 ^ 0x80)
 1045 CFF0              jc L355
 1047           X76:
 1047                   .dbline -2
 1047           L354:
 1047 38FE              add SP,-2
 1049 20                pop X
 104A                   .dbline 0 ; func end
 104A 7F                ret
 104B                   .dbsym l i 0 I
 104B                   .dbend
 104B                   .dbfunc e servoBootWait _servoBootWait fV
 104B           ;              i -> X+0
 104B           _servoBootWait::
 104B                   .dbline -1
 104B 10                push X
 104C 4F                mov X,SP
 104D 3802              add SP,2
 104F                   .dbline 1322
 104F           ; }
 104F           ; 
 104F           ; // This function wastes time while the servo that is attached to this controller boots up.
 104F           ; // Once that happens, communications should happen quickly and reliably.  The estimated boot
 104F           ; // time in testing was approximately 120 ms.
 104F           ; void servoBootWait(void)
 104F           ; {
 104F                   .dbline 1323
 104F           ;       int i = 0;                                      // Index integer used for looping.
 104F 560100            mov [X+1],0
 1052 560000            mov [X+0],0
 1055                   .dbline 1325
 1055           ; 
 1055           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1055 5000              mov A,0
 1057 08                push A
 1058 5008              mov A,8
 105A 08                push A
 105B 7C00B4            xcall _configToggle
 105E 38FE              add SP,-2
 1060                   .dbline 1328
 1060           ;       
 1060           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 1060           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 1060 560100            mov [X+1],0
 1063 560000            mov [X+0],0
 1066                   .dbline 1329
 1066           ;       {
 1066           L364:
 1066                   .dbline 1330
 1066           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1066                   .dbline 1330
 1066           L365:
 1066                   .dbline 1330
 1066 62D000            mov REG[0xd0],>_TIMEOUT
 1069 3C0000            cmp [_TIMEOUT],0
 106C B006              jnz X77
 106E 3C0100            cmp [_TIMEOUT+1],0
 1071 AFF4              jz L364
 1073           X77:
 1073                   .dbline 1331
 1073           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 1073 62D000            mov REG[0xd0],>_TIMEOUT
 1076 550100            mov [_TIMEOUT+1],0
 1079 550000            mov [_TIMEOUT],0
 107C                   .dbline 1332
 107C           ;       }
 107C           L361:
 107C                   .dbline 1328
 107C 7701              inc [X+1]
 107E 0F0000            adc [X+0],0
 1081                   .dbline 1328
 1081 5201              mov A,[X+1]
 1083 114B              sub A,75
 1085 5200              mov A,[X+0]
 1087 3180              xor A,-128
 1089 1980              sbb A,(0 ^ 0x80)
 108B CFDA              jc L365
 108D           X78:
 108D                   .dbline 1334
 108D           ;       
 108D           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 108D 10                push X
 108E 7C0000            xcall _INIT_TIMEOUT_Stop
 1091 20                pop X
 1092                   .dbline 1335
 1092           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 1092 62D000            mov REG[0xd0],>_TIMEOUT
 1095 550100            mov [_TIMEOUT+1],0
 1098 550000            mov [_TIMEOUT],0
 109B                   .dbline -2
 109B           L359:
 109B 38FE              add SP,-2
 109D 20                pop X
 109E                   .dbline 0 ; func end
 109E 7F                ret
 109F                   .dbsym l i 0 I
 109F                   .dbend
 109F                   .dbfunc e servoConfigWait _servoConfigWait fV
 109F           ;              i -> X+0
 109F           _servoConfigWait::
 109F                   .dbline -1
 109F 10                push X
 10A0 4F                mov X,SP
 10A1 3802              add SP,2
 10A3                   .dbline 1341
 10A3           ; }
 10A3           ; 
 10A3           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 10A3           ; // to take place.  This allows all other modules to initialize.
 10A3           ; void servoConfigWait(void)
 10A3           ; {
 10A3                   .dbline 1342
 10A3           ;       int i = 0;                                      // Index integer for looping purposes.
 10A3 560100            mov [X+1],0
 10A6 560000            mov [X+0],0
 10A9                   .dbline 1344
 10A9           ;       
 10A9           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 10A9 5000              mov A,0
 10AB 08                push A
 10AC 5008              mov A,8
 10AE 08                push A
 10AF 7C00B4            xcall _configToggle
 10B2 38FE              add SP,-2
 10B4                   .dbline 1349
 10B4           ;       
 10B4           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 10B4           ;       // their servos.  The reason we loop this many times is to allow for a possible worst
 10B4           ;       // case scenario of setup time to complete.
 10B4           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 10B4 560100            mov [X+1],0
 10B7 560000            mov [X+0],0
 10BA                   .dbline 1350
 10BA           ;       {
 10BA           L372:
 10BA                   .dbline 1351
 10BA           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 10BA                   .dbline 1351
 10BA           L373:
 10BA                   .dbline 1351
 10BA 62D000            mov REG[0xd0],>_TIMEOUT
 10BD 3C0000            cmp [_TIMEOUT],0
 10C0 B006              jnz X79
 10C2 3C0100            cmp [_TIMEOUT+1],0
 10C5 AFF4              jz L372
 10C7           X79:
 10C7                   .dbline 1352
 10C7           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 10C7 62D000            mov REG[0xd0],>_TIMEOUT
 10CA 550100            mov [_TIMEOUT+1],0
 10CD 550000            mov [_TIMEOUT],0
 10D0                   .dbline 1353
 10D0           ;       }
 10D0           L369:
 10D0                   .dbline 1349
 10D0 7701              inc [X+1]
 10D2 0F0000            adc [X+0],0
 10D5                   .dbline 1349
 10D5 5201              mov A,[X+1]
 10D7 1114              sub A,20
 10D9 5200              mov A,[X+0]
 10DB 3180              xor A,-128
 10DD 1980              sbb A,(0 ^ 0x80)
 10DF CFDA              jc L373
 10E1           X80:
 10E1                   .dbline 1355
 10E1           ;       
 10E1           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 10E1 10                push X
 10E2 7C0000            xcall _INIT_TIMEOUT_Stop
 10E5 20                pop X
 10E6                   .dbline 1356
 10E6           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 10E6 62D000            mov REG[0xd0],>_TIMEOUT
 10E9 550100            mov [_TIMEOUT+1],0
 10EC 550000            mov [_TIMEOUT],0
 10EF                   .dbline 1358
 10EF           ; 
 10EF           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 10EF 5000              mov A,0
 10F1 08                push A
 10F2 5001              mov A,1
 10F4 08                push A
 10F5 7C00B4            xcall _configToggle
 10F8 38FE              add SP,-2
 10FA                   .dbline -2
 10FA           L367:
 10FA 38FE              add SP,-2
 10FC 20                pop X
 10FD                   .dbline 0 ; func end
 10FD 7F                ret
 10FE                   .dbsym l i 0 I
 10FE                   .dbend
 10FE                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 10FE           _TX_01234_TIMEOUT_ISR::
 10FE                   .dbline -1
 10FE 71C0              or F,-64
 1100 08                push A
 1101 5DD0              mov A,REG[0xd0]
 1103 08                push A
 1104                   .dbline 1366
 1104           ; }
 1104           ; 
 1104           ; // This timeout ISR is for waiting before a transmission is made from this module.
 1104           ; // This is to give all the other modules a chance to set up and clear their buffers.
 1104           ; // It is currently set so that there is 1 ms of down time between the last transmission
 1104           ; // and this module's transmission.
 1104           ; void TX_01234_TIMEOUT_ISR(void)
 1104           ; {
 1104                   .dbline 1367
 1104           ;       TIMEOUT = 1;    // Set the timeout flag.
 1104 62D000            mov REG[0xd0],>_TIMEOUT
 1107 550101            mov [_TIMEOUT+1],1
 110A 550000            mov [_TIMEOUT],0
 110D                   .dbline 1368
 110D           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 110D 62DAFD            mov REG[0xda],-3
 1110                   .dbline -2
 1110           L375:
 1110 18                pop A
 1111 60D0              mov REG[208],A
 1113 18                pop A
 1114                   .dbline 0 ; func end
 1114 7E                reti
 1115                   .dbend
 1115                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 1115           _HELLO_TIMEOUT_ISR::
 1115                   .dbline -1
 1115 71C0              or F,-64
 1117 08                push A
 1118 5DD0              mov A,REG[0xd0]
 111A 08                push A
 111B                   .dbline 1373
 111B           ; }
 111B           ; 
 111B           ; // This is the ISR for a hello response timeout.
 111B           ; void HELLO_TIMEOUT_ISR(void)
 111B           ; {
 111B                   .dbline 1374
 111B           ;       TIMEOUT = 1;    // Set the timeout flag.
 111B 62D000            mov REG[0xd0],>_TIMEOUT
 111E 550101            mov [_TIMEOUT+1],1
 1121 550000            mov [_TIMEOUT],0
 1124                   .dbline 1375
 1124           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 1124 62DAFD            mov REG[0xda],-3
 1127                   .dbline -2
 1127           L376:
 1127 18                pop A
 1128 60D0              mov REG[208],A
 112A 18                pop A
 112B                   .dbline 0 ; func end
 112B 7E                reti
 112C                   .dbend
 112C                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 112C           _CHILD_1_TIMEOUT_ISR::
 112C                   .dbline -1
 112C 71C0              or F,-64
 112E 08                push A
 112F 5DD0              mov A,REG[0xd0]
 1131 08                push A
 1132                   .dbline 1380
 1132           ; }
 1132           ; 
 1132           ; // These remaining ISRs are for all the child timeout scenarios.
 1132           ; void CHILD_1_TIMEOUT_ISR(void)
 1132           ; {
 1132                   .dbline 1381
 1132           ;       TIMEOUT = 1;    // Set the timeout flag.
 1132 62D000            mov REG[0xd0],>_TIMEOUT
 1135 550101            mov [_TIMEOUT+1],1
 1138 550000            mov [_TIMEOUT],0
 113B                   .dbline 1382
 113B           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 113B 62DAFD            mov REG[0xda],-3
 113E                   .dbline -2
 113E           L377:
 113E 18                pop A
 113F 60D0              mov REG[208],A
 1141 18                pop A
 1142                   .dbline 0 ; func end
 1142 7E                reti
 1143                   .dbend
 1143                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 1143           _CHILD_2_TIMEOUT_ISR::
 1143                   .dbline -1
 1143 71C0              or F,-64
 1145 08                push A
 1146 5DD0              mov A,REG[0xd0]
 1148 08                push A
 1149                   .dbline 1386
 1149           ; }
 1149           ; 
 1149           ; void CHILD_2_TIMEOUT_ISR(void)
 1149           ; {
 1149                   .dbline 1387
 1149           ;       TIMEOUT = 1;    // Set the timeout flag.
 1149 62D000            mov REG[0xd0],>_TIMEOUT
 114C 550101            mov [_TIMEOUT+1],1
 114F 550000            mov [_TIMEOUT],0
 1152                   .dbline 1388
 1152           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 1152 62DAFD            mov REG[0xda],-3
 1155                   .dbline -2
 1155           L378:
 1155 18                pop A
 1156 60D0              mov REG[208],A
 1158 18                pop A
 1159                   .dbline 0 ; func end
 1159 7E                reti
 115A                   .dbend
 115A                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 115A           _CHILD_3_TIMEOUT_ISR::
 115A                   .dbline -1
 115A 71C0              or F,-64
 115C 08                push A
 115D 5DD0              mov A,REG[0xd0]
 115F 08                push A
 1160                   .dbline 1392
 1160           ; }
 1160           ; 
 1160           ; void CHILD_3_TIMEOUT_ISR(void)
 1160           ; {
 1160                   .dbline 1393
 1160           ;       TIMEOUT = 1;    // Set the timeout flag.
 1160 62D000            mov REG[0xd0],>_TIMEOUT
 1163 550101            mov [_TIMEOUT+1],1
 1166 550000            mov [_TIMEOUT],0
 1169                   .dbline 1394
 1169           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 1169 62DAFD            mov REG[0xda],-3
 116C                   .dbline -2
 116C           L379:
 116C 18                pop A
 116D 60D0              mov REG[208],A
 116F 18                pop A
 1170                   .dbline 0 ; func end
 1170 7E                reti
 1171                   .dbend
 1171                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 1171           _CHILD_4_TIMEOUT_ISR::
 1171                   .dbline -1
 1171 71C0              or F,-64
 1173 08                push A
 1174 5DD0              mov A,REG[0xd0]
 1176 08                push A
 1177                   .dbline 1398
 1177           ; }
 1177           ; 
 1177           ; void CHILD_4_TIMEOUT_ISR(void)
 1177           ; {
 1177                   .dbline 1399
 1177           ;       TIMEOUT = 1;    // Set the timeout flag.
 1177 62D000            mov REG[0xd0],>_TIMEOUT
 117A 550101            mov [_TIMEOUT+1],1
 117D 550000            mov [_TIMEOUT],0
 1180                   .dbline 1400
 1180           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 1180 62DAFD            mov REG[0xda],-3
 1183                   .dbline -2
 1183           L380:
 1183 18                pop A
 1184 60D0              mov REG[208],A
 1186 18                pop A
 1187                   .dbline 0 ; func end
 1187 7E                reti
 1188                   .dbend
 1188                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 1188           _INIT_TIMEOUT_ISR::
 1188                   .dbline -1
 1188 71C0              or F,-64
 118A 08                push A
 118B 5DD0              mov A,REG[0xd0]
 118D 08                push A
 118E                   .dbline 1404
 118E           ; }
 118E           ; 
 118E           ; void INIT_TIMEOUT_ISR(void)
 118E           ; {
 118E                   .dbline 1405
 118E           ;       TIMEOUT = 1;    // Set the timeout flag.
 118E 62D000            mov REG[0xd0],>_TIMEOUT
 1191 550101            mov [_TIMEOUT+1],1
 1194 550000            mov [_TIMEOUT],0
 1197                   .dbline 1406
 1197           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 1197 62DAFD            mov REG[0xda],-3
 119A                   .dbline -2
 119A           L381:
 119A 18                pop A
 119B 60D0              mov REG[208],A
 119D 18                pop A
 119E                   .dbline 0 ; func end
 119E 7E                reti
 119F                   .dbend
 119F                   .dbfunc e WAIT_RECV_TIMEOUT_ISR _WAIT_RECV_TIMEOUT_ISR fV
 119F           _WAIT_RECV_TIMEOUT_ISR::
 119F                   .dbline -1
 119F 71C0              or F,-64
 11A1 08                push A
 11A2 5DD0              mov A,REG[0xd0]
 11A4 08                push A
 11A5                   .dbline 1410
 11A5           ; }
 11A5           ; 
 11A5           ; void WAIT_RECV_TIMEOUT_ISR(void)
 11A5           ; {
 11A5                   .dbline 1411
 11A5           ;       TIMEOUT = 1;    // Set the timeout flag.
 11A5 62D000            mov REG[0xd0],>_TIMEOUT
 11A8 550101            mov [_TIMEOUT+1],1
 11AB 550000            mov [_TIMEOUT],0
 11AE                   .dbline 1412
 11AE           ;       M8C_ClearIntFlag(INT_CLR0,WAIT_RECV_TIMEOUT_INT_MASK);
 11AE 62DAFD            mov REG[0xda],-3
 11B1                   .dbline -2
 11B1           L382:
 11B1 18                pop A
 11B2 60D0              mov REG[208],A
 11B4 18                pop A
 11B5                   .dbline 0 ; func end
 11B5 7E                reti
 11B6                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c

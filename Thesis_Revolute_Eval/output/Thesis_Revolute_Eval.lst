0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0116) ; Generated by PSoC Designer 5.0.985.0
                                   (0117) ;
                                   (0118) ;@Id: boot.tpl#895 @
0004: 30       HALT                (0119) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0120) ;  FILENAME:   boot.asm
                                   (0121) ;  VERSION:    4.18
                                   (0122) ;  DATE:       28 June 2007
0008: 7E       RETI                (0123) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0124) ;  DESCRIPTION:
                                   (0125) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0126) ;
000C: 7E       RETI                (0127) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0128) ;
                                   (0129) ; NOTES:
                                   (0130) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0131) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0132) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0133) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0134) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0135) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0136) ;
                                   (0137) ;=============================================================================
                                   (0138) 
0018: 7E       RETI                (0139) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0140) include "m8c.inc"			;Part specific file
                                   (0141) include "m8ssc.inc"			;Part specific file
                                   (0142) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0143) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0144) ;--------------------------------------
                                   (0145) ; Export Declarations
                                   (0146) ;--------------------------------------
0020: 7E       RETI                (0147) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0148) export __Start
                                   (0149) IF	(TOOLCHAIN & HITECH)
0024: 7D 32 00 LJMP  Dispatch_INTERRUPT_9(0150) ELSE
0027: 7E       RETI                (0151) export __bss_start
                                   (0152) export __data_start
                                   (0153) export __idata_start
0028: 7D 31 6A LJMP  Dispatch_INTERRUPT_10(0154) export __func_lit_start
002B: 7E       RETI                (0155) export __text_start
                                   (0156) ENDIF
                                   (0157) export  _bGetPowerSetting
002C: 7D 31 D6 LJMP  Dispatch_INTERRUPT_11(0158) export   bGetPowerSetting
002F: 7E       RETI                (0159) 
                                   (0160) 
                                   (0161) ;--------------------------------------
                                   (0162) ; Optimization flags
0030: 7E       RETI                (0163) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0164) ;
                                   (0165) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0166) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0167) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0168) 
                                   (0169) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 15 75 LJMP  0x1575        (0170) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0171) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0172) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0173) ;
003C: 7D 14 1C LJMP  0x141C        (0174) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0175) ; The C compiler will customize the startup code - it's not required here
                                   (0176) 
                                   (0177) C_LANGUAGE_SUPPORT:              equ 0
                                   (0178) ELSE
0040: 7E       RETI                (0179) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0180) ENDIF
                                   (0181) 
                                   (0182) 
0044: 7E       RETI                (0183) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0184) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0185) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0186) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0187) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0188) ;
                                   (0189) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0190) ;                invoking main
004C: 7E       RETI                (0191) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0192) ;               the time code in main starts executing.
                                   (0193) ;
                                   (0194) WAIT_FOR_32K:                    equ 1
0050: 7E       RETI                (0195) 
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0196) 
                                   (0197) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0198) ; to invoke the user's _main code. If _main executes a return instruction,
0054: 7E       RETI                (0199) ; boot provides an infinite loop. By changing the following equate from zero
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0200) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0201) ; bytes on the stack which are otherwise required for the return address. If
                                   (0202) ; this option is enabled, _main must not return. (Beginning with the 4.2
0058: 7E       RETI                (0203) ; release, the C compiler automatically places an infinite loop at the end
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0204) ; of main, rather than a return instruction.)
                                   (0205) ;
                                   (0206) ENABLE_LJMP_TO_MAIN:             equ 0
005C: 7E       RETI                (0207) 
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0208) 
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ; Interrupt Vector Table
0060: 7E       RETI                (0211) ;-----------------------------------------------------------------------------
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0212) ;
                                   (0213) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0214) ; a jump instruction to an ISR (Interrupt Service Routine), although
0064: 7E       RETI                (0215) ; very short ISRs could be encoded within the table itself. Normally,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0216) ; vector jump targets are modified automatically according to the user
                                   (0217) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0218) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0219) ; configuration files. If you need to hard code a vector, update the
                                   (0220) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0221) ; of this file.
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) 
                                   (0224)     AREA TOP (ROM, ABS, CON)
                                   (0225) 
                                   (0226)     org   0                        ;Reset Interrupt Vector
                                   (0227) IF	(TOOLCHAIN & HITECH)
                                   (0228) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0229) ELSE
                                   (0230)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0231) ENDIF
                                   (0232) 
                                   (0233)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0234)     halt                           ;Stop execution if power falls too low
0068: 71 10    OR    F,16          (0235) 
006A: 62 FA 00 MOV   REG[250],0    (0236)     org   08h                      ;Analog Column 0 Interrupt Vector
006D: 62 E3 87 MOV   REG[227],135  (0237)     // call	void_handler
0070: 70 EF    AND   F,239         (0238)     reti
                                   (0239) 
                                   (0240)     org   0Ch                      ;Analog Column 1 Interrupt Vector
0072: 50 20    MOV   A,32          (0241)     // call	void_handler
0074: 28       ROMX                (0242)     reti
0075: 50 40    MOV   A,64          (0243) 
0077: 28       ROMX                (0244)     org   10h                      ;Analog Column 2 Interrupt Vector
0078: 50 60    MOV   A,96          (0245)     // call	void_handler
007A: 28       ROMX                (0246)     reti
                                   (0247) 
                                   (0248)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0249)     // call	void_handler
                                   (0250)     reti
                                   (0251) 
                                   (0252)     org   18h                      ;VC3 Interrupt Vector
                                   (0253)     // call	void_handler
                                   (0254)     reti
                                   (0255) 
007B: 41 FE FB AND   REG[254],251  (0256)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0257)     // call	void_handler
                                   (0258)     reti
                                   (0259) 
                                   (0260)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0261)     // call	void_handler
                                   (0262)     reti
                                   (0263) 
                                   (0264)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0265)     ljmp	Dispatch_INTERRUPT_9
007E: 50 80    MOV   A,128         (0266)     reti
0080: 4E       SWAP  SP,A          (0267) 
                                   (0268)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0269)     ljmp	Dispatch_INTERRUPT_10
                                   (0270)     reti
                                   (0271) 
                                   (0272)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0273)     ljmp	Dispatch_INTERRUPT_11
                                   (0274)     reti
                                   (0275) 
                                   (0276)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0277)     // call	void_handler
                                   (0278)     reti
                                   (0279) 
                                   (0280)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0281)     // call	void_handler
                                   (0282)     reti
                                   (0283) 
                                   (0284)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0285)     ljmp	_HELLO_3_ISR
                                   (0286)     reti
                                   (0287) 
                                   (0288)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0289)     ljmp	_HELLO_4_ISR
                                   (0290)     reti
                                   (0291) 
                                   (0292)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                   (0293)     // call	void_handler
                                   (0294)     reti
                                   (0295) 
                                   (0296)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0297)     // call	void_handler
0081: 55 F8 00 MOV   [248],0       (0298)     reti
0084: 55 F9 00 MOV   [249],0       (0299) 
                                   (0300)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                   (0301)     // call	void_handler
                                   (0302)     reti
                                   (0303) 
                                   (0304)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                   (0305)     // call	void_handler
                                   (0306)     reti
                                   (0307) 
                                   (0308)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                   (0309)     // call	void_handler
                                   (0310)     reti
                                   (0311) 
                                   (0312)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0313)     // call	void_handler
                                   (0314)     reti
                                   (0315) 
                                   (0316)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0317)     // call	void_handler
                                   (0318)     reti
                                   (0319) 
                                   (0320)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0321)     // call	void_handler
                                   (0322)     reti
0087: 71 10    OR    F,16          (0323) 
0089: 62 E0 02 MOV   REG[224],2    (0324)     org   60h                      ;PSoC I2C Interrupt Vector
008C: 70 EF    AND   F,239         (0325)     // call	void_handler
008E: 62 E3 38 MOV   REG[227],56   (0326)     reti
                                   (0327) 
                                   (0328)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0329)     // call	void_handler
                                   (0330)     reti
                                   (0331) 
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;  Start of Execution.
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0336) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0337) ;
                                   (0338) 
                                   (0339) IF	(TOOLCHAIN & HITECH)
                                   (0340)  	AREA PD_startup(CODE, REL, CON)
                                   (0341) ELSE
                                   (0342)     org 68h
                                   (0343) ENDIF
                                   (0344) __Start:
                                   (0345) 
                                   (0346)     ; initialize SMP values for voltage stabilization, if required,
                                   (0347)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0348)     ; least for now. 
                                   (0349)     ;
                                   (0350)     M8C_SetBank1
                                   (0351)     mov reg[0FAh], 0				;Reset flash location
                                   (0352)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0353)     M8C_SetBank0
                                   (0354) 
                                   (0355)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
                                   (0356)     mov   A, 20h
0091: 62 71 05 MOV   REG[113],5    (0357)     romx
0094: 62 75 05 MOV   REG[117],5    (0358)     mov   A, 40h
0097: 62 79 05 MOV   REG[121],5    (0359)     romx
009A: 62 7D 05 MOV   REG[125],5    (0360)     mov   A, 60h
                                   (0361)     romx
                                   (0362)     ; %45%20%46%46% End workaround
                                   (0363) 
                                   (0364) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0365)     M8C_EnableWatchDog
                                   (0366) ENDIF
                                   (0367) 
                                   (0368) IF ( SELECT_32K )
                                   (0369)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0370) ELSE
                                   (0371)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0372) ENDIF
                                   (0373) 
                                   (0374)     ;---------------------------
                                   (0375)     ; Set up the Temporary stack
                                   (0376)     ;---------------------------
                                   (0377)     ; A temporary stack is set up for the SSC instructions.
                                   (0378)     ; The real stack start will be assigned later.
                                   (0379)     ;
                                   (0380) _stack_start:          equ 80h
                                   (0381)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0382)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0383) 
                                   (0384)     ;-----------------------------------------------
                                   (0385)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0386)     ;-----------------------------------------------
                                   (0387) 
009D: 62 D1 07 MOV   REG[209],7    (0388) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00A0: 50 00    MOV   A,0           (0389)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00A2: 4E       SWAP  SP,A          (0390)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00A3: 62 D3 07 MOV   REG[211],7    (0391)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00A6: 62 D0 00 MOV   REG[208],0    (0392)  ELSE                                          ; *** 12MHZ Main Oscillator ***
00A9: 62 D5 00 MOV   REG[213],0    (0393)   IF ( AGND_BYPASS )
00AC: 62 D4 00 MOV   REG[212],0    (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0396)     ; bit in the write-only BDG_TR register. Recalculate the register
00AF: 71 C0    OR    F,192         (0397)     ; value using the proper trim values.
                                   (0398)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0399)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0400)   ENDIF
                                   (0401)  ENDIF
                                   (0402) ENDIF ; 5.0 V Operation
                                   (0403) 
                                   (0404) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0405)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0406)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0407)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0408)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0409)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0410)  ENDIF
                                   (0411) ENDIF ; 3.3 Volt Operation
                                   (0412) 
                                   (0413)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
                                   (0414)     mov  [bSSC_KEYSP], 0
00B1: 7C 06 56 LCALL 0x0656        (0415) 
                                   (0416)     ;---------------------------------------
                                   (0417)     ; Initialize Crystal Oscillator and PLL
                                   (0418)     ;---------------------------------------
                                   (0419) 
                                   (0420) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0421)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0422)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0423)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0424)     ; the ECO to stabilize.
                                   (0425)     ;
                                   (0426)     M8C_SetBank1
                                   (0427)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0428)     M8C_SetBank0
                                   (0429)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0430)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0431)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0432) .WaitFor1s:
                                   (0433)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0434)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0435)                                           ;   since interrupts are not globally enabled
                                   (0436) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0437)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0438)     M8C_SetBank1
                                   (0439)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0440)     M8C_SetBank0
                                   (0441)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0442) 
                                   (0443) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0444) 
                                   (0445) IF ( PLL_MODE )
                                   (0446)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
00B4: 62 D0 00 MOV   REG[208],0    (0447)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0448)     ;
                                   (0449)     M8C_SetBank1
                                   (0450)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0451)     M8C_SetBank0
                                   (0452)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0453)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
00B7: 50 06    MOV   A,6           (0454) 
00B9: 57 54    MOV   X,84          (0455) .WaitFor16ms:
00BB: 08       PUSH  A             (0456)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00BC: 28       ROMX                (0457)     jz   .WaitFor16ms
00BD: 53 CD    MOV   [__r0],A      (0458)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00BF: 18       POP   A             (0459)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00C0: 75       INC   X             (0460)     M8C_SetBank0
00C1: 09 00    ADC   A,0           (0461) 
00C3: 28       ROMX                (0462) IF      ( WAIT_FOR_32K )
00C4: 4B       SWAP  A,X           (0463) ELSE ; !( WAIT_FOR_32K )
00C5: 51 CD    MOV   A,[205]       (0464)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                   (0465)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
00C7: 80 04    JMP   0x00CC        (0466) ENDIF ;(WAIT_FOR_32K)
                                   (0467) ENDIF ;(PLL_MODE)
                                   (0468) 
                                   (0469)     ;------------------------
                                   (0470)     ; Close CT leakage path.
                                   (0471)     ;------------------------
                                   (0472)     mov   reg[ACB00CR0], 05h
                                   (0473)     mov   reg[ACB01CR0], 05h
                                   (0474)     mov   reg[ACB02CR0], 05h
                                   (0475)     mov   reg[ACB03CR0], 05h
                                   (0476) 
                                   (0477) 
                                   (0478) IF	(TOOLCHAIN & HITECH)
                                   (0479)     ;---------------------------------------------
                                   (0480)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0481)     ;---------------------------------------------
                                   (0482) 	global		__Lstackps
                                   (0483) 	mov     a,low __Lstackps
00C9: 75       INC   X             (0484) 	swap    a,sp
00CA: 09 00    ADC   A,0           (0485) 
                                   (0486) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0487)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0488)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0489)     RAM_SETPAGE_CUR 0
00CC: 62 E3 00 MOV   REG[227],0    (0490)     RAM_SETPAGE_MVW 0
00CF: 08       PUSH  A             (0491)     RAM_SETPAGE_MVR 0
00D0: 28       ROMX                (0492)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00D1: 60 D5    MOV   REG[213],A    (0493)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00D3: 74       INC   A             (0494)     ELSE
00D4: A0 4B    JZ    0x0120        (0495)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00D6: 18       POP   A             (0496)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00D7: 75       INC   X             (0497) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00D8: 09 00    ADC   A,0           (0498) ELSE
00DA: 08       PUSH  A             (0499)     ;---------------------------------------------
00DB: 28       ROMX                (0500)     ; ImageCraft Enter the Large Memory Model, if applicable
00DC: 53 CD    MOV   [__r0],A      (0501)     ;---------------------------------------------
00DE: 18       POP   A             (0502) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00DF: 75       INC   X             (0503)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00E0: 09 00    ADC   A,0           (0504)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00E2: 08       PUSH  A             (0505)     swap  A, SP
00E3: 28       ROMX                (0506)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00E4: A0 1C    JZ    0x0101        (0507)     RAM_SETPAGE_CUR 0
00E6: 53 CC    MOV   [__r1],A      (0508)     RAM_SETPAGE_MVW 0
00E8: 18       POP   A             (0509)     RAM_SETPAGE_MVR 0
                                   (0510) 
                                   (0511)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0512)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0513)   ELSE
                                   (0514)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0515)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0516) ELSE
00E9: 75       INC   X             (0517)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00EA: 09 00    ADC   A,0           (0518)     swap  SP, A
00EC: 08       PUSH  A             (0519) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00ED: 28       ROMX                (0520) ENDIF ;	TOOLCHAIN
00EE: 3F CD    MVI   [__r0],A      (0521) 
00F0: 47 CD FF TST   [205],255     (0522)     ;-------------------------
00F3: B0 06    JNZ   0x00FA        (0523)     ; Load Base Configuration
00F5: 5D D5    MOV   A,REG[213]    (0524)     ;-------------------------
00F7: 74       INC   A             (0525)     ; Load global parameter settings and load the user modules in the
00F8: 60 D5    MOV   REG[213],A    (0526)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0527)     ; to minimize start up time; (2) We may still need to play with the
00FA: 18       POP   A             (0528)     ; Sleep Timer.
00FB: 7A CC    DEC   [__r1]        (0529)     ;
00FD: BF EB    JNZ   0x00E9        (0530)     lcall LoadConfigInit
00FF: 8F C9    JMP   0x00C9        (0531) 
                                   (0532)     ;-----------------------------------
                                   (0533)     ; Initialize C Run-Time Environment
0101: 18       POP   A             (0534)     ;-----------------------------------
0102: 75       INC   X             (0535) IF ( C_LANGUAGE_SUPPORT )
0103: 09 00    ADC   A,0           (0536) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0105: 08       PUSH  A             (0537)     mov  A,0                           ; clear the 'bss' segment to zero
0106: 28       ROMX                (0538)     mov  [__r0],<__bss_start
0107: 53 CC    MOV   [__r1],A      (0539) BssLoop:
0109: 50 00    MOV   A,0           (0540)     cmp  [__r0],<__bss_end
                                   (0541)     jz   BssDone
                                   (0542)     mvi  [__r0],A
                                   (0543)     jmp  BssLoop
                                   (0544) BssDone:
                                   (0545)     mov  A,>__idata_start              ; copy idata to data segment
010B: 3F CD    MVI   [__r0],A      (0546)     mov  X,<__idata_start
010D: 47 CD FF TST   [205],255     (0547)     mov  [__r0],<__data_start
0110: B0 08    JNZ   0x0119        (0548) IDataLoop:
0112: 5D D5    MOV   A,REG[213]    (0549)     cmp  [__r0],<__data_end
0114: 74       INC   A             (0550)     jz   C_RTE_Done
0115: 60 D5    MOV   REG[213],A    (0551)     push A
0117: 50 00    MOV   A,0           (0552)     romx
                                   (0553)     mvi  [__r0],A
0119: 7A CC    DEC   [__r1]        (0554)     pop  A
011B: BF EF    JNZ   0x010B        (0555)     inc  X
011D: 18       POP   A             (0556)     adc  A,0
011E: 8F AA    JMP   0x00C9        (0557)     jmp  IDataLoop
                                   (0558) 
                                   (0559) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0120: 18       POP   A             (0560) 
                                   (0561) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0562)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0563)                                        ; to use the Virtual Register page.
                                   (0564) 
                                   (0565)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0566)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0567)     ; text segment and may have been relocated by the Code Compressor.
                                   (0568)     ;
                                   (0569)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0570)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0571)     push  A
                                   (0572)     romx                               ; get the MSB of xidata's address
                                   (0573)     mov   [__r0], A
                                   (0574)     pop   A
                                   (0575)     inc   X
                                   (0576)     adc   A, 0
                                   (0577)     romx                               ; get the LSB of xidata's address
                                   (0578)     swap  A, X
                                   (0579)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0580)                                        ;   XIData structure list in flash
                                   (0581)     jmp   .AccessStruct
                                   (0582) 
                                   (0583)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0584)     ; values of C variables. Each structure contains 3 member elements.
                                   (0585)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0586)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0587)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0588)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0589)     ; value in the second member element, an unsigned byte:
                                   (0590)     ; (1) If the value of the second element is non-zero, it represents
                                   (0591)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0592)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0593)     ; the bytes are copied to the block of RAM.
                                   (0594)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0595)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0596)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0597) 
                                   (0598) .AccessNextStructLoop:
                                   (0599)     inc   X                            ; pXIData++
                                   (0600)     adc   A, 0
0121: 71 10    OR    F,16          (0601) .AccessStruct:                         ; Entry point for first block
                                   (0602)     ;
                                   (0603)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0604)     ;
                                   (0605)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0606)     push  A
                                   (0607)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0608)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
0123: 43 E3 20 OR    REG[227],32   (0609)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0610)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0611)     pop   A                            ; restore pXIData to [A,X]
                                   (0612)     inc   X                            ; pXIData++
                                   (0613)     adc   A, 0
0126: 70 EF    AND   F,239         (0614)     push  A
                                   (0615)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0616)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0617)     pop   A                            ; restore pXIData to [A,X]
                                   (0618)     inc   X                            ; pXIData++ (point to size)
                                   (0619)     adc   A, 0
                                   (0620)     push  A
                                   (0621)     romx                               ; Get the size (CPU.A <- *pXIData)
                                   (0622)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
0128: 62 E0 00 MOV   REG[224],0    (0623)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0624)     pop   A                            ; restore pXIData to [A,X]
                                   (0625) 
                                   (0626) .CopyNextByteLoop:
                                   (0627)     ; For each byte in the structure's array member, copy from flash to RAM.
012B: 71 10    OR    F,16          (0628)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
012D: 62 E0 03 MOV   REG[224],3    (0629)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
0130: 43 E7 80 OR    REG[231],128  (0630)     ;         __r1 holds a non-zero count of the number of bytes remaining.
0133: 70 EF    AND   F,239         (0631)     ;
                                   (0632)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0633)     adc   A, 0
                                   (0634)     push  A
                                   (0635)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                   (0636)     mvi   [__r0], A                    ; Transfer the data to RAM
0135: 62 E2 00 MOV   REG[226],0    (0637)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0638)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0639)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0640)     inc   A
                                   (0641)     mov   reg[ MVW_PP], A
                                   (0642) .CopyLoopTail:
                                   (0643)     pop   A                            ; restore pXIData to [A,X]
                                   (0644)     dec   [__r1]                       ; End of this array in flash?
0138: 7C 20 64 LCALL _main         (0645)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0646)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
013B: 8F FF    JMP   0x013B        (0647) 
                                   (0648) .ClearRAMBlockToZero:
                                   (0649)     pop   A                            ; restore pXIData to [A,X]
                                   (0650)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0651)     adc   A, 0
                                   (0652)     push  A
                                   (0653)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0654)     mov   [__r1], A                    ; Initialize downcounter
                                   (0655)     mov   A, 0                         ; Initialize source data
                                   (0656) 
                                   (0657) .ClearRAMBlockLoop:
                                   (0658)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0659)     ;         __r1 holds a non-zero count of the number of bytes remaining.
013D: 50 10    MOV   A,16          (0660)     ;
045C: 71 10    OR    F,16          (0661)     mvi   [__r0], A                    ; Clear a byte

FILE: lib\psocconfigtbl.asm
045E: 62 00 1E MOV   REG[0],30     (0698) ; Generated by PSoC Designer 5.0.985.0
0461: 62 01 E1 MOV   REG[1],225    (0699) ;
0464: 70 EF    AND   F,239         (0700) include "m8c.inc"
0466: 62 03 E0 MOV   REG[3],224    (0701) ;  Personalization tables 
0469: 62 02 1F MOV   REG[2],31     (0702) export LoadConfigTBL_waiting_Bank1
046C: 71 10    OR    F,16          (0703) export LoadConfigTBL_waiting_Bank0
046E: 62 02 00 MOV   REG[2],0      (0704) export LoadConfigTBL_waiting_Ordered
0471: 62 03 00 MOV   REG[3],0      (0705) export UnloadConfigTBL_waiting_Bank1
0474: 70 EF    AND   F,239         (0706) export UnloadConfigTBL_waiting_Bank0
0476: 62 01 00 MOV   REG[1],0      (0707) export ReloadConfigTBL_waiting_Bank1
0479: 71 10    OR    F,16          (0708) export ReloadConfigTBL_waiting_Bank0
047B: 62 04 A8 MOV   REG[4],168    (0709) export LoadConfigTBL_hello_Bank1
047E: 62 05 57 MOV   REG[5],87     (0710) export LoadConfigTBL_hello_Bank0
0481: 70 EF    AND   F,239         (0711) export UnloadConfigTBL_hello_Bank1
0483: 62 07 57 MOV   REG[7],87     (0712) export UnloadConfigTBL_hello_Bank0
0486: 62 06 00 MOV   REG[6],0      (0713) export LoadConfigTBL_initial_Bank1
0489: 71 10    OR    F,16          (0714) export LoadConfigTBL_initial_Bank0
048B: 62 06 00 MOV   REG[6],0      (0715) export UnloadConfigTBL_initial_Bank1
048E: 62 07 00 MOV   REG[7],0      (0716) export UnloadConfigTBL_initial_Bank0
0491: 70 EF    AND   F,239         (0717) export LoadConfigTBL_my_response_Bank1
0493: 62 05 00 MOV   REG[5],0      (0718) export LoadConfigTBL_my_response_Bank0
0496: 71 10    OR    F,16          (0719) export UnloadConfigTBL_my_response_Bank1
0498: 62 08 01 MOV   REG[8],1      (0720) export UnloadConfigTBL_my_response_Bank0
049B: 62 09 FE MOV   REG[9],254    (0721) export LoadConfigTBL_response1_Bank1
049E: 70 EF    AND   F,239         (0722) export LoadConfigTBL_response1_Bank0
04A0: 62 0B FE MOV   REG[11],254   (0723) export UnloadConfigTBL_response1_Bank1
04A3: 62 0A 00 MOV   REG[10],0     (0724) export UnloadConfigTBL_response1_Bank0
04A6: 71 10    OR    F,16          (0725) export LoadConfigTBL_response2_Bank1
04A8: 62 0A 00 MOV   REG[10],0     (0726) export LoadConfigTBL_response2_Bank0
04AB: 62 0B 00 MOV   REG[11],0     (0727) export UnloadConfigTBL_response2_Bank1
04AE: 70 EF    AND   F,239         (0728) export UnloadConfigTBL_response2_Bank0
04B0: 62 09 00 MOV   REG[9],0      (0729) export LoadConfigTBL_response3_Bank1
04B3: 71 10    OR    F,16          (0730) export LoadConfigTBL_response3_Bank0
04B5: 62 0C 00 MOV   REG[12],0     (0731) export UnloadConfigTBL_response3_Bank1
04B8: 62 0D 00 MOV   REG[13],0     (0732) export UnloadConfigTBL_response3_Bank0
04BB: 70 EF    AND   F,239         (0733) export LoadConfigTBL_response4_Bank1
04BD: 62 0F 00 MOV   REG[15],0     (0734) export LoadConfigTBL_response4_Bank0
04C0: 62 0E 00 MOV   REG[14],0     (0735) export UnloadConfigTBL_response4_Bank1
04C3: 71 10    OR    F,16          (0736) export UnloadConfigTBL_response4_Bank0
04C5: 62 0E 00 MOV   REG[14],0     (0737) export LoadConfigTBL_servo_transmit_Bank1
04C8: 62 0F 00 MOV   REG[15],0     (0738) export LoadConfigTBL_servo_transmit_Bank0
04CB: 70 EF    AND   F,239         (0739) export UnloadConfigTBL_servo_transmit_Bank1
04CD: 62 0D 00 MOV   REG[13],0     (0740) export UnloadConfigTBL_servo_transmit_Bank0
04D0: 71 10    OR    F,16          (0741) export UnloadConfigTBL_Total_Bank1
04D2: 62 10 00 MOV   REG[16],0     (0742) export UnloadConfigTBL_Total_Bank0
04D5: 62 11 00 MOV   REG[17],0     (0743) AREA lit(rom, rel)
04D8: 70 EF    AND   F,239         (0744) LoadConfigTBL_hello_Bank0:
04DA: 62 13 00 MOV   REG[19],0     (0745) ;  Instance name HELLO_1, User Module RX8
04DD: 62 12 00 MOV   REG[18],0     (0746) ;       Instance name HELLO_1, Block Name RX8(DCB02)
04E0: 71 10    OR    F,16          (0747) 	db		2bh, 00h		;HELLO_1_CONTROL_REG  (DCB02CR0)
04E2: 62 12 00 MOV   REG[18],0     (0748) 	db		29h, 00h		;HELLO_1_(DCB02DR1)
04E5: 62 13 00 MOV   REG[19],0     (0749) 	db		2ah, 00h		;HELLO_1_RX_BUFFER_REG(DCB02DR2)
04E8: 70 EF    AND   F,239         (0750) ;  Instance name HELLO_2, User Module RX8
04EA: 62 11 00 MOV   REG[17],0     (0751) ;       Instance name HELLO_2, Block Name RX8(DCB03)
04ED: 71 10    OR    F,16          (0752) 	db		2fh, 00h		;HELLO_2_CONTROL_REG  (DCB03CR0)
04EF: 62 14 00 MOV   REG[20],0     (0753) 	db		2dh, 00h		;HELLO_2_(DCB03DR1)
04F2: 62 15 00 MOV   REG[21],0     (0754) 	db		2eh, 00h		;HELLO_2_RX_BUFFER_REG(DCB03DR2)
04F5: 70 EF    AND   F,239         (0755) ;  Instance name HELLO_3, User Module RX8
04F7: 62 17 00 MOV   REG[23],0     (0756) ;       Instance name HELLO_3, Block Name RX8(DCB12)
04FA: 62 16 00 MOV   REG[22],0     (0757) 	db		3bh, 00h		;HELLO_3_CONTROL_REG  (DCB12CR0)
04FD: 71 10    OR    F,16          (0758) 	db		39h, 00h		;HELLO_3_(DCB12DR1)
04FF: 62 16 00 MOV   REG[22],0     (0759) 	db		3ah, 00h		;HELLO_3_RX_BUFFER_REG(DCB12DR2)
0502: 62 17 00 MOV   REG[23],0     (0760) ;  Instance name HELLO_4, User Module RX8
0505: 70 EF    AND   F,239         (0761) ;       Instance name HELLO_4, Block Name RX8(DCB13)
0507: 62 15 00 MOV   REG[21],0     (0762) 	db		3fh, 00h		;HELLO_4_CONTROL_REG  (DCB13CR0)
050A: 71 10    OR    F,16          (0763) 	db		3dh, 00h		;HELLO_4_(DCB13DR1)
050C: 62 18 00 MOV   REG[24],0     (0764) 	db		3eh, 00h		;HELLO_4_RX_BUFFER_REG(DCB13DR2)
050F: 62 19 00 MOV   REG[25],0     (0765) ;  Instance name HELLO_TIMEOUT, User Module Timer16
0512: 70 EF    AND   F,239         (0766) ;       Instance name HELLO_TIMEOUT, Block Name TIMER16_LSB(DBB00)
0514: 62 1B 00 MOV   REG[27],0     (0767) 	db		23h, 00h		;HELLO_TIMEOUT_CONTROL_LSB_REG(DBB00CR0)
0517: 62 1A 00 MOV   REG[26],0     (0768) 	db		21h, e0h		;HELLO_TIMEOUT_PERIOD_LSB_REG(DBB00DR1)
051A: 71 10    OR    F,16          (0769) 	db		22h, 00h		;HELLO_TIMEOUT_COMPARE_LSB_REG(DBB00DR2)
051C: 62 1A 00 MOV   REG[26],0     (0770) ;       Instance name HELLO_TIMEOUT, Block Name TIMER16_MSB(DBB01)
051F: 62 1B 00 MOV   REG[27],0     (0771) 	db		27h, 04h		;HELLO_TIMEOUT_CONTROL_MSB_REG(DBB01CR0)
0522: 70 EF    AND   F,239         (0772) 	db		25h, 01h		;HELLO_TIMEOUT_PERIOD_MSB_REG(DBB01DR1)
0524: 62 19 00 MOV   REG[25],0     (0773) 	db		26h, 00h		;HELLO_TIMEOUT_COMPARE_MSB_REG(DBB01DR2)
0527: 71 10    OR    F,16          (0774) 	db		ffh
0529: 62 1C 00 MOV   REG[28],0     (0775) LoadConfigTBL_hello_Bank1:
052C: 62 1D 00 MOV   REG[29],0     (0776) ;  Instance name HELLO_1, User Module RX8
052F: 70 EF    AND   F,239         (0777) ;       Instance name HELLO_1, Block Name RX8(DCB02)
0531: 62 1F 00 MOV   REG[31],0     (0778) 	db		28h, 05h		;HELLO_1_FUNC_REG     (DCB02FN)
0534: 62 1E 00 MOV   REG[30],0     (0779) 	db		29h, d1h		;HELLO_1_INPUT_REG    (DCB02IN)
0537: 71 10    OR    F,16          (0780) 	db		2ah, 80h		;HELLO_1_OUTPUT_REG   (DCB02OU)
0539: 62 1E 00 MOV   REG[30],0     (0781) ;  Instance name HELLO_2, User Module RX8
053C: 62 1F 00 MOV   REG[31],0     (0782) ;       Instance name HELLO_2, Block Name RX8(DCB03)
053F: 70 EF    AND   F,239         (0783) 	db		2ch, 05h		;HELLO_2_FUNC_REG     (DCB03FN)
0541: 62 1D 00 MOV   REG[29],0     (0784) 	db		2dh, e1h		;HELLO_2_INPUT_REG    (DCB03IN)
0656: 62 D0 00 MOV   REG[208],0    (0785) 	db		2eh, 80h		;HELLO_2_OUTPUT_REG   (DCB03OU)

FILE: lib\psocconfig.asm
0659: 55 04 00 MOV   [4],0         (0098) ; Generated by PSoC Designer 5.0.985.0
065C: 55 05 00 MOV   [5],0         (0099) ;
                                   (0100) INCLUDE "PSoCDynamic.inc"
065F: 7C 06 66 LCALL 0x0666        (0101) ;==========================================================================
0662: 7C 04 5C LCALL 0x045C        (0102) ;  PSoCConfig.asm
                                   (0103) ;  @PSOC_VERSION
                                   (0104) ;
                                   (0105) ;  Version: 0.85
0665: 7F       RET                 (0106) ;  Revised: June 22, 2004
                                   (0107) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0108) ;
                                   (0109) ;  This file is generated by the Device Editor on Application Generation.
                                   (0110) ;  It contains code which loads the configuration data table generated in
                                   (0111) ;  the file PSoCConfigTBL.asm
                                   (0112) ;
                                   (0113) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0114) ;  Edits to this file will not be preserved.
                                   (0115) ;==========================================================================
                                   (0116) ;
                                   (0117) include "m8c.inc"
                                   (0118) include "memory.inc"
                                   (0119) include "GlobalParams.inc"
                                   (0120) 
                                   (0121) export LoadConfigInit
                                   (0122) export _LoadConfigInit
                                   (0123) export LoadConfig_waiting
                                   (0124) export _LoadConfig_waiting
                                   (0125) export UnloadConfig_waiting
                                   (0126) export _UnloadConfig_waiting
                                   (0127) export ReloadConfig_waiting
                                   (0128) export _ReloadConfig_waiting
                                   (0129) export LoadConfig_hello
0666: 71 10    OR    F,16          (0130) export _LoadConfig_hello
                                   (0131) export UnloadConfig_hello
0668: 10       PUSH  X             (0132) export _UnloadConfig_hello
0669: 70 EF    AND   F,239         (0133) export LoadConfig_initial
066B: 50 00    MOV   A,0           (0134) export _LoadConfig_initial
066D: 67       ASR   A             (0135) export UnloadConfig_initial
                                   (0136) export _UnloadConfig_initial
066E: 50 03    MOV   A,3           (0137) export LoadConfig_my_response
0670: 57 D0    MOV   X,208         (0138) export _LoadConfig_my_response
0672: 7C 0C 26 LCALL 0x0C26        (0139) export UnloadConfig_my_response
                                   (0140) export _UnloadConfig_my_response
0675: 50 01    MOV   A,1           (0141) export LoadConfig_response1
0677: 67       ASR   A             (0142) export _LoadConfig_response1
                                   (0143) export UnloadConfig_response1
0678: 50 04    MOV   A,4           (0144) export _UnloadConfig_response1
067A: 57 2B    MOV   X,43          (0145) export LoadConfig_response2
067C: 7C 0C 26 LCALL 0x0C26        (0146) export _LoadConfig_response2
                                   (0147) export UnloadConfig_response2
067F: 62 D0 00 MOV   REG[208],0    (0148) export _UnloadConfig_response2
                                   (0149) export LoadConfig_response3
0682: 2E 04 01 OR    [4],1         (0150) export _LoadConfig_response3
0685: 70 EF    AND   F,239         (0151) export UnloadConfig_response3
0687: 20       POP   X             (0152) export _UnloadConfig_response3
                                   (0153) export LoadConfig_response4
                                   (0154) export _LoadConfig_response4
0688: 7F       RET                 (0155) export UnloadConfig_response4
                                   (0156) export _UnloadConfig_response4
                                   (0157) export LoadConfig_servo_transmit
                                   (0158) export _LoadConfig_servo_transmit
                                   (0159) export UnloadConfig_servo_transmit
                                   (0160) export _UnloadConfig_servo_transmit
                                   (0161) export UnloadConfig_Total
                                   (0162) export _UnloadConfig_Total
                                   (0163) export ACTIVE_CONFIG_STATUS
                                   (0164) 
                                   (0165) export NO_SHADOW
                                   (0166) export _NO_SHADOW
                                   (0167) 
                                   (0168) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0169) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0170) 
                                   (0171) AREA psoc_config(rom, rel)
                                   (0172) 
                                   (0173) ;---------------------------------------------------------------------------
                                   (0174) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0175) ;                  parameters handled by boot code, like CPU speed). This
                                   (0176) ;                  function can be called from user code, but typically it
                                   (0177) ;                  is only called from boot.
                                   (0178) ;
                                   (0179) ;       INPUTS: None.
0689: 10       PUSH  X             (0180) ;      RETURNS: Nothing.
068A: 70 EF    AND   F,239         (0181) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
068C: 50 00    MOV   A,0           (0182) ;               In the large memory model currently only the page
068E: 67       ASR   A             (0183) ;               pointer registers listed below are modified.  This does
                                   (0184) ;               not guarantee that in future implementations of this
068F: 50 05    MOV   A,5           (0185) ;               function other page pointer registers will not be
0691: 57 45    MOV   X,69          (0186) ;               modified.
0693: 7C 0C 26 LCALL 0x0C26        (0187) ;          
                                   (0188) ;               Page Pointer Registers Modified: 
0696: 50 01    MOV   A,1           (0189) ;               CUR_PP
0698: 67       ASR   A             (0190) ;
                                   (0191) _LoadConfigInit:
0699: 50 05    MOV   A,5           (0192)  LoadConfigInit:
069B: 57 52    MOV   X,82          (0193)     RAM_PROLOGUE RAM_USE_CLASS_4
069D: 7C 0C 26 LCALL 0x0C26        (0194)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0195) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0196) 	mov		[ACTIVE_CONFIG_STATUS+1], 0
06A0: 62 D0 00 MOV   REG[208],0    (0197) 
06A3: 2E 04 01 OR    [4],1         (0198) 	lcall	LoadConfig_waiting
06A6: 70 EF    AND   F,239         (0199) 	lcall	LoadConfigTBL_waiting_Ordered
06A8: 20       POP   X             (0200) 
                                   (0201) 
                                   (0202)     RAM_EPILOGUE RAM_USE_CLASS_4
06A9: 7F       RET                 (0203)     ret
                                   (0204) 
                                   (0205) ;---------------------------------------------------------------------------
                                   (0206) ; Load Configuration waiting
                                   (0207) ;
                                   (0208) ;    Load configuration registers for waiting.
                                   (0209) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0210) ;
                                   (0211) ;       INPUTS: None.
                                   (0212) ;      RETURNS: Nothing.
                                   (0213) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0214) ;               modified as may the Page Pointer registers!
                                   (0215) ;               In the large memory model currently only the page
                                   (0216) ;               pointer registers listed below are modified.  This does
                                   (0217) ;               not guarantee that in future implementations of this
                                   (0218) ;               function other page pointer registers will not be
                                   (0219) ;               modified.
                                   (0220) ;          
                                   (0221) ;               Page Pointer Registers Modified: 
                                   (0222) ;               CUR_PP
                                   (0223) ;
                                   (0224) _LoadConfig_waiting:
                                   (0225)  LoadConfig_waiting:
                                   (0226)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0227) 	M8C_SetBank1
                                   (0228) 
06AA: 10       PUSH  X             (0229) 	push	x
06AB: 70 EF    AND   F,239         (0230)     M8C_SetBank0                    ; Force bank 0
06AD: 50 00    MOV   A,0           (0231)     mov     a, 0                    ; Specify bank 0
06AF: 67       ASR   A             (0232)     asr     a                       ; Store in carry flag
                                   (0233)                                     ; Load bank 0 table:
06B0: 50 05    MOV   A,5           (0234)     mov     A, >LoadConfigTBL_waiting_Bank0
06B2: 57 5F    MOV   X,95          (0235)     mov     X, <LoadConfigTBL_waiting_Bank0
06B4: 7C 0C 26 LCALL 0x0C26        (0236)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0237) 
06B7: 50 01    MOV   A,1           (0238)     mov     a, 1                    ; Specify bank 1
06B9: 67       ASR   A             (0239)     asr     a                       ; Store in carry flag
                                   (0240)                                     ; Load bank 1 table:
06BA: 50 05    MOV   A,5           (0241)     mov     A, >LoadConfigTBL_waiting_Bank1
06BC: 57 64    MOV   X,100         (0242)     mov     X, <LoadConfigTBL_waiting_Bank1
06BE: 7C 0C 26 LCALL 0x0C26        (0243)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0244) 
06C1: 70 EF    AND   F,239         (0245) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0246) ; set config active bit
06C3: 62 D0 00 MOV   REG[208],0    (0247) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
06C6: 26 04 FE AND   [4],254       (0248)     M8C_SetBank0                    ; Force return to bank 0
06C9: 70 EF    AND   F,239         (0249) 	pop		x
06CB: 20       POP   X             (0250) 
                                   (0251)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0252)     ret
06CC: 7F       RET                 (0253) 
                                   (0254) ;---------------------------------------------------------------------------
                                   (0255) ; Reload Configuration waiting
                                   (0256) ;
                                   (0257) ;    Reload configuration registers for waiting.
                                   (0258) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0259) ;
                                   (0260) ;       INPUTS: None.
                                   (0261) ;      RETURNS: Nothing.
                                   (0262) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0263) ;               modified as may the Page Pointer registers!
                                   (0264) ;               In the large memory model currently only the page
                                   (0265) ;               pointer registers listed below are modified.  This does
                                   (0266) ;               not guarantee that in future implementations of this
                                   (0267) ;               function other page pointer registers will not be
                                   (0268) ;               modified.
                                   (0269) ;          
                                   (0270) ;               Page Pointer Registers Modified: 
                                   (0271) ;               CUR_PP
                                   (0272) ;
                                   (0273) _ReloadConfig_waiting:
                                   (0274)  ReloadConfig_waiting:
                                   (0275)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0276) 
06CD: 71 10    OR    F,16          (0277) 	push	x
                                   (0278)     M8C_SetBank0                    ; Force bank 0
06CF: 41 00 E1 AND   REG[0],225    (0279)     mov     a, 0                    ; Specify bank 0
                                   (0280)     asr     a                       ; Store in carry flag
06D2: 41 01 E1 AND   REG[1],225    (0281)                                     ; Bank 0 table address:
06D5: 43 01 1E OR    REG[1],30     (0282)     mov     A, >ReloadConfigTBL_waiting_Bank0
                                   (0283)     mov     X, <ReloadConfigTBL_waiting_Bank0
06D8: 70 EF    AND   F,239         (0284)     lcall   LoadConfig              ; Reload the bank 0 values
06DA: 41 03 FE AND   REG[3],254    (0285) 
06DD: 43 03 01 OR    REG[3],1      (0286)     mov     a, 1                    ; Specify bank 1
                                   (0287)     asr     a                       ; Store in carry flag
06E0: 41 02 FE AND   REG[2],254    (0288)                                     ; Bank 1 table address:
                                   (0289)     mov     A, >ReloadConfigTBL_waiting_Bank1
06E3: 41 B3 F0 AND   REG[179],240  (0290)     mov     X, <ReloadConfigTBL_waiting_Bank1
06E6: 43 B3 03 OR    REG[179],3    (0291)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0292) 
06E9: 41 B4 F0 AND   REG[180],240  (0293) ; set config active bit
06EC: 43 B4 03 OR    REG[180],3    (0294) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0295) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
06EF: 41 B5 ED AND   REG[181],237  (0296)     M8C_SetBank0                    ; Force return to bank 0
                                   (0297) 	pop		x
06F2: 41 B6 EE AND   REG[182],238  (0298) 
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_4
06F5: 41 B8 3C AND   REG[184],60   (0300)     ret
06F8: 43 B8 01 OR    REG[184],1    (0301) 
                                   (0302) ;---------------------------------------------------------------------------
06FB: 10       PUSH  X             (0303) ; Unload Configuration waiting
06FC: 70 EF    AND   F,239         (0304) ;
06FE: 50 00    MOV   A,0           (0305) ;    Reset configuration registers for waiting
0700: 67       ASR   A             (0306) ;    to their values as initially configured.
                                   (0307) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0701: 50 01    MOV   A,1           (0308) ;
0703: 57 A0    MOV   X,160         (0309) ;       INPUTS: None.
0705: 7C 0C 26 LCALL 0x0C26        (0310) ;      RETURNS: Nothing.
                                   (0311) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0708: 50 01    MOV   A,1           (0312) ;               modified as may the Page Pointer registers!
070A: 67       ASR   A             (0313) ;               In the large memory model currently only the page
                                   (0314) ;               pointer registers listed below are modified.  This does
070B: 50 01    MOV   A,1           (0315) ;               not guarantee that in future implementations of this
070D: 57 C5    MOV   X,197         (0316) ;               function other page pointer registers will not be
070F: 7C 0C 26 LCALL 0x0C26        (0317) ;               modified.
                                   (0318) ;          
0712: 62 D0 00 MOV   REG[208],0    (0319) ;               Page Pointer Registers Modified: 
                                   (0320) ;               CUR_PP
0715: 2E 04 02 OR    [4],2         (0321) ;
0718: 70 EF    AND   F,239         (0322) _UnloadConfig_waiting:
071A: 20       POP   X             (0323)  UnloadConfig_waiting:
                                   (0324)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0325) 
071B: 7F       RET                 (0326) 	push	x
                                   (0327)     M8C_SetBank0                    ; Force bank 0
                                   (0328)     mov     a, 0                    ; Specify bank 0
                                   (0329)     asr     a                       ; Store in carry flag
                                   (0330)                                     ; Bank 0 table address:
                                   (0331)     mov     A, >UnloadConfigTBL_waiting_Bank0
                                   (0332)     mov     X, <UnloadConfigTBL_waiting_Bank0
                                   (0333)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0334) 
                                   (0335)     mov     a, 1                    ; Specify bank 1
                                   (0336)     asr     a                       ; Store in carry flag
                                   (0337)                                     ; Bank 1 table address:
                                   (0338)     mov     A, >UnloadConfigTBL_waiting_Bank1
                                   (0339)     mov     X, <UnloadConfigTBL_waiting_Bank1
                                   (0340)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0341) 
                                   (0342) 	M8C_SetBank0
                                   (0343) ; clear config active bit
                                   (0344) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0345) 	and		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], ~waiting_BIT
                                   (0346)     M8C_SetBank0                    ; Force return to bank 0
                                   (0347) 	pop		x
                                   (0348) 
                                   (0349)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0350)     ret
                                   (0351) 
071C: 10       PUSH  X             (0352) ;---------------------------------------------------------------------------
071D: 70 EF    AND   F,239         (0353) ; Load Configuration hello
071F: 50 00    MOV   A,0           (0354) ;
0721: 67       ASR   A             (0355) ;    Load configuration registers for hello.
                                   (0356) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0722: 50 01    MOV   A,1           (0357) ;
0724: 57 EA    MOV   X,234         (0358) ;       INPUTS: None.
0726: 7C 0C 26 LCALL 0x0C26        (0359) ;      RETURNS: Nothing.
                                   (0360) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0729: 50 01    MOV   A,1           (0361) ;               modified as may the Page Pointer registers!
072B: 67       ASR   A             (0362) ;               In the large memory model currently only the page
                                   (0363) ;               pointer registers listed below are modified.  This does
072C: 50 01    MOV   A,1           (0364) ;               not guarantee that in future implementations of this
072E: 57 F7    MOV   X,247         (0365) ;               function other page pointer registers will not be
0730: 7C 0C 26 LCALL 0x0C26        (0366) ;               modified.
                                   (0367) ;          
0733: 70 EF    AND   F,239         (0368) ;               Page Pointer Registers Modified: 
                                   (0369) ;               CUR_PP
0735: 41 B3 F0 AND   REG[179],240  (0370) ;
0738: 43 B3 05 OR    REG[179],5    (0371) _LoadConfig_hello:
                                   (0372)  LoadConfig_hello:
073B: 41 B4 F0 AND   REG[180],240  (0373)     RAM_PROLOGUE RAM_USE_CLASS_4
073E: 43 B4 05 OR    REG[180],5    (0374) 	M8C_SetBank1
                                   (0375) ; writing Port_0_DriveMode_0 register
0741: 41 B5 ED AND   REG[181],237  (0376) 	and		reg[ 0h], ~1eh
0744: 43 B5 12 OR    REG[181],18   (0377) ; writing Port_0_DriveMode_1 register
                                   (0378) 	and		reg[ 1h], ~1eh
0747: 41 B6 EE AND   REG[182],238  (0379) 	or		reg[ 1h], 1eh
074A: 43 B6 11 OR    REG[182],17   (0380) ; writing Port_0_DriveMode_2 register
                                   (0381) 	M8C_SetBank0
074D: 41 B8 3C AND   REG[184],60   (0382) 	and		reg[ 3h], ~ 1h
0750: 43 B8 40 OR    REG[184],64   (0383) 	or		reg[ 3h],  1h
                                   (0384) ; writing Port_0_GlobalSelect register
0753: 41 02 FE AND   REG[2],254    (0385) 	and		reg[ 2h], ~ 1h
0756: 43 02 01 OR    REG[2],1      (0386) ; writing Row_0_LogicSelect_0 register
                                   (0387) 	and		reg[b3h], ~ fh
0759: 41 03 FE AND   REG[3],254    (0388) 	or		reg[b3h],  3h
                                   (0389) ; writing Row_0_LogicSelect_1 register
075C: 71 10    OR    F,16          (0390) 	and		reg[b4h], ~ fh
075E: 41 01 E1 AND   REG[1],225    (0391) 	or		reg[b4h],  3h
                                   (0392) ; writing Row_0_OutputDrive_0 register
0761: 41 00 E1 AND   REG[0],225    (0393) 	and		reg[b5h], ~12h
0764: 43 00 1E OR    REG[0],30     (0394) ; writing Row_0_OutputDrive_1 register
0767: 70 EF    AND   F,239         (0395) 	and		reg[b6h], ~11h
                                   (0396) ; writing Row_1_InputMux register
0769: 62 D0 00 MOV   REG[208],0    (0397) 	and		reg[b8h], ~c3h
076C: 26 04 FD AND   [4],253       (0398) 	or		reg[b8h],  1h
076F: 70 EF    AND   F,239         (0399) 
0771: 20       POP   X             (0400) 	push	x
                                   (0401)     M8C_SetBank0                    ; Force bank 0
                                   (0402)     mov     a, 0                    ; Specify bank 0
0772: 7F       RET                 (0403)     asr     a                       ; Store in carry flag
                                   (0404)                                     ; Load bank 0 table:
                                   (0405)     mov     A, >LoadConfigTBL_hello_Bank0
                                   (0406)     mov     X, <LoadConfigTBL_hello_Bank0
                                   (0407)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0408) 
                                   (0409)     mov     a, 1                    ; Specify bank 1
                                   (0410)     asr     a                       ; Store in carry flag
                                   (0411)                                     ; Load bank 1 table:
                                   (0412)     mov     A, >LoadConfigTBL_hello_Bank1
                                   (0413)     mov     X, <LoadConfigTBL_hello_Bank1
                                   (0414)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0415) 
                                   (0416) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0417) ; set config active bit
                                   (0418) 	or		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
                                   (0419)     M8C_SetBank0                    ; Force return to bank 0
                                   (0420) 	pop		x
                                   (0421) 
                                   (0422)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0423)     ret
                                   (0424) 
                                   (0425) ;---------------------------------------------------------------------------
                                   (0426) ; Unload Configuration hello
0773: 71 10    OR    F,16          (0427) ;
                                   (0428) ;    Reset configuration registers for hello
0775: 41 00 E1 AND   REG[0],225    (0429) ;    to their values as initially configured.
                                   (0430) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0778: 41 01 E1 AND   REG[1],225    (0431) ;
077B: 43 01 1E OR    REG[1],30     (0432) ;       INPUTS: None.
                                   (0433) ;      RETURNS: Nothing.
077E: 70 EF    AND   F,239         (0434) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0780: 41 03 E1 AND   REG[3],225    (0435) ;               modified as may the Page Pointer registers!
0783: 43 03 1E OR    REG[3],30     (0436) ;               In the large memory model currently only the page
                                   (0437) ;               pointer registers listed below are modified.  This does
0786: 41 02 E1 AND   REG[2],225    (0438) ;               not guarantee that in future implementations of this
                                   (0439) ;               function other page pointer registers will not be
0789: 41 B3 F0 AND   REG[179],240  (0440) ;               modified.
078C: 43 B3 03 OR    REG[179],3    (0441) ;          
                                   (0442) ;               Page Pointer Registers Modified: 
078F: 41 B4 F0 AND   REG[180],240  (0443) ;               CUR_PP
0792: 43 B4 03 OR    REG[180],3    (0444) ;
                                   (0445) _UnloadConfig_hello:
0795: 41 B5 ED AND   REG[181],237  (0446)  UnloadConfig_hello:
                                   (0447)     RAM_PROLOGUE RAM_USE_CLASS_4
0798: 41 B6 EE AND   REG[182],238  (0448) 
                                   (0449) 	push	x
079B: 41 B8 FC AND   REG[184],252  (0450)     M8C_SetBank0                    ; Force bank 0
079E: 43 B8 01 OR    REG[184],1    (0451)     mov     a, 0                    ; Specify bank 0
                                   (0452)     asr     a                       ; Store in carry flag
07A1: 71 10    OR    F,16          (0453)                                     ; Bank 0 table address:
07A3: 41 E3 F8 AND   REG[227],248  (0454)     mov     A, >UnloadConfigTBL_hello_Bank0
07A6: 43 E3 03 OR    REG[227],3    (0455)     mov     X, <UnloadConfigTBL_hello_Bank0
                                   (0456)     lcall   LoadConfig              ; Unload the bank 0 values
07A9: 10       PUSH  X             (0457) 
07AA: 70 EF    AND   F,239         (0458)     mov     a, 1                    ; Specify bank 1
07AC: 50 00    MOV   A,0           (0459)     asr     a                       ; Store in carry flag
07AE: 67       ASR   A             (0460)                                     ; Bank 1 table address:
                                   (0461)     mov     A, >UnloadConfigTBL_hello_Bank1
07AF: 50 02    MOV   A,2           (0462)     mov     X, <UnloadConfigTBL_hello_Bank1
07B1: 57 1D    MOV   X,29          (0463)     lcall   LoadConfig              ; Unload the bank 1 values
07B3: 7C 0C 26 LCALL 0x0C26        (0464) 
                                   (0465) 	M8C_SetBank0
07B6: 50 01    MOV   A,1           (0466) ; writing Row_0_LogicSelect_0 register
07B8: 67       ASR   A             (0467) 	and		reg[b3h], ~ fh
                                   (0468) 	or		reg[b3h],  5h
07B9: 50 02    MOV   A,2           (0469) ; writing Row_0_LogicSelect_1 register
07BB: 57 30    MOV   X,48          (0470) 	and		reg[b4h], ~ fh
07BD: 7C 0C 26 LCALL 0x0C26        (0471) 	or		reg[b4h],  5h
                                   (0472) ; writing Row_0_OutputDrive_0 register
07C0: 62 D0 00 MOV   REG[208],0    (0473) 	and		reg[b5h], ~12h
                                   (0474) 	or		reg[b5h], 12h
07C3: 2E 04 04 OR    [4],4         (0475) ; writing Row_0_OutputDrive_1 register
07C6: 70 EF    AND   F,239         (0476) 	and		reg[b6h], ~11h
07C8: 20       POP   X             (0477) 	or		reg[b6h], 11h
                                   (0478) ; writing Row_1_InputMux register
                                   (0479) 	and		reg[b8h], ~c3h
07C9: 7F       RET                 (0480) 	or		reg[b8h], 40h
                                   (0481) ; writing Port_0_GlobalSelect register
                                   (0482) 	and		reg[ 2h], ~ 1h
                                   (0483) 	or		reg[ 2h],  1h
                                   (0484) ; writing Port_0_DriveMode_2 register
                                   (0485) 	and		reg[ 3h], ~ 1h
                                   (0486) ; writing Port_0_DriveMode_1 register
                                   (0487) 	M8C_SetBank1
                                   (0488) 	and		reg[ 1h], ~1eh
                                   (0489) ; writing Port_0_DriveMode_0 register
                                   (0490) 	and		reg[ 0h], ~1eh
                                   (0491) 	or		reg[ 0h], 1eh
                                   (0492) 	M8C_SetBank0
                                   (0493) ; clear config active bit
                                   (0494) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0495) 	and		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], ~hello_BIT
                                   (0496)     M8C_SetBank0                    ; Force return to bank 0
                                   (0497) 	pop		x
                                   (0498) 
                                   (0499)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0500)     ret
                                   (0501) 
                                   (0502) ;---------------------------------------------------------------------------
                                   (0503) ; Load Configuration initial
                                   (0504) ;
                                   (0505) ;    Load configuration registers for initial.
07CA: 10       PUSH  X             (0506) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07CB: 70 EF    AND   F,239         (0507) ;
07CD: 50 00    MOV   A,0           (0508) ;       INPUTS: None.
07CF: 67       ASR   A             (0509) ;      RETURNS: Nothing.
                                   (0510) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
07D0: 50 02    MOV   A,2           (0511) ;               modified as may the Page Pointer registers!
07D2: 57 43    MOV   X,67          (0512) ;               In the large memory model currently only the page
07D4: 7C 0C 26 LCALL 0x0C26        (0513) ;               pointer registers listed below are modified.  This does
                                   (0514) ;               not guarantee that in future implementations of this
07D7: 50 01    MOV   A,1           (0515) ;               function other page pointer registers will not be
07D9: 67       ASR   A             (0516) ;               modified.
                                   (0517) ;          
07DA: 50 02    MOV   A,2           (0518) ;               Page Pointer Registers Modified: 
07DC: 57 4A    MOV   X,74          (0519) ;               CUR_PP
07DE: 7C 0C 26 LCALL 0x0C26        (0520) ;
                                   (0521) _LoadConfig_initial:
07E1: 70 EF    AND   F,239         (0522)  LoadConfig_initial:
                                   (0523)     RAM_PROLOGUE RAM_USE_CLASS_4
07E3: 41 B3 F0 AND   REG[179],240  (0524) 	M8C_SetBank1
07E6: 43 B3 05 OR    REG[179],5    (0525) ; writing Port_0_DriveMode_0 register
                                   (0526) 	and		reg[ 0h], ~1eh
07E9: 41 B4 F0 AND   REG[180],240  (0527) ; writing Port_0_DriveMode_1 register
07EC: 43 B4 05 OR    REG[180],5    (0528) 	and		reg[ 1h], ~1eh
                                   (0529) 	or		reg[ 1h], 1eh
07EF: 41 B5 ED AND   REG[181],237  (0530) ; writing Port_0_DriveMode_2 register
07F2: 43 B5 12 OR    REG[181],18   (0531) 	M8C_SetBank0
                                   (0532) 	and		reg[ 3h], ~1eh
07F5: 41 B6 EE AND   REG[182],238  (0533) 	or		reg[ 3h], 1eh
07F8: 43 B6 11 OR    REG[182],17   (0534) ; writing Port_0_GlobalSelect register
                                   (0535) 	and		reg[ 2h], ~1eh
07FB: 41 B8 FC AND   REG[184],252  (0536) ; writing Row_0_LogicSelect_0 register
                                   (0537) 	and		reg[b3h], ~ fh
07FE: 71 10    OR    F,16          (0538) 	or		reg[b3h],  3h
0800: 41 E3 F8 AND   REG[227],248  (0539) ; writing Row_0_LogicSelect_1 register
0803: 43 E3 07 OR    REG[227],7    (0540) 	and		reg[b4h], ~ fh
                                   (0541) 	or		reg[b4h],  3h
0806: 70 EF    AND   F,239         (0542) ; writing Row_0_OutputDrive_0 register
0808: 41 02 E1 AND   REG[2],225    (0543) 	and		reg[b5h], ~12h
080B: 43 02 1E OR    REG[2],30     (0544) ; writing Row_0_OutputDrive_1 register
                                   (0545) 	and		reg[b6h], ~11h
080E: 41 03 E1 AND   REG[3],225    (0546) ; writing Row_1_InputMux register
                                   (0547) 	and		reg[b8h], ~ 3h
0811: 71 10    OR    F,16          (0548) 	or		reg[b8h],  1h
0813: 41 01 E1 AND   REG[1],225    (0549) ; writing VoltageMonitorControl register
                                   (0550) 	M8C_SetBank1
0816: 41 00 E1 AND   REG[0],225    (0551) 	and		reg[e3h], ~ 7h
0819: 43 00 1E OR    REG[0],30     (0552) 	or		reg[e3h],  3h
081C: 70 EF    AND   F,239         (0553) 
                                   (0554) 	push	x
081E: 62 D0 00 MOV   REG[208],0    (0555)     M8C_SetBank0                    ; Force bank 0
0821: 26 04 FB AND   [4],251       (0556)     mov     a, 0                    ; Specify bank 0
0824: 70 EF    AND   F,239         (0557)     asr     a                       ; Store in carry flag
0826: 20       POP   X             (0558)                                     ; Load bank 0 table:
                                   (0559)     mov     A, >LoadConfigTBL_initial_Bank0
                                   (0560)     mov     X, <LoadConfigTBL_initial_Bank0
0827: 7F       RET                 (0561)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0562) 
                                   (0563)     mov     a, 1                    ; Specify bank 1
                                   (0564)     asr     a                       ; Store in carry flag
                                   (0565)                                     ; Load bank 1 table:
                                   (0566)     mov     A, >LoadConfigTBL_initial_Bank1
                                   (0567)     mov     X, <LoadConfigTBL_initial_Bank1
                                   (0568)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0569) 
                                   (0570) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0571) ; set config active bit
                                   (0572) 	or		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
                                   (0573)     M8C_SetBank0                    ; Force return to bank 0
                                   (0574) 	pop		x
                                   (0575) 
                                   (0576)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0577)     ret
                                   (0578) 
                                   (0579) ;---------------------------------------------------------------------------
                                   (0580) ; Unload Configuration initial
                                   (0581) ;
                                   (0582) ;    Reset configuration registers for initial
                                   (0583) ;    to their values as initially configured.
                                   (0584) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0828: 71 10    OR    F,16          (0585) ;
                                   (0586) ;       INPUTS: None.
082A: 41 00 FE AND   REG[0],254    (0587) ;      RETURNS: Nothing.
082D: 43 00 01 OR    REG[0],1      (0588) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0589) ;               modified as may the Page Pointer registers!
0830: 41 01 FE AND   REG[1],254    (0590) ;               In the large memory model currently only the page
                                   (0591) ;               pointer registers listed below are modified.  This does
0833: 70 EF    AND   F,239         (0592) ;               not guarantee that in future implementations of this
0835: 41 B5 FE AND   REG[181],254  (0593) ;               function other page pointer registers will not be
0838: 43 B5 01 OR    REG[181],1    (0594) ;               modified.
                                   (0595) ;          
083B: 41 B8 FC AND   REG[184],252  (0596) ;               Page Pointer Registers Modified: 
083E: 43 B8 01 OR    REG[184],1    (0597) ;               CUR_PP
                                   (0598) ;
0841: 10       PUSH  X             (0599) _UnloadConfig_initial:
0842: 70 EF    AND   F,239         (0600)  UnloadConfig_initial:
0844: 50 00    MOV   A,0           (0601)     RAM_PROLOGUE RAM_USE_CLASS_4
0846: 67       ASR   A             (0602) 
                                   (0603) 	push	x
0847: 50 02    MOV   A,2           (0604)     M8C_SetBank0                    ; Force bank 0
0849: 57 5E    MOV   X,94          (0605)     mov     a, 0                    ; Specify bank 0
084B: 7C 0C 26 LCALL 0x0C26        (0606)     asr     a                       ; Store in carry flag
                                   (0607)                                     ; Bank 0 table address:
084E: 50 01    MOV   A,1           (0608)     mov     A, >UnloadConfigTBL_initial_Bank0
0850: 67       ASR   A             (0609)     mov     X, <UnloadConfigTBL_initial_Bank0
                                   (0610)     lcall   LoadConfig              ; Unload the bank 0 values
0851: 50 02    MOV   A,2           (0611) 
0853: 57 77    MOV   X,119         (0612)     mov     a, 1                    ; Specify bank 1
0855: 7C 0C 26 LCALL 0x0C26        (0613)     asr     a                       ; Store in carry flag
                                   (0614)                                     ; Bank 1 table address:
0858: 62 D0 00 MOV   REG[208],0    (0615)     mov     A, >UnloadConfigTBL_initial_Bank1
                                   (0616)     mov     X, <UnloadConfigTBL_initial_Bank1
085B: 2E 04 08 OR    [4],8         (0617)     lcall   LoadConfig              ; Unload the bank 1 values
085E: 70 EF    AND   F,239         (0618) 
0860: 20       POP   X             (0619) 	M8C_SetBank0
                                   (0620) ; writing Row_0_LogicSelect_0 register
                                   (0621) 	and		reg[b3h], ~ fh
0861: 7F       RET                 (0622) 	or		reg[b3h],  5h
                                   (0623) ; writing Row_0_LogicSelect_1 register
                                   (0624) 	and		reg[b4h], ~ fh
                                   (0625) 	or		reg[b4h],  5h
                                   (0626) ; writing Row_0_OutputDrive_0 register
                                   (0627) 	and		reg[b5h], ~12h
                                   (0628) 	or		reg[b5h], 12h
                                   (0629) ; writing Row_0_OutputDrive_1 register
                                   (0630) 	and		reg[b6h], ~11h
                                   (0631) 	or		reg[b6h], 11h
                                   (0632) ; writing Row_1_InputMux register
                                   (0633) 	and		reg[b8h], ~ 3h
                                   (0634) ; writing VoltageMonitorControl register
                                   (0635) 	M8C_SetBank1
                                   (0636) 	and		reg[e3h], ~ 7h
                                   (0637) 	or		reg[e3h],  7h
                                   (0638) ; writing Port_0_GlobalSelect register
                                   (0639) 	M8C_SetBank0
                                   (0640) 	and		reg[ 2h], ~1eh
                                   (0641) 	or		reg[ 2h], 1eh
                                   (0642) ; writing Port_0_DriveMode_2 register
                                   (0643) 	and		reg[ 3h], ~1eh
                                   (0644) ; writing Port_0_DriveMode_1 register
                                   (0645) 	M8C_SetBank1
                                   (0646) 	and		reg[ 1h], ~1eh
                                   (0647) ; writing Port_0_DriveMode_0 register
0862: 10       PUSH  X             (0648) 	and		reg[ 0h], ~1eh
0863: 70 EF    AND   F,239         (0649) 	or		reg[ 0h], 1eh
0865: 50 00    MOV   A,0           (0650) 	M8C_SetBank0
0867: 67       ASR   A             (0651) ; clear config active bit
                                   (0652) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0868: 50 02    MOV   A,2           (0653) 	and		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], ~initial_BIT
086A: 57 90    MOV   X,144         (0654)     M8C_SetBank0                    ; Force return to bank 0
086C: 7C 0C 26 LCALL 0x0C26        (0655) 	pop		x
                                   (0656) 
086F: 50 01    MOV   A,1           (0657)     RAM_EPILOGUE RAM_USE_CLASS_4
0871: 67       ASR   A             (0658)     ret
                                   (0659) 
0872: 50 02    MOV   A,2           (0660) ;---------------------------------------------------------------------------
0874: 57 99    MOV   X,153         (0661) ; Load Configuration my_response
0876: 7C 0C 26 LCALL 0x0C26        (0662) ;
                                   (0663) ;    Load configuration registers for my_response.
0879: 70 EF    AND   F,239         (0664) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0665) ;
087B: 41 B5 FE AND   REG[181],254  (0666) ;       INPUTS: None.
                                   (0667) ;      RETURNS: Nothing.
087E: 41 B8 FC AND   REG[184],252  (0668) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0669) ;               modified as may the Page Pointer registers!
0881: 71 10    OR    F,16          (0670) ;               In the large memory model currently only the page
0883: 41 01 FE AND   REG[1],254    (0671) ;               pointer registers listed below are modified.  This does
0886: 43 01 01 OR    REG[1],1      (0672) ;               not guarantee that in future implementations of this
                                   (0673) ;               function other page pointer registers will not be
0889: 41 00 FE AND   REG[0],254    (0674) ;               modified.
088C: 70 EF    AND   F,239         (0675) ;          
                                   (0676) ;               Page Pointer Registers Modified: 
088E: 62 D0 00 MOV   REG[208],0    (0677) ;               CUR_PP
0891: 26 04 F7 AND   [4],247       (0678) ;
0894: 70 EF    AND   F,239         (0679) _LoadConfig_my_response:
0896: 20       POP   X             (0680)  LoadConfig_my_response:
                                   (0681)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0682) 	M8C_SetBank1
0897: 7F       RET                 (0683) ; writing Port_0_DriveMode_0 register
                                   (0684) 	and		reg[ 0h], ~ 1h
                                   (0685) 	or		reg[ 0h],  1h
                                   (0686) ; writing Port_0_DriveMode_1 register
                                   (0687) 	and		reg[ 1h], ~ 1h
                                   (0688) ; writing Row_0_OutputDrive_0 register
                                   (0689) 	M8C_SetBank0
                                   (0690) 	and		reg[b5h], ~ 1h
                                   (0691) 	or		reg[b5h],  1h
                                   (0692) ; writing Row_1_InputMux register
                                   (0693) 	and		reg[b8h], ~ 3h
                                   (0694) 	or		reg[b8h],  1h
                                   (0695) 
                                   (0696) 	push	x
                                   (0697)     M8C_SetBank0                    ; Force bank 0
                                   (0698)     mov     a, 0                    ; Specify bank 0
                                   (0699)     asr     a                       ; Store in carry flag
                                   (0700)                                     ; Load bank 0 table:
                                   (0701)     mov     A, >LoadConfigTBL_my_response_Bank0
                                   (0702)     mov     X, <LoadConfigTBL_my_response_Bank0
                                   (0703)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0704) 
                                   (0705)     mov     a, 1                    ; Specify bank 1
                                   (0706)     asr     a                       ; Store in carry flag
0898: 71 10    OR    F,16          (0707)                                     ; Load bank 1 table:
                                   (0708)     mov     A, >LoadConfigTBL_my_response_Bank1
089A: 41 00 E0 AND   REG[0],224    (0709)     mov     X, <LoadConfigTBL_my_response_Bank1
089D: 43 00 01 OR    REG[0],1      (0710)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0711) 
08A0: 41 01 E0 AND   REG[1],224    (0712) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
08A3: 43 01 1E OR    REG[1],30     (0713) ; set config active bit
                                   (0714) 	or		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
08A6: 70 EF    AND   F,239         (0715)     M8C_SetBank0                    ; Force return to bank 0
08A8: 41 03 E3 AND   REG[3],227    (0716) 	pop		x
08AB: 43 03 1C OR    REG[3],28     (0717) 
                                   (0718)     RAM_EPILOGUE RAM_USE_CLASS_4
08AE: 41 02 E3 AND   REG[2],227    (0719)     ret
                                   (0720) 
08B1: 41 B3 F0 AND   REG[179],240  (0721) ;---------------------------------------------------------------------------
08B4: 43 B3 03 OR    REG[179],3    (0722) ; Unload Configuration my_response
                                   (0723) ;
08B7: 41 B4 F0 AND   REG[180],240  (0724) ;    Reset configuration registers for my_response
08BA: 43 B4 03 OR    REG[180],3    (0725) ;    to their values as initially configured.
                                   (0726) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
08BD: 41 B5 EC AND   REG[181],236  (0727) ;
08C0: 43 B5 01 OR    REG[181],1    (0728) ;       INPUTS: None.
                                   (0729) ;      RETURNS: Nothing.
08C3: 41 B6 EE AND   REG[182],238  (0730) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0731) ;               modified as may the Page Pointer registers!
08C6: 41 B8 FC AND   REG[184],252  (0732) ;               In the large memory model currently only the page
08C9: 43 B8 01 OR    REG[184],1    (0733) ;               pointer registers listed below are modified.  This does
                                   (0734) ;               not guarantee that in future implementations of this
08CC: 10       PUSH  X             (0735) ;               function other page pointer registers will not be
08CD: 70 EF    AND   F,239         (0736) ;               modified.
08CF: 50 00    MOV   A,0           (0737) ;          
08D1: 67       ASR   A             (0738) ;               Page Pointer Registers Modified: 
                                   (0739) ;               CUR_PP
08D2: 50 02    MOV   A,2           (0740) ;
08D4: 57 B3    MOV   X,179         (0741) _UnloadConfig_my_response:
08D6: 7C 0C 26 LCALL 0x0C26        (0742)  UnloadConfig_my_response:
                                   (0743)     RAM_PROLOGUE RAM_USE_CLASS_4
08D9: 50 01    MOV   A,1           (0744) 
08DB: 67       ASR   A             (0745) 	push	x
                                   (0746)     M8C_SetBank0                    ; Force bank 0
08DC: 50 02    MOV   A,2           (0747)     mov     a, 0                    ; Specify bank 0
08DE: 57 C6    MOV   X,198         (0748)     asr     a                       ; Store in carry flag
08E0: 7C 0C 26 LCALL 0x0C26        (0749)                                     ; Bank 0 table address:
                                   (0750)     mov     A, >UnloadConfigTBL_my_response_Bank0
08E3: 62 D0 00 MOV   REG[208],0    (0751)     mov     X, <UnloadConfigTBL_my_response_Bank0
                                   (0752)     lcall   LoadConfig              ; Unload the bank 0 values
08E6: 2E 04 10 OR    [4],16        (0753) 
08E9: 70 EF    AND   F,239         (0754)     mov     a, 1                    ; Specify bank 1
08EB: 20       POP   X             (0755)     asr     a                       ; Store in carry flag
                                   (0756)                                     ; Bank 1 table address:
                                   (0757)     mov     A, >UnloadConfigTBL_my_response_Bank1
08EC: 7F       RET                 (0758)     mov     X, <UnloadConfigTBL_my_response_Bank1
                                   (0759)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0760) 
                                   (0761) 	M8C_SetBank0
                                   (0762) ; writing Row_0_OutputDrive_0 register
                                   (0763) 	and		reg[b5h], ~ 1h
                                   (0764) ; writing Row_1_InputMux register
                                   (0765) 	and		reg[b8h], ~ 3h
                                   (0766) ; writing Port_0_DriveMode_1 register
                                   (0767) 	M8C_SetBank1
                                   (0768) 	and		reg[ 1h], ~ 1h
                                   (0769) 	or		reg[ 1h],  1h
                                   (0770) ; writing Port_0_DriveMode_0 register
                                   (0771) 	and		reg[ 0h], ~ 1h
                                   (0772) 	M8C_SetBank0
                                   (0773) ; clear config active bit
                                   (0774) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0775) 	and		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], ~my_response_BIT
                                   (0776)     M8C_SetBank0                    ; Force return to bank 0
                                   (0777) 	pop		x
                                   (0778) 
                                   (0779)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0780)     ret
                                   (0781) 
                                   (0782) ;---------------------------------------------------------------------------
                                   (0783) ; Load Configuration response1
08ED: 10       PUSH  X             (0784) ;
08EE: 70 EF    AND   F,239         (0785) ;    Load configuration registers for response1.
08F0: 50 00    MOV   A,0           (0786) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
08F2: 67       ASR   A             (0787) ;
                                   (0788) ;       INPUTS: None.
08F3: 50 02    MOV   A,2           (0789) ;      RETURNS: Nothing.
08F5: 57 D9    MOV   X,217         (0790) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
08F7: 7C 0C 26 LCALL 0x0C26        (0791) ;               modified as may the Page Pointer registers!
                                   (0792) ;               In the large memory model currently only the page
08FA: 50 01    MOV   A,1           (0793) ;               pointer registers listed below are modified.  This does
08FC: 67       ASR   A             (0794) ;               not guarantee that in future implementations of this
                                   (0795) ;               function other page pointer registers will not be
08FD: 50 02    MOV   A,2           (0796) ;               modified.
08FF: 57 E0    MOV   X,224         (0797) ;          
0901: 7C 0C 26 LCALL 0x0C26        (0798) ;               Page Pointer Registers Modified: 
                                   (0799) ;               CUR_PP
0904: 70 EF    AND   F,239         (0800) ;
                                   (0801) _LoadConfig_response1:
0906: 41 B3 F0 AND   REG[179],240  (0802)  LoadConfig_response1:
0909: 43 B3 05 OR    REG[179],5    (0803)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0804) 	M8C_SetBank1
090C: 41 B4 F0 AND   REG[180],240  (0805) ; writing Port_0_DriveMode_0 register
090F: 43 B4 05 OR    REG[180],5    (0806) 	and		reg[ 0h], ~1fh
                                   (0807) 	or		reg[ 0h],  1h
0912: 41 B5 EC AND   REG[181],236  (0808) ; writing Port_0_DriveMode_1 register
0915: 43 B5 12 OR    REG[181],18   (0809) 	and		reg[ 1h], ~1fh
                                   (0810) 	or		reg[ 1h], 1eh
0918: 41 B6 EE AND   REG[182],238  (0811) ; writing Port_0_DriveMode_2 register
091B: 43 B6 11 OR    REG[182],17   (0812) 	M8C_SetBank0
                                   (0813) 	and		reg[ 3h], ~1ch
091E: 41 B8 FC AND   REG[184],252  (0814) 	or		reg[ 3h], 1ch
                                   (0815) ; writing Port_0_GlobalSelect register
0921: 41 02 E3 AND   REG[2],227    (0816) 	and		reg[ 2h], ~1ch
0924: 43 02 1C OR    REG[2],28     (0817) ; writing Row_0_LogicSelect_0 register
                                   (0818) 	and		reg[b3h], ~ fh
0927: 41 03 E3 AND   REG[3],227    (0819) 	or		reg[b3h],  3h
                                   (0820) ; writing Row_0_LogicSelect_1 register
092A: 71 10    OR    F,16          (0821) 	and		reg[b4h], ~ fh
092C: 41 01 E0 AND   REG[1],224    (0822) 	or		reg[b4h],  3h
092F: 43 01 01 OR    REG[1],1      (0823) ; writing Row_0_OutputDrive_0 register
                                   (0824) 	and		reg[b5h], ~13h
0932: 41 00 E0 AND   REG[0],224    (0825) 	or		reg[b5h],  1h
0935: 43 00 1E OR    REG[0],30     (0826) ; writing Row_0_OutputDrive_1 register
0938: 70 EF    AND   F,239         (0827) 	and		reg[b6h], ~11h
                                   (0828) ; writing Row_1_InputMux register
093A: 62 D0 00 MOV   REG[208],0    (0829) 	and		reg[b8h], ~ 3h
093D: 26 04 EF AND   [4],239       (0830) 	or		reg[b8h],  1h
0940: 70 EF    AND   F,239         (0831) 
0942: 20       POP   X             (0832) 	push	x
                                   (0833)     M8C_SetBank0                    ; Force bank 0
                                   (0834)     mov     a, 0                    ; Specify bank 0
0943: 7F       RET                 (0835)     asr     a                       ; Store in carry flag
                                   (0836)                                     ; Load bank 0 table:
                                   (0837)     mov     A, >LoadConfigTBL_response1_Bank0
                                   (0838)     mov     X, <LoadConfigTBL_response1_Bank0
                                   (0839)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0840) 
                                   (0841)     mov     a, 1                    ; Specify bank 1
                                   (0842)     asr     a                       ; Store in carry flag
                                   (0843)                                     ; Load bank 1 table:
                                   (0844)     mov     A, >LoadConfigTBL_response1_Bank1
                                   (0845)     mov     X, <LoadConfigTBL_response1_Bank1
                                   (0846)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0847) 
                                   (0848) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0849) ; set config active bit
                                   (0850) 	or		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
                                   (0851)     M8C_SetBank0                    ; Force return to bank 0
                                   (0852) 	pop		x
                                   (0853) 
                                   (0854)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0855)     ret
                                   (0856) 
                                   (0857) ;---------------------------------------------------------------------------
                                   (0858) ; Unload Configuration response1
0944: 71 10    OR    F,16          (0859) ;
                                   (0860) ;    Reset configuration registers for response1
0946: 41 00 E0 AND   REG[0],224    (0861) ;    to their values as initially configured.
0949: 43 00 01 OR    REG[0],1      (0862) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0863) ;
094C: 41 01 E0 AND   REG[1],224    (0864) ;       INPUTS: None.
094F: 43 01 1E OR    REG[1],30     (0865) ;      RETURNS: Nothing.
                                   (0866) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0952: 70 EF    AND   F,239         (0867) ;               modified as may the Page Pointer registers!
0954: 41 03 E5 AND   REG[3],229    (0868) ;               In the large memory model currently only the page
0957: 43 03 1A OR    REG[3],26     (0869) ;               pointer registers listed below are modified.  This does
                                   (0870) ;               not guarantee that in future implementations of this
095A: 41 02 E5 AND   REG[2],229    (0871) ;               function other page pointer registers will not be
                                   (0872) ;               modified.
095D: 41 B3 F0 AND   REG[179],240  (0873) ;          
0960: 43 B3 03 OR    REG[179],3    (0874) ;               Page Pointer Registers Modified: 
                                   (0875) ;               CUR_PP
0963: 41 B4 F0 AND   REG[180],240  (0876) ;
0966: 43 B4 03 OR    REG[180],3    (0877) _UnloadConfig_response1:
                                   (0878)  UnloadConfig_response1:
0969: 41 B5 EC AND   REG[181],236  (0879)     RAM_PROLOGUE RAM_USE_CLASS_4
096C: 43 B5 01 OR    REG[181],1    (0880) 
                                   (0881) 	push	x
096F: 41 B6 EE AND   REG[182],238  (0882)     M8C_SetBank0                    ; Force bank 0
                                   (0883)     mov     a, 0                    ; Specify bank 0
0972: 41 B8 FC AND   REG[184],252  (0884)     asr     a                       ; Store in carry flag
0975: 43 B8 01 OR    REG[184],1    (0885)                                     ; Bank 0 table address:
                                   (0886)     mov     A, >UnloadConfigTBL_response1_Bank0
0978: 10       PUSH  X             (0887)     mov     X, <UnloadConfigTBL_response1_Bank0
0979: 70 EF    AND   F,239         (0888)     lcall   LoadConfig              ; Unload the bank 0 values
097B: 50 00    MOV   A,0           (0889) 
097D: 67       ASR   A             (0890)     mov     a, 1                    ; Specify bank 1
                                   (0891)     asr     a                       ; Store in carry flag
097E: 50 02    MOV   A,2           (0892)                                     ; Bank 1 table address:
0980: 57 F4    MOV   X,244         (0893)     mov     A, >UnloadConfigTBL_response1_Bank1
0982: 7C 0C 26 LCALL 0x0C26        (0894)     mov     X, <UnloadConfigTBL_response1_Bank1
                                   (0895)     lcall   LoadConfig              ; Unload the bank 1 values
0985: 50 01    MOV   A,1           (0896) 
0987: 67       ASR   A             (0897) 	M8C_SetBank0
                                   (0898) ; writing Row_0_LogicSelect_0 register
0988: 50 03    MOV   A,3           (0899) 	and		reg[b3h], ~ fh
098A: 57 07    MOV   X,7           (0900) 	or		reg[b3h],  5h
098C: 7C 0C 26 LCALL 0x0C26        (0901) ; writing Row_0_LogicSelect_1 register
                                   (0902) 	and		reg[b4h], ~ fh
098F: 62 D0 00 MOV   REG[208],0    (0903) 	or		reg[b4h],  5h
                                   (0904) ; writing Row_0_OutputDrive_0 register
0992: 2E 04 20 OR    [4],32        (0905) 	and		reg[b5h], ~13h
0995: 70 EF    AND   F,239         (0906) 	or		reg[b5h], 12h
0997: 20       POP   X             (0907) ; writing Row_0_OutputDrive_1 register
                                   (0908) 	and		reg[b6h], ~11h
                                   (0909) 	or		reg[b6h], 11h
0998: 7F       RET                 (0910) ; writing Row_1_InputMux register
                                   (0911) 	and		reg[b8h], ~ 3h
                                   (0912) ; writing Port_0_GlobalSelect register
                                   (0913) 	and		reg[ 2h], ~1ch
                                   (0914) 	or		reg[ 2h], 1ch
                                   (0915) ; writing Port_0_DriveMode_2 register
                                   (0916) 	and		reg[ 3h], ~1ch
                                   (0917) ; writing Port_0_DriveMode_1 register
                                   (0918) 	M8C_SetBank1
                                   (0919) 	and		reg[ 1h], ~1fh
                                   (0920) 	or		reg[ 1h],  1h
                                   (0921) ; writing Port_0_DriveMode_0 register
                                   (0922) 	and		reg[ 0h], ~1fh
                                   (0923) 	or		reg[ 0h], 1eh
                                   (0924) 	M8C_SetBank0
                                   (0925) ; clear config active bit
                                   (0926) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0927) 	and		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], ~response1_BIT
                                   (0928)     M8C_SetBank0                    ; Force return to bank 0
                                   (0929) 	pop		x
                                   (0930) 
                                   (0931)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0932)     ret
                                   (0933) 
                                   (0934) ;---------------------------------------------------------------------------
                                   (0935) ; Load Configuration response2
0999: 10       PUSH  X             (0936) ;
099A: 70 EF    AND   F,239         (0937) ;    Load configuration registers for response2.
099C: 50 00    MOV   A,0           (0938) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
099E: 67       ASR   A             (0939) ;
                                   (0940) ;       INPUTS: None.
099F: 50 03    MOV   A,3           (0941) ;      RETURNS: Nothing.
09A1: 57 1A    MOV   X,26          (0942) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
09A3: 7C 0C 26 LCALL 0x0C26        (0943) ;               modified as may the Page Pointer registers!
                                   (0944) ;               In the large memory model currently only the page
09A6: 50 01    MOV   A,1           (0945) ;               pointer registers listed below are modified.  This does
09A8: 67       ASR   A             (0946) ;               not guarantee that in future implementations of this
                                   (0947) ;               function other page pointer registers will not be
09A9: 50 03    MOV   A,3           (0948) ;               modified.
09AB: 57 21    MOV   X,33          (0949) ;          
09AD: 7C 0C 26 LCALL 0x0C26        (0950) ;               Page Pointer Registers Modified: 
                                   (0951) ;               CUR_PP
09B0: 70 EF    AND   F,239         (0952) ;
                                   (0953) _LoadConfig_response2:
09B2: 41 B3 F0 AND   REG[179],240  (0954)  LoadConfig_response2:
09B5: 43 B3 05 OR    REG[179],5    (0955)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0956) 	M8C_SetBank1
09B8: 41 B4 F0 AND   REG[180],240  (0957) ; writing Port_0_DriveMode_0 register
09BB: 43 B4 05 OR    REG[180],5    (0958) 	and		reg[ 0h], ~1fh
                                   (0959) 	or		reg[ 0h],  1h
09BE: 41 B5 EC AND   REG[181],236  (0960) ; writing Port_0_DriveMode_1 register
09C1: 43 B5 12 OR    REG[181],18   (0961) 	and		reg[ 1h], ~1fh
                                   (0962) 	or		reg[ 1h], 1eh
09C4: 41 B6 EE AND   REG[182],238  (0963) ; writing Port_0_DriveMode_2 register
09C7: 43 B6 11 OR    REG[182],17   (0964) 	M8C_SetBank0
                                   (0965) 	and		reg[ 3h], ~1ah
09CA: 41 B8 FC AND   REG[184],252  (0966) 	or		reg[ 3h], 1ah
                                   (0967) ; writing Port_0_GlobalSelect register
09CD: 41 02 E5 AND   REG[2],229    (0968) 	and		reg[ 2h], ~1ah
09D0: 43 02 1A OR    REG[2],26     (0969) ; writing Row_0_LogicSelect_0 register
                                   (0970) 	and		reg[b3h], ~ fh
09D3: 41 03 E5 AND   REG[3],229    (0971) 	or		reg[b3h],  3h
                                   (0972) ; writing Row_0_LogicSelect_1 register
09D6: 71 10    OR    F,16          (0973) 	and		reg[b4h], ~ fh
09D8: 41 01 E0 AND   REG[1],224    (0974) 	or		reg[b4h],  3h
09DB: 43 01 01 OR    REG[1],1      (0975) ; writing Row_0_OutputDrive_0 register
                                   (0976) 	and		reg[b5h], ~13h
09DE: 41 00 E0 AND   REG[0],224    (0977) 	or		reg[b5h],  1h
09E1: 43 00 1E OR    REG[0],30     (0978) ; writing Row_0_OutputDrive_1 register
09E4: 70 EF    AND   F,239         (0979) 	and		reg[b6h], ~11h
                                   (0980) ; writing Row_1_InputMux register
09E6: 62 D0 00 MOV   REG[208],0    (0981) 	and		reg[b8h], ~ 3h
09E9: 26 04 DF AND   [4],223       (0982) 	or		reg[b8h],  1h
09EC: 70 EF    AND   F,239         (0983) 
09EE: 20       POP   X             (0984) 	push	x
                                   (0985)     M8C_SetBank0                    ; Force bank 0
                                   (0986)     mov     a, 0                    ; Specify bank 0
09EF: 7F       RET                 (0987)     asr     a                       ; Store in carry flag
                                   (0988)                                     ; Load bank 0 table:
                                   (0989)     mov     A, >LoadConfigTBL_response2_Bank0
                                   (0990)     mov     X, <LoadConfigTBL_response2_Bank0
                                   (0991)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0992) 
                                   (0993)     mov     a, 1                    ; Specify bank 1
                                   (0994)     asr     a                       ; Store in carry flag
                                   (0995)                                     ; Load bank 1 table:
                                   (0996)     mov     A, >LoadConfigTBL_response2_Bank1
                                   (0997)     mov     X, <LoadConfigTBL_response2_Bank1
                                   (0998)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0999) 
                                   (1000) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1001) ; set config active bit
                                   (1002) 	or		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
                                   (1003)     M8C_SetBank0                    ; Force return to bank 0
                                   (1004) 	pop		x
                                   (1005) 
                                   (1006)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1007)     ret
                                   (1008) 
                                   (1009) ;---------------------------------------------------------------------------
                                   (1010) ; Unload Configuration response2
09F0: 71 10    OR    F,16          (1011) ;
                                   (1012) ;    Reset configuration registers for response2
09F2: 41 00 E0 AND   REG[0],224    (1013) ;    to their values as initially configured.
09F5: 43 00 01 OR    REG[0],1      (1014) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1015) ;
09F8: 41 01 E0 AND   REG[1],224    (1016) ;       INPUTS: None.
09FB: 43 01 1E OR    REG[1],30     (1017) ;      RETURNS: Nothing.
                                   (1018) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
09FE: 70 EF    AND   F,239         (1019) ;               modified as may the Page Pointer registers!
0A00: 41 03 E9 AND   REG[3],233    (1020) ;               In the large memory model currently only the page
0A03: 43 03 16 OR    REG[3],22     (1021) ;               pointer registers listed below are modified.  This does
                                   (1022) ;               not guarantee that in future implementations of this
0A06: 41 02 E9 AND   REG[2],233    (1023) ;               function other page pointer registers will not be
                                   (1024) ;               modified.
0A09: 41 B3 F0 AND   REG[179],240  (1025) ;          
0A0C: 43 B3 03 OR    REG[179],3    (1026) ;               Page Pointer Registers Modified: 
                                   (1027) ;               CUR_PP
0A0F: 41 B4 F0 AND   REG[180],240  (1028) ;
0A12: 43 B4 03 OR    REG[180],3    (1029) _UnloadConfig_response2:
                                   (1030)  UnloadConfig_response2:
0A15: 41 B5 EC AND   REG[181],236  (1031)     RAM_PROLOGUE RAM_USE_CLASS_4
0A18: 43 B5 01 OR    REG[181],1    (1032) 
                                   (1033) 	push	x
0A1B: 41 B6 EE AND   REG[182],238  (1034)     M8C_SetBank0                    ; Force bank 0
                                   (1035)     mov     a, 0                    ; Specify bank 0
0A1E: 41 B8 FC AND   REG[184],252  (1036)     asr     a                       ; Store in carry flag
0A21: 43 B8 01 OR    REG[184],1    (1037)                                     ; Bank 0 table address:
                                   (1038)     mov     A, >UnloadConfigTBL_response2_Bank0
0A24: 10       PUSH  X             (1039)     mov     X, <UnloadConfigTBL_response2_Bank0
0A25: 70 EF    AND   F,239         (1040)     lcall   LoadConfig              ; Unload the bank 0 values
0A27: 50 00    MOV   A,0           (1041) 
0A29: 67       ASR   A             (1042)     mov     a, 1                    ; Specify bank 1
                                   (1043)     asr     a                       ; Store in carry flag
0A2A: 50 03    MOV   A,3           (1044)                                     ; Bank 1 table address:
0A2C: 57 35    MOV   X,53          (1045)     mov     A, >UnloadConfigTBL_response2_Bank1
0A2E: 7C 0C 26 LCALL 0x0C26        (1046)     mov     X, <UnloadConfigTBL_response2_Bank1
                                   (1047)     lcall   LoadConfig              ; Unload the bank 1 values
0A31: 50 01    MOV   A,1           (1048) 
0A33: 67       ASR   A             (1049) 	M8C_SetBank0
                                   (1050) ; writing Row_0_LogicSelect_0 register
0A34: 50 03    MOV   A,3           (1051) 	and		reg[b3h], ~ fh
0A36: 57 48    MOV   X,72          (1052) 	or		reg[b3h],  5h
0A38: 7C 0C 26 LCALL 0x0C26        (1053) ; writing Row_0_LogicSelect_1 register
                                   (1054) 	and		reg[b4h], ~ fh
0A3B: 62 D0 00 MOV   REG[208],0    (1055) 	or		reg[b4h],  5h
                                   (1056) ; writing Row_0_OutputDrive_0 register
0A3E: 2E 04 40 OR    [4],64        (1057) 	and		reg[b5h], ~13h
0A41: 70 EF    AND   F,239         (1058) 	or		reg[b5h], 12h
0A43: 20       POP   X             (1059) ; writing Row_0_OutputDrive_1 register
                                   (1060) 	and		reg[b6h], ~11h
                                   (1061) 	or		reg[b6h], 11h
0A44: 7F       RET                 (1062) ; writing Row_1_InputMux register
                                   (1063) 	and		reg[b8h], ~ 3h
                                   (1064) ; writing Port_0_GlobalSelect register
                                   (1065) 	and		reg[ 2h], ~1ah
                                   (1066) 	or		reg[ 2h], 1ah
                                   (1067) ; writing Port_0_DriveMode_2 register
                                   (1068) 	and		reg[ 3h], ~1ah
                                   (1069) ; writing Port_0_DriveMode_1 register
                                   (1070) 	M8C_SetBank1
                                   (1071) 	and		reg[ 1h], ~1fh
                                   (1072) 	or		reg[ 1h],  1h
                                   (1073) ; writing Port_0_DriveMode_0 register
                                   (1074) 	and		reg[ 0h], ~1fh
                                   (1075) 	or		reg[ 0h], 1eh
                                   (1076) 	M8C_SetBank0
                                   (1077) ; clear config active bit
                                   (1078) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1079) 	and		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], ~response2_BIT
                                   (1080)     M8C_SetBank0                    ; Force return to bank 0
                                   (1081) 	pop		x
                                   (1082) 
                                   (1083)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1084)     ret
                                   (1085) 
                                   (1086) ;---------------------------------------------------------------------------
                                   (1087) ; Load Configuration response3
0A45: 10       PUSH  X             (1088) ;
0A46: 70 EF    AND   F,239         (1089) ;    Load configuration registers for response3.
0A48: 50 00    MOV   A,0           (1090) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0A4A: 67       ASR   A             (1091) ;
                                   (1092) ;       INPUTS: None.
0A4B: 50 03    MOV   A,3           (1093) ;      RETURNS: Nothing.
0A4D: 57 5B    MOV   X,91          (1094) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A4F: 7C 0C 26 LCALL 0x0C26        (1095) ;               modified as may the Page Pointer registers!
                                   (1096) ;               In the large memory model currently only the page
0A52: 50 01    MOV   A,1           (1097) ;               pointer registers listed below are modified.  This does
0A54: 67       ASR   A             (1098) ;               not guarantee that in future implementations of this
                                   (1099) ;               function other page pointer registers will not be
0A55: 50 03    MOV   A,3           (1100) ;               modified.
0A57: 57 62    MOV   X,98          (1101) ;          
0A59: 7C 0C 26 LCALL 0x0C26        (1102) ;               Page Pointer Registers Modified: 
                                   (1103) ;               CUR_PP
0A5C: 70 EF    AND   F,239         (1104) ;
                                   (1105) _LoadConfig_response3:
0A5E: 41 B3 F0 AND   REG[179],240  (1106)  LoadConfig_response3:
0A61: 43 B3 05 OR    REG[179],5    (1107)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1108) 	M8C_SetBank1
0A64: 41 B4 F0 AND   REG[180],240  (1109) ; writing Port_0_DriveMode_0 register
0A67: 43 B4 05 OR    REG[180],5    (1110) 	and		reg[ 0h], ~1fh
                                   (1111) 	or		reg[ 0h],  1h
0A6A: 41 B5 EC AND   REG[181],236  (1112) ; writing Port_0_DriveMode_1 register
0A6D: 43 B5 12 OR    REG[181],18   (1113) 	and		reg[ 1h], ~1fh
                                   (1114) 	or		reg[ 1h], 1eh
0A70: 41 B6 EE AND   REG[182],238  (1115) ; writing Port_0_DriveMode_2 register
0A73: 43 B6 11 OR    REG[182],17   (1116) 	M8C_SetBank0
                                   (1117) 	and		reg[ 3h], ~16h
0A76: 41 B8 FC AND   REG[184],252  (1118) 	or		reg[ 3h], 16h
                                   (1119) ; writing Port_0_GlobalSelect register
0A79: 41 02 E9 AND   REG[2],233    (1120) 	and		reg[ 2h], ~16h
0A7C: 43 02 16 OR    REG[2],22     (1121) ; writing Row_0_LogicSelect_0 register
                                   (1122) 	and		reg[b3h], ~ fh
0A7F: 41 03 E9 AND   REG[3],233    (1123) 	or		reg[b3h],  3h
                                   (1124) ; writing Row_0_LogicSelect_1 register
0A82: 71 10    OR    F,16          (1125) 	and		reg[b4h], ~ fh
0A84: 41 01 E0 AND   REG[1],224    (1126) 	or		reg[b4h],  3h
0A87: 43 01 01 OR    REG[1],1      (1127) ; writing Row_0_OutputDrive_0 register
                                   (1128) 	and		reg[b5h], ~13h
0A8A: 41 00 E0 AND   REG[0],224    (1129) 	or		reg[b5h],  1h
0A8D: 43 00 1E OR    REG[0],30     (1130) ; writing Row_0_OutputDrive_1 register
0A90: 70 EF    AND   F,239         (1131) 	and		reg[b6h], ~11h
                                   (1132) ; writing Row_1_InputMux register
0A92: 62 D0 00 MOV   REG[208],0    (1133) 	and		reg[b8h], ~ 3h
0A95: 26 04 BF AND   [4],191       (1134) 	or		reg[b8h],  1h
0A98: 70 EF    AND   F,239         (1135) 
0A9A: 20       POP   X             (1136) 	push	x
                                   (1137)     M8C_SetBank0                    ; Force bank 0
                                   (1138)     mov     a, 0                    ; Specify bank 0
0A9B: 7F       RET                 (1139)     asr     a                       ; Store in carry flag
                                   (1140)                                     ; Load bank 0 table:
                                   (1141)     mov     A, >LoadConfigTBL_response3_Bank0
                                   (1142)     mov     X, <LoadConfigTBL_response3_Bank0
                                   (1143)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1144) 
                                   (1145)     mov     a, 1                    ; Specify bank 1
                                   (1146)     asr     a                       ; Store in carry flag
                                   (1147)                                     ; Load bank 1 table:
                                   (1148)     mov     A, >LoadConfigTBL_response3_Bank1
                                   (1149)     mov     X, <LoadConfigTBL_response3_Bank1
                                   (1150)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1151) 
                                   (1152) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1153) ; set config active bit
                                   (1154) 	or		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
                                   (1155)     M8C_SetBank0                    ; Force return to bank 0
                                   (1156) 	pop		x
                                   (1157) 
                                   (1158)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1159)     ret
                                   (1160) 
                                   (1161) ;---------------------------------------------------------------------------
                                   (1162) ; Unload Configuration response3
0A9C: 71 10    OR    F,16          (1163) ;
                                   (1164) ;    Reset configuration registers for response3
0A9E: 41 00 E0 AND   REG[0],224    (1165) ;    to their values as initially configured.
0AA1: 43 00 01 OR    REG[0],1      (1166) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1167) ;
0AA4: 41 01 E0 AND   REG[1],224    (1168) ;       INPUTS: None.
0AA7: 43 01 1E OR    REG[1],30     (1169) ;      RETURNS: Nothing.
                                   (1170) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AAA: 70 EF    AND   F,239         (1171) ;               modified as may the Page Pointer registers!
0AAC: 41 03 F1 AND   REG[3],241    (1172) ;               In the large memory model currently only the page
0AAF: 43 03 0E OR    REG[3],14     (1173) ;               pointer registers listed below are modified.  This does
                                   (1174) ;               not guarantee that in future implementations of this
0AB2: 41 02 F1 AND   REG[2],241    (1175) ;               function other page pointer registers will not be
                                   (1176) ;               modified.
0AB5: 41 B0 FC AND   REG[176],252  (1177) ;          
0AB8: 43 B0 01 OR    REG[176],1    (1178) ;               Page Pointer Registers Modified: 
                                   (1179) ;               CUR_PP
0ABB: 41 B3 F0 AND   REG[179],240  (1180) ;
0ABE: 43 B3 03 OR    REG[179],3    (1181) _UnloadConfig_response3:
                                   (1182)  UnloadConfig_response3:
0AC1: 41 B4 F0 AND   REG[180],240  (1183)     RAM_PROLOGUE RAM_USE_CLASS_4
0AC4: 43 B4 03 OR    REG[180],3    (1184) 
                                   (1185) 	push	x
0AC7: 41 B5 EC AND   REG[181],236  (1186)     M8C_SetBank0                    ; Force bank 0
0ACA: 43 B5 01 OR    REG[181],1    (1187)     mov     a, 0                    ; Specify bank 0
                                   (1188)     asr     a                       ; Store in carry flag
0ACD: 41 B6 EE AND   REG[182],238  (1189)                                     ; Bank 0 table address:
                                   (1190)     mov     A, >UnloadConfigTBL_response3_Bank0
0AD0: 41 B8 FC AND   REG[184],252  (1191)     mov     X, <UnloadConfigTBL_response3_Bank0
0AD3: 43 B8 01 OR    REG[184],1    (1192)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1193) 
0AD6: 10       PUSH  X             (1194)     mov     a, 1                    ; Specify bank 1
0AD7: 70 EF    AND   F,239         (1195)     asr     a                       ; Store in carry flag
0AD9: 50 00    MOV   A,0           (1196)                                     ; Bank 1 table address:
0ADB: 67       ASR   A             (1197)     mov     A, >UnloadConfigTBL_response3_Bank1
                                   (1198)     mov     X, <UnloadConfigTBL_response3_Bank1
0ADC: 50 03    MOV   A,3           (1199)     lcall   LoadConfig              ; Unload the bank 1 values
0ADE: 57 76    MOV   X,118         (1200) 
0AE0: 7C 0C 26 LCALL 0x0C26        (1201) 	M8C_SetBank0
                                   (1202) ; writing Row_0_LogicSelect_0 register
0AE3: 50 01    MOV   A,1           (1203) 	and		reg[b3h], ~ fh
0AE5: 67       ASR   A             (1204) 	or		reg[b3h],  5h
                                   (1205) ; writing Row_0_LogicSelect_1 register
0AE6: 50 03    MOV   A,3           (1206) 	and		reg[b4h], ~ fh
0AE8: 57 89    MOV   X,137         (1207) 	or		reg[b4h],  5h
0AEA: 7C 0C 26 LCALL 0x0C26        (1208) ; writing Row_0_OutputDrive_0 register
                                   (1209) 	and		reg[b5h], ~13h
0AED: 62 D0 00 MOV   REG[208],0    (1210) 	or		reg[b5h], 12h
                                   (1211) ; writing Row_0_OutputDrive_1 register
0AF0: 2E 04 80 OR    [4],128       (1212) 	and		reg[b6h], ~11h
0AF3: 70 EF    AND   F,239         (1213) 	or		reg[b6h], 11h
0AF5: 20       POP   X             (1214) ; writing Row_1_InputMux register
                                   (1215) 	and		reg[b8h], ~ 3h
                                   (1216) ; writing Port_0_GlobalSelect register
0AF6: 7F       RET                 (1217) 	and		reg[ 2h], ~16h
                                   (1218) 	or		reg[ 2h], 16h
                                   (1219) ; writing Port_0_DriveMode_2 register
                                   (1220) 	and		reg[ 3h], ~16h
                                   (1221) ; writing Port_0_DriveMode_1 register
                                   (1222) 	M8C_SetBank1
                                   (1223) 	and		reg[ 1h], ~1fh
                                   (1224) 	or		reg[ 1h],  1h
                                   (1225) ; writing Port_0_DriveMode_0 register
                                   (1226) 	and		reg[ 0h], ~1fh
                                   (1227) 	or		reg[ 0h], 1eh
                                   (1228) 	M8C_SetBank0
                                   (1229) ; clear config active bit
                                   (1230) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1231) 	and		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], ~response3_BIT
                                   (1232)     M8C_SetBank0                    ; Force return to bank 0
                                   (1233) 	pop		x
                                   (1234) 
                                   (1235)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1236)     ret
                                   (1237) 
                                   (1238) ;---------------------------------------------------------------------------
                                   (1239) ; Load Configuration response4
                                   (1240) ;
                                   (1241) ;    Load configuration registers for response4.
                                   (1242) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0AF7: 10       PUSH  X             (1243) ;
0AF8: 70 EF    AND   F,239         (1244) ;       INPUTS: None.
0AFA: 50 00    MOV   A,0           (1245) ;      RETURNS: Nothing.
0AFC: 67       ASR   A             (1246) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (1247) ;               modified as may the Page Pointer registers!
0AFD: 50 03    MOV   A,3           (1248) ;               In the large memory model currently only the page
0AFF: 57 9C    MOV   X,156         (1249) ;               pointer registers listed below are modified.  This does
0B01: 7C 0C 26 LCALL 0x0C26        (1250) ;               not guarantee that in future implementations of this
                                   (1251) ;               function other page pointer registers will not be
0B04: 50 01    MOV   A,1           (1252) ;               modified.
0B06: 67       ASR   A             (1253) ;          
                                   (1254) ;               Page Pointer Registers Modified: 
0B07: 50 03    MOV   A,3           (1255) ;               CUR_PP
0B09: 57 A3    MOV   X,163         (1256) ;
0B0B: 7C 0C 26 LCALL 0x0C26        (1257) _LoadConfig_response4:
                                   (1258)  LoadConfig_response4:
0B0E: 70 EF    AND   F,239         (1259)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1260) 	M8C_SetBank1
0B10: 41 B0 FC AND   REG[176],252  (1261) ; writing Port_0_DriveMode_0 register
                                   (1262) 	and		reg[ 0h], ~1fh
0B13: 41 B3 F0 AND   REG[179],240  (1263) 	or		reg[ 0h],  1h
0B16: 43 B3 05 OR    REG[179],5    (1264) ; writing Port_0_DriveMode_1 register
                                   (1265) 	and		reg[ 1h], ~1fh
0B19: 41 B4 F0 AND   REG[180],240  (1266) 	or		reg[ 1h], 1eh
0B1C: 43 B4 05 OR    REG[180],5    (1267) ; writing Port_0_DriveMode_2 register
                                   (1268) 	M8C_SetBank0
0B1F: 41 B5 EC AND   REG[181],236  (1269) 	and		reg[ 3h], ~ eh
0B22: 43 B5 12 OR    REG[181],18   (1270) 	or		reg[ 3h],  eh
                                   (1271) ; writing Port_0_GlobalSelect register
0B25: 41 B6 EE AND   REG[182],238  (1272) 	and		reg[ 2h], ~ eh
0B28: 43 B6 11 OR    REG[182],17   (1273) ; writing Row_0_InputMux register
                                   (1274) 	and		reg[b0h], ~ 3h
0B2B: 41 B8 FC AND   REG[184],252  (1275) 	or		reg[b0h],  1h
                                   (1276) ; writing Row_0_LogicSelect_0 register
0B2E: 41 02 F1 AND   REG[2],241    (1277) 	and		reg[b3h], ~ fh
0B31: 43 02 0E OR    REG[2],14     (1278) 	or		reg[b3h],  3h
                                   (1279) ; writing Row_0_LogicSelect_1 register
0B34: 41 03 F1 AND   REG[3],241    (1280) 	and		reg[b4h], ~ fh
                                   (1281) 	or		reg[b4h],  3h
0B37: 71 10    OR    F,16          (1282) ; writing Row_0_OutputDrive_0 register
0B39: 41 01 E0 AND   REG[1],224    (1283) 	and		reg[b5h], ~13h
0B3C: 43 01 01 OR    REG[1],1      (1284) 	or		reg[b5h],  1h
                                   (1285) ; writing Row_0_OutputDrive_1 register
0B3F: 41 00 E0 AND   REG[0],224    (1286) 	and		reg[b6h], ~11h
0B42: 43 00 1E OR    REG[0],30     (1287) ; writing Row_1_InputMux register
0B45: 70 EF    AND   F,239         (1288) 	and		reg[b8h], ~ 3h
                                   (1289) 	or		reg[b8h],  1h
0B47: 62 D0 00 MOV   REG[208],0    (1290) 
0B4A: 26 04 7F AND   [4],127       (1291) 	push	x
0B4D: 70 EF    AND   F,239         (1292)     M8C_SetBank0                    ; Force bank 0
0B4F: 20       POP   X             (1293)     mov     a, 0                    ; Specify bank 0
                                   (1294)     asr     a                       ; Store in carry flag
                                   (1295)                                     ; Load bank 0 table:
0B50: 7F       RET                 (1296)     mov     A, >LoadConfigTBL_response4_Bank0
                                   (1297)     mov     X, <LoadConfigTBL_response4_Bank0
                                   (1298)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1299) 
                                   (1300)     mov     a, 1                    ; Specify bank 1
                                   (1301)     asr     a                       ; Store in carry flag
                                   (1302)                                     ; Load bank 1 table:
                                   (1303)     mov     A, >LoadConfigTBL_response4_Bank1
                                   (1304)     mov     X, <LoadConfigTBL_response4_Bank1
                                   (1305)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1306) 
                                   (1307) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1308) ; set config active bit
                                   (1309) 	or		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
                                   (1310)     M8C_SetBank0                    ; Force return to bank 0
                                   (1311) 	pop		x
                                   (1312) 
                                   (1313)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1314)     ret
                                   (1315) 
                                   (1316) ;---------------------------------------------------------------------------
                                   (1317) ; Unload Configuration response4
                                   (1318) ;
                                   (1319) ;    Reset configuration registers for response4
0B51: 71 10    OR    F,16          (1320) ;    to their values as initially configured.
                                   (1321) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0B53: 41 00 E0 AND   REG[0],224    (1322) ;
0B56: 43 00 01 OR    REG[0],1      (1323) ;       INPUTS: None.
                                   (1324) ;      RETURNS: Nothing.
0B59: 41 01 E0 AND   REG[1],224    (1325) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0B5C: 43 01 1E OR    REG[1],30     (1326) ;               modified as may the Page Pointer registers!
                                   (1327) ;               In the large memory model currently only the page
0B5F: 70 EF    AND   F,239         (1328) ;               pointer registers listed below are modified.  This does
0B61: 41 03 E1 AND   REG[3],225    (1329) ;               not guarantee that in future implementations of this
0B64: 43 03 1E OR    REG[3],30     (1330) ;               function other page pointer registers will not be
                                   (1331) ;               modified.
0B67: 41 02 E1 AND   REG[2],225    (1332) ;          
                                   (1333) ;               Page Pointer Registers Modified: 
0B6A: 41 B3 F0 AND   REG[179],240  (1334) ;               CUR_PP
0B6D: 43 B3 03 OR    REG[179],3    (1335) ;
                                   (1336) _UnloadConfig_response4:
0B70: 41 B4 F0 AND   REG[180],240  (1337)  UnloadConfig_response4:
0B73: 43 B4 03 OR    REG[180],3    (1338)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1339) 
0B76: 41 B5 EC AND   REG[181],236  (1340) 	push	x
0B79: 43 B5 01 OR    REG[181],1    (1341)     M8C_SetBank0                    ; Force bank 0
                                   (1342)     mov     a, 0                    ; Specify bank 0
0B7C: 41 B6 EE AND   REG[182],238  (1343)     asr     a                       ; Store in carry flag
                                   (1344)                                     ; Bank 0 table address:
0B7F: 41 B8 FC AND   REG[184],252  (1345)     mov     A, >UnloadConfigTBL_response4_Bank0
0B82: 43 B8 01 OR    REG[184],1    (1346)     mov     X, <UnloadConfigTBL_response4_Bank0
                                   (1347)     lcall   LoadConfig              ; Unload the bank 0 values
0B85: 10       PUSH  X             (1348) 
0B86: 70 EF    AND   F,239         (1349)     mov     a, 1                    ; Specify bank 1
0B88: 50 00    MOV   A,0           (1350)     asr     a                       ; Store in carry flag
0B8A: 67       ASR   A             (1351)                                     ; Bank 1 table address:
                                   (1352)     mov     A, >UnloadConfigTBL_response4_Bank1
0B8B: 50 03    MOV   A,3           (1353)     mov     X, <UnloadConfigTBL_response4_Bank1
0B8D: 57 B7    MOV   X,183         (1354)     lcall   LoadConfig              ; Unload the bank 1 values
0B8F: 7C 0C 26 LCALL 0x0C26        (1355) 
                                   (1356) 	M8C_SetBank0
0B92: 50 01    MOV   A,1           (1357) ; writing Row_0_InputMux register
0B94: 67       ASR   A             (1358) 	and		reg[b0h], ~ 3h
                                   (1359) ; writing Row_0_LogicSelect_0 register
0B95: 50 03    MOV   A,3           (1360) 	and		reg[b3h], ~ fh
0B97: 57 BE    MOV   X,190         (1361) 	or		reg[b3h],  5h
0B99: 7C 0C 26 LCALL 0x0C26        (1362) ; writing Row_0_LogicSelect_1 register
                                   (1363) 	and		reg[b4h], ~ fh
0B9C: 62 D0 00 MOV   REG[208],0    (1364) 	or		reg[b4h],  5h
                                   (1365) ; writing Row_0_OutputDrive_0 register
0B9F: 2E 05 01 OR    [5],1         (1366) 	and		reg[b5h], ~13h
0BA2: 70 EF    AND   F,239         (1367) 	or		reg[b5h], 12h
0BA4: 20       POP   X             (1368) ; writing Row_0_OutputDrive_1 register
                                   (1369) 	and		reg[b6h], ~11h
                                   (1370) 	or		reg[b6h], 11h
0BA5: 7F       RET                 (1371) ; writing Row_1_InputMux register
                                   (1372) 	and		reg[b8h], ~ 3h
                                   (1373) ; writing Port_0_GlobalSelect register
                                   (1374) 	and		reg[ 2h], ~ eh
                                   (1375) 	or		reg[ 2h],  eh
                                   (1376) ; writing Port_0_DriveMode_2 register
                                   (1377) 	and		reg[ 3h], ~ eh
                                   (1378) ; writing Port_0_DriveMode_1 register
                                   (1379) 	M8C_SetBank1
                                   (1380) 	and		reg[ 1h], ~1fh
                                   (1381) 	or		reg[ 1h],  1h
                                   (1382) ; writing Port_0_DriveMode_0 register
                                   (1383) 	and		reg[ 0h], ~1fh
                                   (1384) 	or		reg[ 0h], 1eh
                                   (1385) 	M8C_SetBank0
                                   (1386) ; clear config active bit
                                   (1387) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1388) 	and		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], ~response4_BIT
                                   (1389)     M8C_SetBank0                    ; Force return to bank 0
                                   (1390) 	pop		x
                                   (1391) 
                                   (1392)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1393)     ret
                                   (1394) 
                                   (1395) ;---------------------------------------------------------------------------
                                   (1396) ; Load Configuration servo_transmit
0BA6: 10       PUSH  X             (1397) ;
0BA7: 70 EF    AND   F,239         (1398) ;    Load configuration registers for servo_transmit.
0BA9: 50 00    MOV   A,0           (1399) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0BAB: 67       ASR   A             (1400) ;
                                   (1401) ;       INPUTS: None.
0BAC: 50 03    MOV   A,3           (1402) ;      RETURNS: Nothing.
0BAE: 57 C5    MOV   X,197         (1403) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0BB0: 7C 0C 26 LCALL 0x0C26        (1404) ;               modified as may the Page Pointer registers!
                                   (1405) ;               In the large memory model currently only the page
0BB3: 50 01    MOV   A,1           (1406) ;               pointer registers listed below are modified.  This does
0BB5: 67       ASR   A             (1407) ;               not guarantee that in future implementations of this
                                   (1408) ;               function other page pointer registers will not be
0BB6: 50 03    MOV   A,3           (1409) ;               modified.
0BB8: 57 C8    MOV   X,200         (1410) ;          
0BBA: 7C 0C 26 LCALL 0x0C26        (1411) ;               Page Pointer Registers Modified: 
                                   (1412) ;               CUR_PP
0BBD: 70 EF    AND   F,239         (1413) ;
                                   (1414) _LoadConfig_servo_transmit:
0BBF: 41 B3 F0 AND   REG[179],240  (1415)  LoadConfig_servo_transmit:
0BC2: 43 B3 05 OR    REG[179],5    (1416)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1417) 	M8C_SetBank1
0BC5: 41 B4 F0 AND   REG[180],240  (1418) ; writing Port_0_DriveMode_0 register
0BC8: 43 B4 05 OR    REG[180],5    (1419) 	and		reg[ 0h], ~1fh
                                   (1420) 	or		reg[ 0h],  1h
0BCB: 41 B5 EC AND   REG[181],236  (1421) ; writing Port_0_DriveMode_1 register
0BCE: 43 B5 12 OR    REG[181],18   (1422) 	and		reg[ 1h], ~1fh
                                   (1423) 	or		reg[ 1h], 1eh
0BD1: 41 B6 EE AND   REG[182],238  (1424) ; writing Port_0_DriveMode_2 register
0BD4: 43 B6 11 OR    REG[182],17   (1425) 	M8C_SetBank0
                                   (1426) 	and		reg[ 3h], ~1eh
0BD7: 41 B8 FC AND   REG[184],252  (1427) 	or		reg[ 3h], 1eh
                                   (1428) ; writing Port_0_GlobalSelect register
0BDA: 41 02 E1 AND   REG[2],225    (1429) 	and		reg[ 2h], ~1eh
0BDD: 43 02 1E OR    REG[2],30     (1430) ; writing Row_0_LogicSelect_0 register
                                   (1431) 	and		reg[b3h], ~ fh
0BE0: 41 03 E1 AND   REG[3],225    (1432) 	or		reg[b3h],  3h
                                   (1433) ; writing Row_0_LogicSelect_1 register
0BE3: 71 10    OR    F,16          (1434) 	and		reg[b4h], ~ fh
0BE5: 41 01 E0 AND   REG[1],224    (1435) 	or		reg[b4h],  3h
0BE8: 43 01 01 OR    REG[1],1      (1436) ; writing Row_0_OutputDrive_0 register
                                   (1437) 	and		reg[b5h], ~13h
0BEB: 41 00 E0 AND   REG[0],224    (1438) 	or		reg[b5h],  1h
0BEE: 43 00 1E OR    REG[0],30     (1439) ; writing Row_0_OutputDrive_1 register
0BF1: 70 EF    AND   F,239         (1440) 	and		reg[b6h], ~11h
                                   (1441) ; writing Row_1_InputMux register
0BF3: 62 D0 00 MOV   REG[208],0    (1442) 	and		reg[b8h], ~ 3h
0BF6: 26 05 FE AND   [5],254       (1443) 	or		reg[b8h],  1h
0BF9: 70 EF    AND   F,239         (1444) 
0BFB: 20       POP   X             (1445) 	push	x
                                   (1446)     M8C_SetBank0                    ; Force bank 0
                                   (1447)     mov     a, 0                    ; Specify bank 0
0BFC: 7F       RET                 (1448)     asr     a                       ; Store in carry flag
                                   (1449)                                     ; Load bank 0 table:
                                   (1450)     mov     A, >LoadConfigTBL_servo_transmit_Bank0
                                   (1451)     mov     X, <LoadConfigTBL_servo_transmit_Bank0
                                   (1452)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1453) 
                                   (1454)     mov     a, 1                    ; Specify bank 1
                                   (1455)     asr     a                       ; Store in carry flag
                                   (1456)                                     ; Load bank 1 table:
                                   (1457)     mov     A, >LoadConfigTBL_servo_transmit_Bank1
                                   (1458)     mov     X, <LoadConfigTBL_servo_transmit_Bank1
                                   (1459)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1460) 
                                   (1461) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1462) ; set config active bit
                                   (1463) 	or		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
                                   (1464)     M8C_SetBank0                    ; Force return to bank 0
                                   (1465) 	pop		x
                                   (1466) 
                                   (1467)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1468)     ret
                                   (1469) 
                                   (1470) ;---------------------------------------------------------------------------
                                   (1471) ; Unload Configuration servo_transmit
                                   (1472) ;
                                   (1473) ;    Reset configuration registers for servo_transmit
0BFD: 10       PUSH  X             (1474) ;    to their values as initially configured.
0BFE: 70 EF    AND   F,239         (1475) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C00: 50 00    MOV   A,0           (1476) ;
0C02: 67       ASR   A             (1477) ;       INPUTS: None.
                                   (1478) ;      RETURNS: Nothing.
0C03: 50 05    MOV   A,5           (1479) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C05: 57 72    MOV   X,114         (1480) ;               modified as may the Page Pointer registers!
0C07: 7C 0C 26 LCALL 0x0C26        (1481) ;               In the large memory model currently only the page
                                   (1482) ;               pointer registers listed below are modified.  This does
0C0A: 50 01    MOV   A,1           (1483) ;               not guarantee that in future implementations of this
0C0C: 67       ASR   A             (1484) ;               function other page pointer registers will not be
                                   (1485) ;               modified.
0C0D: 50 05    MOV   A,5           (1486) ;          
0C0F: 57 F3    MOV   X,243         (1487) ;               Page Pointer Registers Modified: 
0C11: 7C 0C 26 LCALL 0x0C26        (1488) ;               CUR_PP
                                   (1489) ;
0C14: 70 EF    AND   F,239         (1490) _UnloadConfig_servo_transmit:
                                   (1491)  UnloadConfig_servo_transmit:
0C16: 62 D0 00 MOV   REG[208],0    (1492)     RAM_PROLOGUE RAM_USE_CLASS_4
0C19: 55 04 00 MOV   [4],0         (1493) 
0C1C: 62 D0 00 MOV   REG[208],0    (1494) 	push	x
0C1F: 55 05 00 MOV   [5],0         (1495)     M8C_SetBank0                    ; Force bank 0
0C22: 70 EF    AND   F,239         (1496)     mov     a, 0                    ; Specify bank 0
0C24: 20       POP   X             (1497)     asr     a                       ; Store in carry flag
                                   (1498)                                     ; Bank 0 table address:
                                   (1499)     mov     A, >UnloadConfigTBL_servo_transmit_Bank0
0C25: 7F       RET                 (1500)     mov     X, <UnloadConfigTBL_servo_transmit_Bank0
                                   (1501)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1502) 
                                   (1503)     mov     a, 1                    ; Specify bank 1
                                   (1504)     asr     a                       ; Store in carry flag
                                   (1505)                                     ; Bank 1 table address:
                                   (1506)     mov     A, >UnloadConfigTBL_servo_transmit_Bank1
                                   (1507)     mov     X, <UnloadConfigTBL_servo_transmit_Bank1
                                   (1508)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1509) 
                                   (1510) 	M8C_SetBank0
                                   (1511) ; writing Row_0_LogicSelect_0 register
                                   (1512) 	and		reg[b3h], ~ fh
                                   (1513) 	or		reg[b3h],  5h
                                   (1514) ; writing Row_0_LogicSelect_1 register
                                   (1515) 	and		reg[b4h], ~ fh
                                   (1516) 	or		reg[b4h],  5h
                                   (1517) ; writing Row_0_OutputDrive_0 register
                                   (1518) 	and		reg[b5h], ~13h
                                   (1519) 	or		reg[b5h], 12h
                                   (1520) ; writing Row_0_OutputDrive_1 register
                                   (1521) 	and		reg[b6h], ~11h
0C26: 38 02    ADD   SP,2          (1522) 	or		reg[b6h], 11h
0C28: 10       PUSH  X             (1523) ; writing Row_1_InputMux register
0C29: 08       PUSH  A             (1524) 	and		reg[b8h], ~ 3h
0C2A: 4F       MOV   X,SP          (1525) ; writing Port_0_GlobalSelect register
0C2B: 56 FC 00 MOV   [X-4],0       (1526) 	and		reg[ 2h], ~1eh
0C2E: D0 04    JNC   0x0C33        (1527) 	or		reg[ 2h], 1eh
0C30: 56 FC 01 MOV   [X-4],1       (1528) ; writing Port_0_DriveMode_2 register
                                   (1529) 	and		reg[ 3h], ~1eh
0C33: 18       POP   A             (1530) ; writing Port_0_DriveMode_1 register
0C34: 20       POP   X             (1531) 	M8C_SetBank1
                                   (1532) 	and		reg[ 1h], ~1fh
                                   (1533) 	or		reg[ 1h],  1h
0C35: 70 EF    AND   F,239         (1534) ; writing Port_0_DriveMode_0 register
0C37: 62 E3 00 MOV   REG[227],0    (1535) 	and		reg[ 0h], ~1fh
0C3A: 10       PUSH  X             (1536) 	or		reg[ 0h], 1eh
0C3B: 08       PUSH  A             (1537) 	M8C_SetBank0
0C3C: 28       ROMX                (1538) ; clear config active bit
0C3D: 39 FF    CMP   A,255         (1539) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0C3F: A0 1F    JZ    0x0C5F        (1540) 	and		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], ~servo_transmit_BIT
0C41: 4F       MOV   X,SP          (1541)     M8C_SetBank0                    ; Force return to bank 0
0C42: 48 FC 01 TST   [X-4],1       (1542) 	pop		x
0C45: A0 03    JZ    0x0C49        (1543) 
0C47: 71 10    OR    F,16          (1544)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1545)     ret
0C49: 54 FD    MOV   [X-3],A       (1546) 
0C4B: 18       POP   A             (1547) ;---------------------------------------------------------------------------
0C4C: 20       POP   X             (1548) ; Unload Configuration Total
0C4D: 75       INC   X             (1549) ;
0C4E: 09 00    ADC   A,0           (1550) ;    Reset configuration registers for Total
0C50: 10       PUSH  X             (1551) ;    to their values as initially configured.
0C51: 08       PUSH  A             (1552) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C52: 28       ROMX                (1553) ;
0C53: 4F       MOV   X,SP          (1554) ;       INPUTS: None.
0C54: 59 FD    MOV   X,[X-3]       (1555) ;      RETURNS: Nothing.
0C56: 61 00    MOV   REG[X+0],A    (1556) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C58: 18       POP   A             (1557) ;               modified as may the Page Pointer registers!
0C59: 20       POP   X             (1558) ;               In the large memory model currently only the page
0C5A: 75       INC   X             (1559) ;               pointer registers listed below are modified.  This does
0C5B: 09 00    ADC   A,0           (1560) ;               not guarantee that in future implementations of this
0C5D: 8F D7    JMP   0x0C35        (1561) ;               function other page pointer registers will not be
                                   (1562) ;               modified.
0C5F: 38 FC    ADD   SP,252        (1563) ;          
0C61: 70 3F    AND   F,63
0C63: 71 C0    OR    F,192         (1564) ;               Page Pointer Registers Modified: 
0C66: 08       PUSH  A             (1565) ;               CUR_PP

FILE: lib\wait_recvint.asm
0C67: 10       PUSH  X             (0104) ;;*****************************************************************************
0C68: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: WAIT_RECVINT.asm
0C6A: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0C6B: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0C6D: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0C6F: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0C70: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0C72: B0 04    JNZ   0x0C77        (0115) 
0C74: 18       POP   A             (0116) include "m8c.inc"
0C75: 80 5E    JMP   0x0CD4        (0117) include "memory.inc"
                                   (0118) include "WAIT_RECV.inc"
                                   (0119) 
                                   (0120) 
0C77: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0C78: 21 E0    AND   A,224         (0124) export  _WAIT_RECV_ISR
0C7A: A0 12    JZ    0x0C8D        (0125) 
                                   (0126) 
0C7C: 2C 00    OR    [0],A         (0127) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0128) export  WAIT_RECV_aRxBuffer
0C7E: 49 2A 00 TST   REG[42],0     (0129) export _WAIT_RECV_aRxBuffer
                                   (0130) export  WAIT_RECV_bRxCnt
0C81: 21 20    AND   A,32          (0131) export _WAIT_RECV_bRxCnt
0C83: A0 50    JZ    0x0CD4        (0132) export  WAIT_RECV_fStatus
                                   (0133) export _WAIT_RECV_fStatus
                                   (0134) ENDIF
                                   (0135) 
0C85: 41 2B FE AND   REG[43],254   (0136) 
0C88: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0C8B: 80 48    JMP   0x0CD4        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (WAIT_RECV_RXBUF_ENABLE)
0C8D: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  WAIT_RECV_fStatus:
                                   (0144) _WAIT_RECV_fStatus:      BLK  1
0C8F: 47 00 01 TST   [0],1         (0145)  WAIT_RECV_bRxCnt:
0C92: B0 41    JNZ   0x0CD4        (0146) _WAIT_RECV_bRxCnt:       BLK  1
                                   (0147) AREA WAIT_RECV_RAM(RAM,REL,CON)
0C94: 39 00    CMP   A,0           (0148)  WAIT_RECV_aRxBuffer:    
0C96: B0 14    JNZ   0x0CAB        (0149) _WAIT_RECV_aRxBuffer:    BLK WAIT_RECV_RX_BUFFER_SIZE
0C98: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0C9B: 62 D3 00 MOV   REG[211],0    (0152) 
0C9E: 70 3F    AND   F,63
0CA0: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0CA2: 56 68 00 MOV   [X+104],0     (0154) 
0CA5: 70 3F    AND   F,63
0CA7: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0CA9: 80 2A    JMP   0x0CD4        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0CAB: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0CAE: C0 14    JC    0x0CC3        (0168) 
0CB0: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0CB3: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0CB6: 70 3F    AND   F,63
0CB8: 71 80    OR    F,128         (0172) ;------------------------
0CBA: 56 68 00 MOV   [X+104],0     (0173) 
0CBD: 70 3F    AND   F,63
0CBF: 71 00    OR    F,0           (0174) 
0CC1: 80 12    JMP   0x0CD4        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0CC3: 75       INC   X             (0179) 
0CC4: 5A 01    MOV   [1],X         (0180) 
0CC6: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0CC7: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0CCA: 70 3F    AND   F,63
0CCC: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _WAIT_RECV_ISR
0CCE: 54 68    MOV   [X+104],A     (0185) ;
0CD0: 70 3F    AND   F,63
0CD2: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0CD4: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0CD5: 60 D3    MOV   REG[211],A    (0191) _WAIT_RECV_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0CD7: 20       POP   X             (0195)    ; Insert your custom code below this banner
0CD8: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0CDA: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\wait_recv.asm
                                   (0121) ;;*****************************************************************************
0CDD: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: WAIT_RECV.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "WAIT_RECV.inc"
0CDE: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0CE1: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   WAIT_RECV_EnableInt
                                   (0155) export  _WAIT_RECV_EnableInt
                                   (0156) export   WAIT_RECV_DisableInt
                                   (0157) export  _WAIT_RECV_DisableInt
                                   (0158) export   WAIT_RECV_Start
                                   (0159) export  _WAIT_RECV_Start
                                   (0160) export   WAIT_RECV_Stop
                                   (0161) export  _WAIT_RECV_Stop
                                   (0162) export   WAIT_RECV_bReadRxData
                                   (0163) export  _WAIT_RECV_bReadRxData
                                   (0164) export   WAIT_RECV_bReadRxStatus
                                   (0165) export  _WAIT_RECV_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bWAIT_RECV_ReadRxData
                                   (0170) export _bWAIT_RECV_ReadRxData
                                   (0171) export  bWAIT_RECV_ReadRxStatus
                                   (0172) export _bWAIT_RECV_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  WAIT_RECV_cGetChar
0CE2: 29 01    OR    A,1           (0179) export _WAIT_RECV_cGetChar
0CE4: 60 2B    MOV   REG[43],A     (0180) export  WAIT_RECV_cReadChar
                                   (0181) export _WAIT_RECV_cReadChar
0CE6: 7F       RET                 (0182) export  WAIT_RECV_iReadChar
                                   (0183) export _WAIT_RECV_iReadChar
                                   (0184) 
                                   (0185) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0186) export  WAIT_RECV_CmdReset
                                   (0187) export _WAIT_RECV_CmdReset
                                   (0188) export  WAIT_RECV_bCmdCheck
                                   (0189) export _WAIT_RECV_bCmdCheck
                                   (0190) export  WAIT_RECV_bCmdLength
                                   (0191) export _WAIT_RECV_bCmdLength
                                   (0192) export  WAIT_RECV_bErrCheck
                                   (0193) export _WAIT_RECV_bErrCheck
                                   (0194) 
                                   (0195) export  WAIT_RECV_szGetParam
                                   (0196) export _WAIT_RECV_szGetParam
                                   (0197) export  WAIT_RECV_szGetRestOfParams
                                   (0198) export _WAIT_RECV_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA WAIT_RECV_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0CE7: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0CEA: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: WAIT_RECV_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  WAIT_RECV_EnableInt:
                                   (0238) _WAIT_RECV_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0CEB: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0CED: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: WAIT_RECV_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  WAIT_RECV_DisableInt:
                                   (0267) _WAIT_RECV_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0CEE: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0CF0: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: WAIT_RECV_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  WAIT_RECV_Start:
                                   (0297) _WAIT_RECV_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[WAIT_RECV_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: WAIT_RECV_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0CF1: 49 2B 08 TST   REG[43],8     (0311) ;
0CF4: AF FC    JZ    0x0CF1        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0CF6: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0CF8: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  WAIT_RECV_Stop:
                                   (0326) _WAIT_RECV_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[WAIT_RECV_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: WAIT_RECV_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0CF9: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0CFB: 08       PUSH  A             (0347) ;
0CFC: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0CFE: B0 04    JNZ   0x0D03        (0349) ;    The A and X registers may be modified by this or future implementations
0D00: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0D01: 80 0B    JMP   0x0D0D        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0D03: 5D 2A    MOV   A,REG[42]     (0354) ;
0D05: 4B       SWAP  A,X           (0355)  WAIT_RECV_bReadRxData:
                                   (0356) _WAIT_RECV_bReadRxData:
0D06: 18       POP   A             (0357)  bWAIT_RECV_ReadRxData:
0D07: 21 A0    AND   A,160         (0358) _bWAIT_RECV_ReadRxData:
0D09: B0 03    JNZ   0x0D0D        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0D0B: 4B       SWAP  A,X           (0360)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0D0C: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0D0D: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: WAIT_RECV_bReadRxStatus
                                   (0368) ;
0D0F: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  WAIT_RECV_bReadRxStatus:
                                   (0388) _WAIT_RECV_bReadRxStatus:
                                   (0389)  bWAIT_RECV_ReadRxStatus:
                                   (0390) _bWAIT_RECV_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[WAIT_RECV_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: WAIT_RECV_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0D10: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0D12: 21 E8    AND   A,232         (0408) ;
0D14: 08       PUSH  A             (0409) ;  ARGUMENTS:
0D15: 21 08    AND   A,8           (0410) ;      none
0D17: B0 07    JNZ   0x0D1F        (0411) ;
0D19: 18       POP   A             (0412) ;  RETURNS:
0D1A: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0D1C: 4B       SWAP  A,X           (0414) ;
0D1D: 80 07    JMP   0x0D25        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0D1F: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0D20: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0D22: 4B       SWAP  A,X           (0420) ;    functions.
0D23: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0D25: 7F       RET                 (0426)  WAIT_RECV_cGetChar:
                                   (0427) _WAIT_RECV_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[WAIT_RECV_CONTROL_REG],WAIT_RECV_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: WAIT_RECV_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  WAIT_RECV_cReadChar:
                                   (0463) _WAIT_RECV_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
0D26: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0D29: 55 68 00 MOV   [104],0       (0470)    pop  A
0D2C: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0D2F: 55 E6 00 MOV   [ID+1],0      (0472) 
0D32: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0D35: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
0D38: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0D3B: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(WAIT_RECV_RX_PARITY_ERROR | WAIT_RECV_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_WAIT_RECV_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: WAIT_RECV_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0D3C: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0D3F: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0D41: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0D43: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  WAIT_RECV_iReadChar:
                                   (0523) _WAIT_RECV_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(WAIT_RECV_RX_ERROR|WAIT_RECV_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,WAIT_RECV_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_WAIT_RECV_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,WAIT_RECV_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_WAIT_RECV_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0552) .SECTION
0D44: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0D47: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0D49: 21 F0    AND   A,240         (0555) ;
0D4B: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0D4E: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: WAIT_RECV_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  WAIT_RECV_CmdReset:
0D4F: 62 D0 00 MOV   REG[208],0    (0587) _WAIT_RECV_CmdReset:
0D52: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >WAIT_RECV_aRxBuffer
0D54: 7F       RET                 (0590)    mov [WAIT_RECV_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
                                   (0594)    mov [WAIT_RECV_bRxCnt], 0x00
                                   (0595)    and [WAIT_RECV_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: WAIT_RECV_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  WAIT_RECV_bCmdCheck:
                                   (0628) _WAIT_RECV_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0631)    mov A,  [WAIT_RECV_fStatus]
                                   (0632)    and A, WAIT_RECV_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: WAIT_RECV_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0D55: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0D57: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0D5A: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0D5D: 50 68    MOV   A,104         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0D5F: 02 E6    ADD   A,[ID+1]      (0649) ;                     Returns non-zero value in A if command is valid.
0D61: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0D62: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0D64: B0 04    JNZ   0x0D69        (0653) ;           0x10 => Software Buffer OverRun
0D66: 10       PUSH  X             (0654) ;
0D67: 80 33    JMP   0x0D9B        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0D69: 39 00    CMP   A,0           (0660) ;    functions.
0D6B: B0 11    JNZ   0x0D7D        (0661) ;          
0D6D: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0D6E: 76 E6    INC   [ID+1]        (0663) ;          CUR_PP
0D70: 52 00    MOV   A,[X+0]       (0664) ;
0D72: 3C E6 0F CMP   [ID+1],15     (0665) ;     Error Status is clear when read.
0D75: BF F3    JNZ   0x0D69        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0D77: 10       PUSH  X             (0669) ;
                                   (0670)  WAIT_RECV_bErrCheck:
0D78: 56 00 00 MOV   [X+0],0       (0671) _WAIT_RECV_bErrCheck:
0D7B: 80 1F    JMP   0x0D9B        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0674)    mov A,  [WAIT_RECV_fStatus]
0D7D: 10       PUSH  X             (0675)    and A, WAIT_RECV_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [WAIT_RECV_fStatus], ~WAIT_RECV_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0D7E: 75       INC   X             (0679) .ENDSECTION
0D7F: 76 E6    INC   [ID+1]        (0680) 
0D81: 3C E6 0F CMP   [ID+1],15     (0681) .SECTION
0D84: AF F3    JZ    0x0D78        (0682) ;-----------------------------------------------------------------------------
0D86: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: WAIT_RECV_bCmdLength
0D88: A0 12    JZ    0x0D9B        (0684) ;
0D8A: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0D8C: BF F1    JNZ   0x0D7E        (0686) ;     Get length of command string
                                   (0687) ;
0D8E: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0D91: 76 E6    INC   [ID+1]        (0689) ;     none.
0D93: 3C E6 0F CMP   [ID+1],15     (0690) ;
0D96: B0 04    JNZ   0x0D9B        (0691) ;  RETURNS:
0D98: 55 E6 0F MOV   [ID+1],15     (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0D9B: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0D9C: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0D9D: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0DA0: B0 0B    JNZ   0x0DAC        (0699) ;    functions.
0DA2: 20       POP   X             (0700) ;          
0DA3: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0DA5: 50 00    MOV   A,0           (0702) ;          CUR_PP
0DA7: 70 3F    AND   F,63
0DA9: 71 C0    OR    F,192         (0703) ;
                                   (0704)  WAIT_RECV_bCmdLength:
0DAB: 7F       RET                 (0705) _WAIT_RECV_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
0DAC: 20       POP   X             (0708)    mov A,  [WAIT_RECV_bRxCnt]
0DAD: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0DAF: 70 3F    AND   F,63
0DB1: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0DB3: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: WAIT_RECV_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0DB4: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0DB7: 50 68    MOV   A,104         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0DB9: 02 E6    ADD   A,[ID+1]      (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0DBB: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0DBC: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     WAIT_RECV_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, WAIT_RECV_szGetParam, is
0DC0: 43 E1 04 OR    REG[225],4    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\tx_23.asm
                                   (0109) ;;*****************************************************************************
0DC3: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_23.inc"
0DC4: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0DC7: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_23_SetTxIntMode
                                   (0143) export  _TX_23_SetTxIntMode
                                   (0144) export   TX_23_EnableInt
                                   (0145) export  _TX_23_EnableInt
                                   (0146) export   TX_23_DisableInt
                                   (0147) export  _TX_23_DisableInt
                                   (0148) export   TX_23_Start
                                   (0149) export  _TX_23_Start
                                   (0150) export   TX_23_Stop
                                   (0151) export  _TX_23_Stop
                                   (0152) export   TX_23_SendData
                                   (0153) export  _TX_23_SendData
                                   (0154) export   TX_23_bReadTxStatus
                                   (0155) export  _TX_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_23_ReadTxStatus
                                   (0160) export  _bTX_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_23_PutSHexByte
                                   (0166) export _TX_23_PutSHexByte
                                   (0167) export  TX_23_PutSHexInt
                                   (0168) export _TX_23_PutSHexInt
                                   (0169) 
0DC8: 71 10    OR    F,16          (0170) export  TX_23_CPutString
0DCA: 21 01    AND   A,1           (0171) export _TX_23_CPutString
0DCC: A0 07    JZ    0x0DD4        (0172) export  TX_23_PutString
0DCE: 43 28 10 OR    REG[40],16    (0173) export _TX_23_PutString
0DD1: 70 EF    AND   F,239         (0174) export  TX_23_PutChar
                                   (0175) export _TX_23_PutChar
0DD3: 7F       RET                 (0176) export  TX_23_Write
                                   (0177) export _TX_23_Write
                                   (0178) export  TX_23_CWrite
0DD4: 41 28 EF AND   REG[40],239   (0179) export _TX_23_CWrite
0DD7: 70 EF    AND   F,239         (0180) export  TX_23_PutCRLF
                                   (0181) export _TX_23_PutCRLF 
0DD9: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0DDA: 29 01    OR    A,1           (0211) ;    functions.
0DDC: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_23_EnableInt:
0DDE: 7F       RET                 (0214) _TX_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_23_INT_REG, TX_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0DDF: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0DE2: 7F       RET                 (0242)  TX_23_DisableInt:
                                   (0243) _TX_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_23_INT_REG, TX_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0DE3: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0DE5: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_23_SetTxIntMode:
                                   (0276) _TX_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0DE6: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0DE8: 7F       RET                 (0303) ;
0DE9: 30       HALT  
0DEA: 31 32    XOR   A,50
0DEC: 33 34    XOR   A,[X+52]
0DEE: 35 36    XOR   [X+54],A
0DF0: 37 38 39 XOR   [X+56],57
0DF3: 41 42 43 AND   REG[66],67
0DF6: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_23_Start:
                                   (0317) _TX_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0DF9: 08       PUSH  A             (0335) ;
0DFA: 67       ASR   A             (0336) ;  RETURNS:  none
0DFB: 67       ASR   A             (0337) ;
0DFC: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0DFD: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0DFE: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0E00: FF E7    INDEX 0x0DE9        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0E02: 90 0F    CALL  0x0E13        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0E04: 18       POP   A             (0343) ;    functions.
0E05: 21 0F    AND   A,15          (0344) ;
0E07: FF E0    INDEX 0x0DE9        (0345)  TX_23_Stop:
0E09: 90 08    CALL  0x0E13        (0346) _TX_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0E0B: 7F       RET                 (0348)    and   REG[TX_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_23_SendData:
                                   (0375) _TX_23_SendData:
0E0C: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0E0D: 9F EA    CALL  0x0DF9        (0377)    mov REG[TX_23_TX_BUFFER_REG], A
0E0F: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0E10: 9F E7    CALL  0x0DF9        (0379)    ret
                                   (0380) .ENDSECTION
0E12: 7F       RET                 (0381) 
0E13: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_23_bReadTxStatus:
                                   (0405) _TX_23_bReadTxStatus:
                                   (0406)  bTX_23_ReadTxStatus:
                                   (0407) _bTX_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0E16: AF FC    JZ    0x0E13        (0416) ;  FUNCTION NAME: TX_23_PutSHexByte
0E18: 60 29    MOV   REG[41],A
                                   (0417) ;
0E1A: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_23_PutSHexByte:
                                   (0441) _TX_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_23_HEX_STR                ; Get Hex value
                                   (0450)     call  TX_23_PutChar                ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_23_HEX_STR                ; Get Hex value
                                   (0454)     call  TX_23_PutChar                ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0E1B: 70 BF    AND   F,191         (0456)     ret
0E1D: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0E1F: 52 00    MOV   A,[X+0]       (0459) .SECTION
0E21: A0 06    JZ    0x0E28        (0460) ;-----------------------------------------------------------------------------
0E23: 9F EE    CALL  0x0E13        (0461) ;  FUNCTION NAME: TX_23_PutSHexInt
0E25: 75       INC   X             (0462) ;
0E26: 8F F8    JMP   0x0E1F        (0463) ;  DESCRIPTION:
0E28: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0E2A: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0E2C: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_23_PutSHexInt:
                                   (0482) _TX_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_23_PutSHexByte            ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_23_PutSHexByte            ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0E2D: 70 BF    AND   F,191         (0503) ;  RETURNS:
0E2F: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0E32: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0E33: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0E35: A0 1A    JZ    0x0E50        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0E37: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0E39: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_23_CONTROL_REG], TX_23_TX_BUFFER_EMPTY    ; Check Tx Status
0E3B: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0E3D: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0E3F: 52 00    MOV   A,[X+0]       (0518)    endm
0E41: 49 2B 10 TST   REG[43],16
0E44: AF FC    JZ    0x0E41        (0519) 
0E46: 60 29    MOV   REG[41],A
0E48: 4F       MOV   X,SP          (0520) 
0E49: 62 D3 07 MOV   REG[211],7    (0521)  TX_23_PutChar:
0E4C: 77 FD    INC   [X-3]         (0522) _TX_23_PutChar:
0E4E: 8F E4    JMP   0x0E33        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0E50: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0E52: 71 C0    OR    F,192         (0526)    ret
0E54: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_23_PutString:
                                   (0563) _TX_23_PutString:
0E55: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0E56: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0E59: B0 06    JNZ   0x0E60        (0569)    call  TX_23_PutChar                      ; Send character to Tx port
0E5B: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0E5E: A0 1D    JZ    0x0E7C        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0E60: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0E61: 52 FC    MOV   A,[X-4]       (0575)    ret
0E63: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0E65: 28       ROMX                (0577) 
0E66: 49 2B 10 TST   REG[43],16
0E69: AF FC    JZ    0x0E66        (0578) .SECTION
0E6B: 60 29    MOV   REG[41],A
0E6D: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_23_Write
0E6E: 07 FD 01 ADD   [X-3],1       (0581) ;
0E71: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0E74: 17 FB 01 SUB   [X-5],1       (0585) ;
0E77: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0E7A: 8F DB    JMP   0x0E56        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0E7C: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_23_Write:
                                   (0610) _TX_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0E7D: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0E7E: 10       PUSH  X             (0622)    ENDIF
0E7F: 28       ROMX                (0623) 
0E80: A0 0B    JZ    0x0E8C        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0E82: 9F 8F    CALL  0x0E13        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0E84: 20       POP   X             (0626)    mov   A,[X]
0E85: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0E86: 75       INC   X             (0628)    mov   X, SP
0E87: DF F5    JNC   0x0E7D        (0629)    RAM_SETPAGE_IDX2STK
0E89: 74       INC   A             (0630)    inc   [X+STR_LSB]
0E8A: 8F F2    JMP   0x0E7D        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0E8C: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0E8E: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0E8F: 50 0D    MOV   A,13          (0663) ;
0E91: 9F 80    CALL  0x0E13        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0E93: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0E95: 9F 7C    CALL  0x0E13        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0E99: 43 E1 08 OR    REG[225],8    (0668) 

FILE: lib\tx_014.asm
                                   (0109) ;;*****************************************************************************
0E9C: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_014.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_014.inc"
0E9D: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0EA0: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_014_SetTxIntMode
                                   (0143) export  _TX_014_SetTxIntMode
                                   (0144) export   TX_014_EnableInt
                                   (0145) export  _TX_014_EnableInt
                                   (0146) export   TX_014_DisableInt
                                   (0147) export  _TX_014_DisableInt
                                   (0148) export   TX_014_Start
                                   (0149) export  _TX_014_Start
                                   (0150) export   TX_014_Stop
                                   (0151) export  _TX_014_Stop
                                   (0152) export   TX_014_SendData
                                   (0153) export  _TX_014_SendData
                                   (0154) export   TX_014_bReadTxStatus
                                   (0155) export  _TX_014_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_014_ReadTxStatus
                                   (0160) export  _bTX_014_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_014_PutSHexByte
                                   (0166) export _TX_014_PutSHexByte
                                   (0167) export  TX_014_PutSHexInt
                                   (0168) export _TX_014_PutSHexInt
                                   (0169) 
0EA1: 71 10    OR    F,16          (0170) export  TX_014_CPutString
0EA3: 21 01    AND   A,1           (0171) export _TX_014_CPutString
0EA5: A0 07    JZ    0x0EAD        (0172) export  TX_014_PutString
0EA7: 43 2C 10 OR    REG[44],16    (0173) export _TX_014_PutString
0EAA: 70 EF    AND   F,239         (0174) export  TX_014_PutChar
                                   (0175) export _TX_014_PutChar
0EAC: 7F       RET                 (0176) export  TX_014_Write
                                   (0177) export _TX_014_Write
                                   (0178) export  TX_014_CWrite
0EAD: 41 2C EF AND   REG[44],239   (0179) export _TX_014_CWrite
0EB0: 70 EF    AND   F,239         (0180) export  TX_014_PutCRLF
                                   (0181) export _TX_014_PutCRLF 
0EB2: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_014_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0EB3: 29 01    OR    A,1           (0211) ;    functions.
0EB5: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_014_EnableInt:
0EB7: 7F       RET                 (0214) _TX_014_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_014_INT_REG, TX_014_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_014_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0EB8: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
0EBB: 7F       RET                 (0242)  TX_014_DisableInt:
                                   (0243) _TX_014_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_014_INT_REG, TX_014_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_014_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0EBC: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
0EBE: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_014_SetTxIntMode:
                                   (0276) _TX_014_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_014_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_014_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_014_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_014_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0EBF: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0EC1: 7F       RET                 (0303) ;
0EC2: 30       HALT  
0EC3: 31 32    XOR   A,50
0EC5: 33 34    XOR   A,[X+52]
0EC7: 35 36    XOR   [X+54],A
0EC9: 37 38 39 XOR   [X+56],57
0ECC: 41 42 43 AND   REG[66],67
0ECF: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_014_Start:
                                   (0317) _TX_014_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_014_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_014_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0ED2: 08       PUSH  A             (0335) ;
0ED3: 67       ASR   A             (0336) ;  RETURNS:  none
0ED4: 67       ASR   A             (0337) ;
0ED5: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0ED6: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0ED7: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0ED9: FF E7    INDEX 0x0EC2        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0EDB: 90 0F    CALL  0x0EEC        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0EDD: 18       POP   A             (0343) ;    functions.
0EDE: 21 0F    AND   A,15          (0344) ;
0EE0: FF E0    INDEX 0x0EC2        (0345)  TX_014_Stop:
0EE2: 90 08    CALL  0x0EEC        (0346) _TX_014_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0EE4: 7F       RET                 (0348)    and   REG[TX_014_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_014_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_014_SendData:
                                   (0375) _TX_014_SendData:
0EE5: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0EE6: 9F EA    CALL  0x0ED2        (0377)    mov REG[TX_014_TX_BUFFER_REG], A
0EE8: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0EE9: 9F E7    CALL  0x0ED2        (0379)    ret
                                   (0380) .ENDSECTION
0EEB: 7F       RET                 (0381) 
0EEC: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_014_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_014_bReadTxStatus:
                                   (0405) _TX_014_bReadTxStatus:
                                   (0406)  bTX_014_ReadTxStatus:
                                   (0407) _bTX_014_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_014_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0EEF: AF FC    JZ    0x0EEC        (0416) ;  FUNCTION NAME: TX_014_PutSHexByte
0EF1: 60 2D    MOV   REG[45],A
                                   (0417) ;
0EF3: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_014_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_014_PutSHexByte:
                                   (0441) _TX_014_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_014_HEX_STR               ; Get Hex value
                                   (0450)     call  TX_014_PutChar               ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_014_HEX_STR               ; Get Hex value
                                   (0454)     call  TX_014_PutChar               ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0EF4: 70 BF    AND   F,191         (0456)     ret
0EF6: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0EF8: 52 00    MOV   A,[X+0]       (0459) .SECTION
0EFA: A0 06    JZ    0x0F01        (0460) ;-----------------------------------------------------------------------------
0EFC: 9F EE    CALL  0x0EEC        (0461) ;  FUNCTION NAME: TX_014_PutSHexInt
0EFE: 75       INC   X             (0462) ;
0EFF: 8F F8    JMP   0x0EF8        (0463) ;  DESCRIPTION:
0F01: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0F03: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0F05: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_014_PutSHexInt:
                                   (0482) _TX_014_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_014_PutSHexByte           ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_014_PutSHexByte           ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_014_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0F06: 70 BF    AND   F,191         (0503) ;  RETURNS:
0F08: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0F0B: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0F0C: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0F0E: A0 1A    JZ    0x0F29        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0F10: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0F12: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_014_CONTROL_REG], TX_014_TX_BUFFER_EMPTY    ; Check Tx Status
0F14: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0F16: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_014_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0F18: 52 00    MOV   A,[X+0]       (0518)    endm
0F1A: 49 2F 10 TST   REG[47],16
0F1D: AF FC    JZ    0x0F1A        (0519) 
0F1F: 60 2D    MOV   REG[45],A
0F21: 4F       MOV   X,SP          (0520) 
0F22: 62 D3 07 MOV   REG[211],7    (0521)  TX_014_PutChar:
0F25: 77 FD    INC   [X-3]         (0522) _TX_014_PutChar:
0F27: 8F E4    JMP   0x0F0C        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0F29: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0F2B: 71 C0    OR    F,192         (0526)    ret
0F2D: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_014_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_014_PutString:
                                   (0563) _TX_014_PutString:
0F2E: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0F2F: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0F32: B0 06    JNZ   0x0F39        (0569)    call  TX_014_PutChar                     ; Send character to Tx port
0F34: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0F37: A0 1D    JZ    0x0F55        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0F39: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0F3A: 52 FC    MOV   A,[X-4]       (0575)    ret
0F3C: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0F3E: 28       ROMX                (0577) 
0F3F: 49 2F 10 TST   REG[47],16
0F42: AF FC    JZ    0x0F3F        (0578) .SECTION
0F44: 60 2D    MOV   REG[45],A
0F46: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_014_Write
0F47: 07 FD 01 ADD   [X-3],1       (0581) ;
0F4A: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0F4D: 17 FB 01 SUB   [X-5],1       (0585) ;
0F50: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0F53: 8F DB    JMP   0x0F2F        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0F55: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_014_Write:
                                   (0610) _TX_014_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0F56: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0F57: 10       PUSH  X             (0622)    ENDIF
0F58: 28       ROMX                (0623) 
0F59: A0 0B    JZ    0x0F65        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0F5B: 9F 8F    CALL  0x0EEC        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0F5D: 20       POP   X             (0626)    mov   A,[X]
0F5E: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0F5F: 75       INC   X             (0628)    mov   X, SP
0F60: DF F5    JNC   0x0F56        (0629)    RAM_SETPAGE_IDX2STK
0F62: 74       INC   A             (0630)    inc   [X+STR_LSB]
0F63: 8F F2    JMP   0x0F56        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0F65: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0F67: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_014_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0F68: 50 0D    MOV   A,13          (0663) ;
0F6A: 9F 80    CALL  0x0EEC        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0F6C: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0F6E: 9F 7C    CALL  0x0EEC        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0F71: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\tx_01234_timeout.asm
                                   (0102) ;;*****************************************************************************
0F74: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_01234_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_01234_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0F75: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0F78: 7F       RET                 (0131) export  TX_01234_TIMEOUT_EnableInt
                                   (0132) export _TX_01234_TIMEOUT_EnableInt
                                   (0133) export  TX_01234_TIMEOUT_DisableInt
                                   (0134) export _TX_01234_TIMEOUT_DisableInt
                                   (0135) export  TX_01234_TIMEOUT_Start
                                   (0136) export _TX_01234_TIMEOUT_Start
                                   (0137) export  TX_01234_TIMEOUT_Stop
                                   (0138) export _TX_01234_TIMEOUT_Stop
                                   (0139) export  TX_01234_TIMEOUT_WritePeriod
                                   (0140) export _TX_01234_TIMEOUT_WritePeriod
                                   (0141) export  TX_01234_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_01234_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_01234_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_01234_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_01234_TIMEOUT_wReadTimer
                                   (0146) export _TX_01234_TIMEOUT_wReadTimer
                                   (0147) export  TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
0F79: 43 23 01 OR    REG[35],1     (0157) export _wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0F7C: 7F       RET                 (0159) export  wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA my_response_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_01234_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0F7D: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0F80: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_01234_TIMEOUT_EnableInt:
                                   (0200) _TX_01234_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_01234_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_01234_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0F81: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0F83: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0F84: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0F86: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_01234_TIMEOUT_DisableInt:
                                   (0228) _TX_01234_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_01234_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_01234_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0F87: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0F89: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0F8A: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0F8C: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_01234_TIMEOUT_Start:
                                   (0256) _TX_01234_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_01234_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_01234_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0F8D: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0F8F: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0F90: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0F92: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_01234_TIMEOUT_Stop:
                                   (0284) _TX_01234_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_01234_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_01234_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_01234_TIMEOUT_WritePeriod:
                                   (0313) _TX_01234_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_01234_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_01234_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_01234_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_01234_TIMEOUT_Stop to disable).
0F93: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0F94: 38 03    ADD   SP,3          (0334) ;
0F96: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0F98: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0F99: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0F9B: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0F9C: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0F9E: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0F9F: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0FA1: 5D 26    MOV   A,REG[38]     (0343) ;
0FA3: 54 01    MOV   [X+1],A       (0344)  TX_01234_TIMEOUT_WriteCompareValue:
0FA5: 5D 22    MOV   A,REG[34]     (0345) _TX_01234_TIMEOUT_WriteCompareValue:
0FA7: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0FA9: 50 00    MOV   A,0           (0347)    mov   reg[TX_01234_TIMEOUT_COMPARE_LSB_REG], A
0FAB: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0FAE: A0 03    JZ    0x0FB2        (0349)    mov   reg[TX_01234_TIMEOUT_COMPARE_MSB_REG], A
0FB0: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0FB2: 54 00    MOV   [X+0],A       (0352) 
0FB4: 70 FE    AND   F,254         (0353) .ENDSECTION
0FB6: 41 23 FE AND   REG[35],254   (0354) 
0FB9: 18       POP   A             (0355) 
0FBA: 60 26    MOV   REG[38],A     (0356) .SECTION
0FBC: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0FBD: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadCompareValue
0FBF: 18       POP   A             (0359) ;
0FC0: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0FC2: 18       POP   A             (0361) ;     Reads the Compare registers.
0FC3: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0FC4: 70 3F    AND   F,63
0FC6: 71 C0    OR    F,192         (0363) ;
0FC8: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_01234_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_01234_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0FC9: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0FCB: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0FCD: 5C       MOV   X,A           (0409) ;
0FCE: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0FD2: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\servo_tx.asm
                                   (0109) ;;*****************************************************************************
0FD5: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: SERVO_TX.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "SERVO_TX.inc"
0FD6: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0FD9: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   SERVO_TX_SetTxIntMode
                                   (0143) export  _SERVO_TX_SetTxIntMode
                                   (0144) export   SERVO_TX_EnableInt
                                   (0145) export  _SERVO_TX_EnableInt
                                   (0146) export   SERVO_TX_DisableInt
                                   (0147) export  _SERVO_TX_DisableInt
                                   (0148) export   SERVO_TX_Start
                                   (0149) export  _SERVO_TX_Start
                                   (0150) export   SERVO_TX_Stop
                                   (0151) export  _SERVO_TX_Stop
                                   (0152) export   SERVO_TX_SendData
                                   (0153) export  _SERVO_TX_SendData
                                   (0154) export   SERVO_TX_bReadTxStatus
                                   (0155) export  _SERVO_TX_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bSERVO_TX_ReadTxStatus
                                   (0160) export  _bSERVO_TX_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  SERVO_TX_PutSHexByte
                                   (0166) export _SERVO_TX_PutSHexByte
                                   (0167) export  SERVO_TX_PutSHexInt
                                   (0168) export _SERVO_TX_PutSHexInt
                                   (0169) 
0FDA: 71 10    OR    F,16          (0170) export  SERVO_TX_CPutString
0FDC: 21 01    AND   A,1           (0171) export _SERVO_TX_CPutString
0FDE: A0 07    JZ    0x0FE6        (0172) export  SERVO_TX_PutString
0FE0: 43 28 10 OR    REG[40],16    (0173) export _SERVO_TX_PutString
0FE3: 70 EF    AND   F,239         (0174) export  SERVO_TX_PutChar
                                   (0175) export _SERVO_TX_PutChar
0FE5: 7F       RET                 (0176) export  SERVO_TX_Write
                                   (0177) export _SERVO_TX_Write
                                   (0178) export  SERVO_TX_CWrite
0FE6: 41 28 EF AND   REG[40],239   (0179) export _SERVO_TX_CWrite
0FE9: 70 EF    AND   F,239         (0180) export  SERVO_TX_PutCRLF
                                   (0181) export _SERVO_TX_PutCRLF 
0FEB: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: SERVO_TX_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0FEC: 29 01    OR    A,1           (0211) ;    functions.
0FEE: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  SERVO_TX_EnableInt:
0FF0: 7F       RET                 (0214) _SERVO_TX_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: SERVO_TX_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0FF1: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0FF4: 7F       RET                 (0242)  SERVO_TX_DisableInt:
                                   (0243) _SERVO_TX_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: SERVO_TX_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0FF5: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0FF7: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  SERVO_TX_SetTxIntMode:
                                   (0276) _SERVO_TX_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, SERVO_TX_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[SERVO_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[SERVO_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: SERVO_TX_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0FF8: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0FFA: 7F       RET                 (0303) ;
0FFB: 30       HALT  
0FFC: 31 32    XOR   A,50
0FFE: 33 34    XOR   A,[X+52]
1000: 35 36    XOR   [X+54],A
1002: 37 38 39 XOR   [X+56],57
1005: 41 42 43 AND   REG[66],67
1008: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  SERVO_TX_Start:
                                   (0317) _SERVO_TX_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[SERVO_TX_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: SERVO_TX_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
100B: 08       PUSH  A             (0335) ;
100C: 67       ASR   A             (0336) ;  RETURNS:  none
100D: 67       ASR   A             (0337) ;
100E: 67       ASR   A             (0338) ;  SIDE EFFECTS:
100F: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
1010: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
1012: FF E7    INDEX 0x0FFB        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
1014: 90 0F    CALL  0x1025        (0342) ;    responsibility to perserve their values across calls to fastcall16 
1016: 18       POP   A             (0343) ;    functions.
1017: 21 0F    AND   A,15          (0344) ;
1019: FF E0    INDEX 0x0FFB        (0345)  SERVO_TX_Stop:
101B: 90 08    CALL  0x1025        (0346) _SERVO_TX_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
101D: 7F       RET                 (0348)    and   REG[SERVO_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: SERVO_TX_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  SERVO_TX_SendData:
                                   (0375) _SERVO_TX_SendData:
101E: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
101F: 9F EA    CALL  0x100B        (0377)    mov REG[SERVO_TX_TX_BUFFER_REG], A
1021: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
1022: 9F E7    CALL  0x100B        (0379)    ret
                                   (0380) .ENDSECTION
1024: 7F       RET                 (0381) 
1025: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: SERVO_TX_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  SERVO_TX_bReadTxStatus:
                                   (0405) _SERVO_TX_bReadTxStatus:
                                   (0406)  bSERVO_TX_ReadTxStatus:
                                   (0407) _bSERVO_TX_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[SERVO_TX_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
1028: AF FC    JZ    0x1025        (0416) ;  FUNCTION NAME: SERVO_TX_PutSHexByte
102A: 60 29    MOV   REG[41],A
                                   (0417) ;
102C: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) SERVO_TX_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  SERVO_TX_PutSHexByte:
                                   (0441) _SERVO_TX_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0450)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0454)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
102D: 70 BF    AND   F,191         (0456)     ret
102F: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
1031: 52 00    MOV   A,[X+0]       (0459) .SECTION
1033: A0 06    JZ    0x103A        (0460) ;-----------------------------------------------------------------------------
1035: 9F EE    CALL  0x1025        (0461) ;  FUNCTION NAME: SERVO_TX_PutSHexInt
1037: 75       INC   X             (0462) ;
1038: 8F F8    JMP   0x1031        (0463) ;  DESCRIPTION:
103A: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
103C: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
103E: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  SERVO_TX_PutSHexInt:
                                   (0482) _SERVO_TX_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  SERVO_TX_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  SERVO_TX_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: SERVO_TX_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
103F: 70 BF    AND   F,191         (0503) ;  RETURNS:
1041: 62 D3 07 MOV   REG[211],7    (0504) ;     none
1044: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
1045: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
1047: A0 1A    JZ    0x1062        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
1049: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
104B: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[SERVO_TX_CONTROL_REG], SERVO_TX_TX_BUFFER_EMPTY    ; Check Tx Status
104D: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
104F: 60 D3    MOV   REG[211],A    (0517)    mov REG[SERVO_TX_TX_BUFFER_REG], @Source    ; Write data to Tx Port
1051: 52 00    MOV   A,[X+0]       (0518)    endm
1053: 49 2B 10 TST   REG[43],16
1056: AF FC    JZ    0x1053        (0519) 
1058: 60 29    MOV   REG[41],A
105A: 4F       MOV   X,SP          (0520) 
105B: 62 D3 07 MOV   REG[211],7    (0521)  SERVO_TX_PutChar:
105E: 77 FD    INC   [X-3]         (0522) _SERVO_TX_PutChar:
1060: 8F E4    JMP   0x1045        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
1062: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
1064: 71 C0    OR    F,192         (0526)    ret
1066: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: SERVO_TX_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  SERVO_TX_PutString:
                                   (0563) _SERVO_TX_PutString:
1067: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
1068: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
106B: B0 06    JNZ   0x1072        (0569)    call  SERVO_TX_PutChar                   ; Send character to Tx port
106D: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
1070: A0 1D    JZ    0x108E        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
1072: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
1073: 52 FC    MOV   A,[X-4]       (0575)    ret
1075: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
1077: 28       ROMX                (0577) 
1078: 49 2B 10 TST   REG[43],16
107B: AF FC    JZ    0x1078        (0578) .SECTION
107D: 60 29    MOV   REG[41],A
107F: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: SERVO_TX_Write
1080: 07 FD 01 ADD   [X-3],1       (0581) ;
1083: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
1086: 17 FB 01 SUB   [X-5],1       (0585) ;
1089: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
108C: 8F DB    JMP   0x1068        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
108E: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  SERVO_TX_Write:
                                   (0610) _SERVO_TX_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
108F: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
1090: 10       PUSH  X             (0622)    ENDIF
1091: 28       ROMX                (0623) 
1092: A0 0B    JZ    0x109E        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
1094: 9F 8F    CALL  0x1025        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
1096: 20       POP   X             (0626)    mov   A,[X]
1097: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
1098: 75       INC   X             (0628)    mov   X, SP
1099: DF F5    JNC   0x108F        (0629)    RAM_SETPAGE_IDX2STK
109B: 74       INC   A             (0630)    inc   [X+STR_LSB]
109C: 8F F2    JMP   0x108F        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
109E: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
10A0: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: SERVO_TX_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
10A1: 50 0D    MOV   A,13          (0663) ;
10A3: 9F 80    CALL  0x1025        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
10A5: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
10A7: 9F 7C    CALL  0x1025        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
10AA: 08       PUSH  A             (0668) 

FILE: lib\rx8_2int.asm
10AB: 10       PUSH  X             (0104) ;;*****************************************************************************
10AC: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RX8_2INT.asm
10AE: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
10AF: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
10B1: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
10B3: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
10B4: 21 08    AND   A,8           (0114) ;;*****************************************************************************
10B6: B0 04    JNZ   0x10BB        (0115) 
10B8: 18       POP   A             (0116) include "m8c.inc"
10B9: 80 5E    JMP   0x1118        (0117) include "memory.inc"
                                   (0118) include "RX8_2.inc"
                                   (0119) 
                                   (0120) 
10BB: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
10BC: 21 E0    AND   A,224         (0124) export  _RX8_2_ISR
10BE: A0 12    JZ    0x10D1        (0125) 
                                   (0126) 
10C0: 2C 02    OR    [2],A         (0127) IF (RX8_2_RXBUF_ENABLE)
                                   (0128) export  RX8_2_aRxBuffer
10C2: 49 2E 00 TST   REG[46],0     (0129) export _RX8_2_aRxBuffer
                                   (0130) export  RX8_2_bRxCnt
10C5: 21 20    AND   A,32          (0131) export _RX8_2_bRxCnt
10C7: A0 50    JZ    0x1118        (0132) export  RX8_2_fStatus
                                   (0133) export _RX8_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
10C9: 41 2F FE AND   REG[47],254   (0136) 
10CC: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
10CF: 80 48    JMP   0x1118        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RX8_2_RXBUF_ENABLE)
10D1: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RX8_2_fStatus:
                                   (0144) _RX8_2_fStatus:      BLK  1
10D3: 47 02 01 TST   [2],1         (0145)  RX8_2_bRxCnt:
10D6: B0 41    JNZ   0x1118        (0146) _RX8_2_bRxCnt:       BLK  1
                                   (0147) AREA RX8_2_RAM(RAM,REL,CON)
10D8: 39 00    CMP   A,0           (0148)  RX8_2_aRxBuffer:    
10DA: B0 14    JNZ   0x10EF        (0149) _RX8_2_aRxBuffer:    BLK RX8_2_RX_BUFFER_SIZE
10DC: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
10DF: 62 D3 00 MOV   REG[211],0    (0152) 
10E2: 70 3F    AND   F,63
10E4: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
10E6: 56 58 00 MOV   [X+88],0      (0154) 
10E9: 70 3F    AND   F,63
10EB: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
10ED: 80 2A    JMP   0x1118        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
10EF: 3C 03 0F CMP   [3],15        (0167) ;------------------------
10F2: C0 14    JC    0x1107        (0168) 
10F4: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
10F7: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
10FA: 70 3F    AND   F,63
10FC: 71 80    OR    F,128         (0172) ;------------------------
10FE: 56 58 00 MOV   [X+88],0      (0173) 
1101: 70 3F    AND   F,63
1103: 71 00    OR    F,0           (0174) 
1105: 80 12    JMP   0x1118        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1107: 75       INC   X             (0179) 
1108: 5A 03    MOV   [3],X         (0180) 
110A: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
110B: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
110E: 70 3F    AND   F,63
1110: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RX8_2_ISR
1112: 54 58    MOV   [X+88],A      (0185) ;
1114: 70 3F    AND   F,63
1116: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1118: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1119: 60 D3    MOV   REG[211],A    (0191) _RX8_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
111B: 20       POP   X             (0195)    ; Insert your custom code below this banner
111C: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
111E: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\rx8_2.asm
                                   (0121) ;;*****************************************************************************
1121: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RX8_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RX8_2.inc"
1122: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
1125: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RX8_2_EnableInt
                                   (0155) export  _RX8_2_EnableInt
                                   (0156) export   RX8_2_DisableInt
                                   (0157) export  _RX8_2_DisableInt
                                   (0158) export   RX8_2_Start
                                   (0159) export  _RX8_2_Start
                                   (0160) export   RX8_2_Stop
                                   (0161) export  _RX8_2_Stop
                                   (0162) export   RX8_2_bReadRxData
                                   (0163) export  _RX8_2_bReadRxData
                                   (0164) export   RX8_2_bReadRxStatus
                                   (0165) export  _RX8_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRX8_2_ReadRxData
                                   (0170) export _bRX8_2_ReadRxData
                                   (0171) export  bRX8_2_ReadRxStatus
                                   (0172) export _bRX8_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RX8_2_cGetChar
1126: 29 01    OR    A,1           (0179) export _RX8_2_cGetChar
1128: 60 2F    MOV   REG[47],A     (0180) export  RX8_2_cReadChar
                                   (0181) export _RX8_2_cReadChar
112A: 7F       RET                 (0182) export  RX8_2_iReadChar
                                   (0183) export _RX8_2_iReadChar
                                   (0184) 
                                   (0185) IF (RX8_2_RXBUF_ENABLE)
                                   (0186) export  RX8_2_CmdReset
                                   (0187) export _RX8_2_CmdReset
                                   (0188) export  RX8_2_bCmdCheck
                                   (0189) export _RX8_2_bCmdCheck
                                   (0190) export  RX8_2_bCmdLength
                                   (0191) export _RX8_2_bCmdLength
                                   (0192) export  RX8_2_bErrCheck
                                   (0193) export _RX8_2_bErrCheck
                                   (0194) 
                                   (0195) export  RX8_2_szGetParam
                                   (0196) export _RX8_2_szGetParam
                                   (0197) export  RX8_2_szGetRestOfParams
                                   (0198) export _RX8_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RX8_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
112B: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
112E: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RX8_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RX8_2_EnableInt:
                                   (0238) _RX8_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
112F: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1131: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RX8_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RX8_2_DisableInt:
                                   (0267) _RX8_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1132: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
1134: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RX8_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RX8_2_Start:
                                   (0297) _RX8_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RX8_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RX8_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1135: 49 2F 08 TST   REG[47],8     (0311) ;
1138: AF FC    JZ    0x1135        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
113A: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
113C: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RX8_2_Stop:
                                   (0326) _RX8_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RX8_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RX8_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
113D: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
113F: 08       PUSH  A             (0347) ;
1140: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1142: B0 04    JNZ   0x1147        (0349) ;    The A and X registers may be modified by this or future implementations
1144: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1145: 80 0B    JMP   0x1151        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1147: 5D 2E    MOV   A,REG[46]     (0354) ;
1149: 4B       SWAP  A,X           (0355)  RX8_2_bReadRxData:
                                   (0356) _RX8_2_bReadRxData:
114A: 18       POP   A             (0357)  bRX8_2_ReadRxData:
114B: 21 A0    AND   A,160         (0358) _bRX8_2_ReadRxData:
114D: B0 03    JNZ   0x1151        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
114F: 4B       SWAP  A,X           (0360)    mov A, REG[RX8_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1150: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1151: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RX8_2_bReadRxStatus
                                   (0368) ;
1153: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RX8_2_bReadRxStatus:
                                   (0388) _RX8_2_bReadRxStatus:
                                   (0389)  bRX8_2_ReadRxStatus:
                                   (0390) _bRX8_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RX8_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RX8_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1154: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1156: 21 E8    AND   A,232         (0408) ;
1158: 08       PUSH  A             (0409) ;  ARGUMENTS:
1159: 21 08    AND   A,8           (0410) ;      none
115B: B0 07    JNZ   0x1163        (0411) ;
115D: 18       POP   A             (0412) ;  RETURNS:
115E: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1160: 4B       SWAP  A,X           (0414) ;
1161: 80 07    JMP   0x1169        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1163: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1164: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1166: 4B       SWAP  A,X           (0420) ;    functions.
1167: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1169: 7F       RET                 (0426)  RX8_2_cGetChar:
                                   (0427) _RX8_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RX8_2_CONTROL_REG],RX8_2_RX_REG_FULL  ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RX8_2_RX_BUFFER_REG]               ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RX8_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RX8_2_cReadChar:
                                   (0463) _RX8_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
116A: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
116D: 55 58 00 MOV   [88],0        (0470)    pop  A
1170: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1173: 55 DE 00 MOV   [222],0       (0472) 
1176: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1179: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
117C: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
117F: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RX8_2_RX_PARITY_ERROR | RX8_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RX8_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RX8_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1180: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1183: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
1185: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1187: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RX8_2_iReadChar:
                                   (0523) _RX8_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RX8_2_RX_ERROR|RX8_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RX8_2_RX_NO_DATA                                 ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RX8_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RX8_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RX8_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RX8_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1188: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
118B: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
118D: 21 F0    AND   A,240         (0555) ;
118F: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
1192: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RX8_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RX8_2_CmdReset:
1193: 62 D0 00 MOV   REG[208],0    (0587) _RX8_2_CmdReset:
1196: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RX8_2_aRxBuffer
1198: 7F       RET                 (0590)    mov [RX8_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                   (0594)    mov [RX8_2_bRxCnt], 0x00
                                   (0595)    and [RX8_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RX8_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RX8_2_bCmdCheck:
                                   (0628) _RX8_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0631)    mov A,  [RX8_2_fStatus]
                                   (0632)    and A, RX8_2_RX_BUF_CMDTERM                   ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RX8_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1199: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
119B: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
119E: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
11A1: 50 58    MOV   A,88          (0648) ;     BYTE  fStatus - Status of command receive buffer.
11A3: 02 DE    ADD   A,[222]       (0649) ;                     Returns non-zero value in A if command is valid.
11A5: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
11A6: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
11A8: B0 04    JNZ   0x11AD        (0653) ;           0x10 => Software Buffer OverRun
11AA: 10       PUSH  X             (0654) ;
11AB: 80 33    JMP   0x11DF        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
11AD: 39 00    CMP   A,0           (0660) ;    functions.
11AF: B0 11    JNZ   0x11C1        (0661) ;          
11B1: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
11B2: 76 DE    INC   [222]         (0663) ;          CUR_PP
11B4: 52 00    MOV   A,[X+0]       (0664) ;
11B6: 3C DE 0F CMP   [222],15      (0665) ;     Error Status is clear when read.
11B9: BF F3    JNZ   0x11AD        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
11BB: 10       PUSH  X             (0669) ;
                                   (0670)  RX8_2_bErrCheck:
11BC: 56 00 00 MOV   [X+0],0       (0671) _RX8_2_bErrCheck:
11BF: 80 1F    JMP   0x11DF        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0674)    mov A,  [RX8_2_fStatus]
11C1: 10       PUSH  X             (0675)    and A, RX8_2_RX_BUF_ERROR                     ; Mask off Error status
                                   (0676)    and [RX8_2_fStatus], ~RX8_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
11C2: 75       INC   X             (0679) .ENDSECTION
11C3: 76 DE    INC   [222]         (0680) 
11C5: 3C DE 0F CMP   [222],15      (0681) .SECTION
11C8: AF F3    JZ    0x11BC        (0682) ;-----------------------------------------------------------------------------
11CA: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RX8_2_bCmdLength
11CC: A0 12    JZ    0x11DF        (0684) ;
11CE: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
11D0: BF F1    JNZ   0x11C2        (0686) ;     Get length of command string
                                   (0687) ;
11D2: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
11D5: 76 DE    INC   [222]         (0689) ;     none.
11D7: 3C DE 0F CMP   [222],15      (0690) ;
11DA: B0 04    JNZ   0x11DF        (0691) ;  RETURNS:
11DC: 55 DE 0F MOV   [222],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
11DF: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
11E0: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
11E1: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
11E4: B0 0B    JNZ   0x11F0        (0699) ;    functions.
11E6: 20       POP   X             (0700) ;          
11E7: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
11E9: 50 00    MOV   A,0           (0702) ;          CUR_PP
11EB: 70 3F    AND   F,63
11ED: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RX8_2_bCmdLength:
11EF: 7F       RET                 (0705) _RX8_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
11F0: 20       POP   X             (0708)    mov A,  [RX8_2_bRxCnt]
11F1: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
11F3: 70 3F    AND   F,63
11F5: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
11F7: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RX8_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
11F8: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
11FB: 50 58    MOV   A,88          (0744) ;     each lexically distinct element into a null-terminated string by replacing
11FD: 02 DE    ADD   A,[222]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
11FF: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1200: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RX8_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RX8_2_szGetParam, is
1203: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\init_timeout.asm
                                   (0102) ;;*****************************************************************************
1206: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: INIT_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "INIT_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1207: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
120A: 7F       RET                 (0131) export  INIT_TIMEOUT_EnableInt
                                   (0132) export _INIT_TIMEOUT_EnableInt
                                   (0133) export  INIT_TIMEOUT_DisableInt
                                   (0134) export _INIT_TIMEOUT_DisableInt
                                   (0135) export  INIT_TIMEOUT_Start
                                   (0136) export _INIT_TIMEOUT_Start
                                   (0137) export  INIT_TIMEOUT_Stop
                                   (0138) export _INIT_TIMEOUT_Stop
                                   (0139) export  INIT_TIMEOUT_WritePeriod
                                   (0140) export _INIT_TIMEOUT_WritePeriod
                                   (0141) export  INIT_TIMEOUT_WriteCompareValue
                                   (0142) export _INIT_TIMEOUT_WriteCompareValue
                                   (0143) export  INIT_TIMEOUT_wReadCompareValue
                                   (0144) export _INIT_TIMEOUT_wReadCompareValue
                                   (0145) export  INIT_TIMEOUT_wReadTimer
                                   (0146) export _INIT_TIMEOUT_wReadTimer
                                   (0147) export  INIT_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _INIT_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
120B: 43 23 01 OR    REG[35],1     (0157) export _wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
120E: 7F       RET                 (0159) export  wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA initial_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: INIT_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
120F: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1212: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  INIT_TIMEOUT_EnableInt:
                                   (0200) _INIT_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    INIT_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: INIT_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1213: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1215: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1216: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1218: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  INIT_TIMEOUT_DisableInt:
                                   (0228) _INIT_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    INIT_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: INIT_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1219: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
121B: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
121C: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
121E: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  INIT_TIMEOUT_Start:
                                   (0256) _INIT_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    INIT_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: INIT_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
121F: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1221: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1222: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1224: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  INIT_TIMEOUT_Stop:
                                   (0284) _INIT_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    INIT_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: INIT_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  INIT_TIMEOUT_WritePeriod:
                                   (0313) _INIT_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[INIT_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[INIT_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: INIT_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call INIT_TIMEOUT_Stop to disable).
1225: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1226: 38 03    ADD   SP,3          (0334) ;
1228: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
122A: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
122B: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
122D: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
122E: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1230: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1231: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1233: 5D 26    MOV   A,REG[38]     (0343) ;
1235: 54 01    MOV   [X+1],A       (0344)  INIT_TIMEOUT_WriteCompareValue:
1237: 5D 22    MOV   A,REG[34]     (0345) _INIT_TIMEOUT_WriteCompareValue:
1239: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
123B: 50 00    MOV   A,0           (0347)    mov   reg[INIT_TIMEOUT_COMPARE_LSB_REG], A
123D: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1240: A0 03    JZ    0x1244        (0349)    mov   reg[INIT_TIMEOUT_COMPARE_MSB_REG], A
1242: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1244: 54 00    MOV   [X+0],A       (0352) 
1246: 70 FE    AND   F,254         (0353) .ENDSECTION
1248: 41 23 FE AND   REG[35],254   (0354) 
124B: 18       POP   A             (0355) 
124C: 60 26    MOV   REG[38],A     (0356) .SECTION
124E: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
124F: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: INIT_TIMEOUT_wReadCompareValue
1251: 18       POP   A             (0359) ;
1252: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1254: 18       POP   A             (0361) ;     Reads the Compare registers.
1255: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1256: 70 3F    AND   F,63
1258: 71 C0    OR    F,192         (0363) ;
125A: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  INIT_TIMEOUT_wReadCompareValue:
                                   (0374) _INIT_TIMEOUT_wReadCompareValue:
                                   (0375)  wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0376) _wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[INIT_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[INIT_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: INIT_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
125B: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
125D: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
125F: 5C       MOV   X,A           (0409) ;
1260: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1263: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\init_rxint.asm
1264: 10       PUSH  X             (0104) ;;*****************************************************************************
1265: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: INIT_RXINT.asm
1267: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1268: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
126A: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
126C: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
126D: 21 08    AND   A,8           (0114) ;;*****************************************************************************
126F: B0 04    JNZ   0x1274        (0115) 
1271: 18       POP   A             (0116) include "m8c.inc"
1272: 80 5E    JMP   0x12D1        (0117) include "memory.inc"
                                   (0118) include "INIT_RX.inc"
                                   (0119) 
                                   (0120) 
1274: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1275: 21 E0    AND   A,224         (0124) export  _INIT_RX_ISR
1277: A0 12    JZ    0x128A        (0125) 
                                   (0126) 
1279: 2C 06    OR    [6],A         (0127) IF (INIT_RX_RXBUF_ENABLE)
                                   (0128) export  INIT_RX_aRxBuffer
127B: 49 2A 00 TST   REG[42],0     (0129) export _INIT_RX_aRxBuffer
                                   (0130) export  INIT_RX_bRxCnt
127E: 21 20    AND   A,32          (0131) export _INIT_RX_bRxCnt
1280: A0 50    JZ    0x12D1        (0132) export  INIT_RX_fStatus
                                   (0133) export _INIT_RX_fStatus
                                   (0134) ENDIF
                                   (0135) 
1282: 41 2B FE AND   REG[43],254   (0136) 
1285: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1288: 80 48    JMP   0x12D1        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (INIT_RX_RXBUF_ENABLE)
128A: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  INIT_RX_fStatus:
                                   (0144) _INIT_RX_fStatus:      BLK  1
128C: 47 06 01 TST   [6],1         (0145)  INIT_RX_bRxCnt:
128F: B0 41    JNZ   0x12D1        (0146) _INIT_RX_bRxCnt:       BLK  1
                                   (0147) AREA INIT_RX_RAM(RAM,REL,CON)
1291: 39 00    CMP   A,0           (0148)  INIT_RX_aRxBuffer:    
1293: B0 14    JNZ   0x12A8        (0149) _INIT_RX_aRxBuffer:    BLK INIT_RX_RX_BUFFER_SIZE
1295: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
1298: 62 D3 00 MOV   REG[211],0    (0152) 
129B: 70 3F    AND   F,63
129D: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
129F: 56 48 00 MOV   [X+72],0      (0154) 
12A2: 70 3F    AND   F,63
12A4: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
12A6: 80 2A    JMP   0x12D1        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
12A8: 3C 07 0F CMP   [7],15        (0167) ;------------------------
12AB: C0 14    JC    0x12C0        (0168) 
12AD: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
12B0: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
12B3: 70 3F    AND   F,63
12B5: 71 80    OR    F,128         (0172) ;------------------------
12B7: 56 48 00 MOV   [X+72],0      (0173) 
12BA: 70 3F    AND   F,63
12BC: 71 00    OR    F,0           (0174) 
12BE: 80 12    JMP   0x12D1        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
12C0: 75       INC   X             (0179) 
12C1: 5A 07    MOV   [7],X         (0180) 
12C3: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
12C4: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
12C7: 70 3F    AND   F,63
12C9: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _INIT_RX_ISR
12CB: 54 48    MOV   [X+72],A      (0185) ;
12CD: 70 3F    AND   F,63
12CF: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
12D1: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
12D2: 60 D3    MOV   REG[211],A    (0191) _INIT_RX_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
12D4: 20       POP   X             (0195)    ; Insert your custom code below this banner
12D5: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
12D7: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\init_rx.asm
                                   (0121) ;;*****************************************************************************
12DA: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: INIT_RX.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "INIT_RX.inc"
12DB: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
12DE: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   INIT_RX_EnableInt
                                   (0155) export  _INIT_RX_EnableInt
                                   (0156) export   INIT_RX_DisableInt
                                   (0157) export  _INIT_RX_DisableInt
                                   (0158) export   INIT_RX_Start
                                   (0159) export  _INIT_RX_Start
                                   (0160) export   INIT_RX_Stop
                                   (0161) export  _INIT_RX_Stop
                                   (0162) export   INIT_RX_bReadRxData
                                   (0163) export  _INIT_RX_bReadRxData
                                   (0164) export   INIT_RX_bReadRxStatus
                                   (0165) export  _INIT_RX_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bINIT_RX_ReadRxData
                                   (0170) export _bINIT_RX_ReadRxData
                                   (0171) export  bINIT_RX_ReadRxStatus
                                   (0172) export _bINIT_RX_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  INIT_RX_cGetChar
12DF: 29 01    OR    A,1           (0179) export _INIT_RX_cGetChar
12E1: 60 2B    MOV   REG[43],A     (0180) export  INIT_RX_cReadChar
                                   (0181) export _INIT_RX_cReadChar
12E3: 7F       RET                 (0182) export  INIT_RX_iReadChar
                                   (0183) export _INIT_RX_iReadChar
                                   (0184) 
                                   (0185) IF (INIT_RX_RXBUF_ENABLE)
                                   (0186) export  INIT_RX_CmdReset
                                   (0187) export _INIT_RX_CmdReset
                                   (0188) export  INIT_RX_bCmdCheck
                                   (0189) export _INIT_RX_bCmdCheck
                                   (0190) export  INIT_RX_bCmdLength
                                   (0191) export _INIT_RX_bCmdLength
                                   (0192) export  INIT_RX_bErrCheck
                                   (0193) export _INIT_RX_bErrCheck
                                   (0194) 
                                   (0195) export  INIT_RX_szGetParam
                                   (0196) export _INIT_RX_szGetParam
                                   (0197) export  INIT_RX_szGetRestOfParams
                                   (0198) export _INIT_RX_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA INIT_RX_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
12E4: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
12E7: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: INIT_RX_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  INIT_RX_EnableInt:
                                   (0238) _INIT_RX_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
12E8: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
12EA: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: INIT_RX_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  INIT_RX_DisableInt:
                                   (0267) _INIT_RX_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
12EB: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
12ED: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: INIT_RX_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  INIT_RX_Start:
                                   (0297) _INIT_RX_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[INIT_RX_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: INIT_RX_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
12EE: 49 2B 08 TST   REG[43],8     (0311) ;
12F1: AF FC    JZ    0x12EE        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
12F3: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
12F5: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  INIT_RX_Stop:
                                   (0326) _INIT_RX_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[INIT_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: INIT_RX_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
12F6: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
12F8: 08       PUSH  A             (0347) ;
12F9: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
12FB: B0 04    JNZ   0x1300        (0349) ;    The A and X registers may be modified by this or future implementations
12FD: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
12FE: 80 0B    JMP   0x130A        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1300: 5D 2A    MOV   A,REG[42]     (0354) ;
1302: 4B       SWAP  A,X           (0355)  INIT_RX_bReadRxData:
                                   (0356) _INIT_RX_bReadRxData:
1303: 18       POP   A             (0357)  bINIT_RX_ReadRxData:
1304: 21 A0    AND   A,160         (0358) _bINIT_RX_ReadRxData:
1306: B0 03    JNZ   0x130A        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1308: 4B       SWAP  A,X           (0360)    mov A, REG[INIT_RX_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1309: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
130A: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: INIT_RX_bReadRxStatus
                                   (0368) ;
130C: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  INIT_RX_bReadRxStatus:
                                   (0388) _INIT_RX_bReadRxStatus:
                                   (0389)  bINIT_RX_ReadRxStatus:
                                   (0390) _bINIT_RX_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[INIT_RX_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: INIT_RX_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
130D: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
130F: 21 E8    AND   A,232         (0408) ;
1311: 08       PUSH  A             (0409) ;  ARGUMENTS:
1312: 21 08    AND   A,8           (0410) ;      none
1314: B0 07    JNZ   0x131C        (0411) ;
1316: 18       POP   A             (0412) ;  RETURNS:
1317: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1319: 4B       SWAP  A,X           (0414) ;
131A: 80 07    JMP   0x1322        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
131C: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
131D: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
131F: 4B       SWAP  A,X           (0420) ;    functions.
1320: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1322: 7F       RET                 (0426)  INIT_RX_cGetChar:
                                   (0427) _INIT_RX_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[INIT_RX_CONTROL_REG],INIT_RX_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[INIT_RX_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: INIT_RX_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  INIT_RX_cReadChar:
                                   (0463) _INIT_RX_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
1323: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1326: 55 48 00 MOV   [72],0        (0470)    pop  A
1329: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
132C: 55 DD 00 MOV   [221],0       (0472) 
132F: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1332: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
1335: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1338: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(INIT_RX_RX_PARITY_ERROR | INIT_RX_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_INIT_RX_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: INIT_RX_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1339: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
133C: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
133E: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1340: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  INIT_RX_iReadChar:
                                   (0523) _INIT_RX_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(INIT_RX_RX_ERROR|INIT_RX_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,INIT_RX_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_INIT_RX_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,INIT_RX_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_INIT_RX_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (INIT_RX_RXBUF_ENABLE)
                                   (0552) .SECTION
1341: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1344: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
1346: 21 F0    AND   A,240         (0555) ;
1348: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
134B: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: INIT_RX_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  INIT_RX_CmdReset:
134C: 62 D0 00 MOV   REG[208],0    (0587) _INIT_RX_CmdReset:
134F: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >INIT_RX_aRxBuffer
1351: 7F       RET                 (0590)    mov [INIT_RX_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
                                   (0594)    mov [INIT_RX_bRxCnt], 0x00
                                   (0595)    and [INIT_RX_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: INIT_RX_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  INIT_RX_bCmdCheck:
                                   (0628) _INIT_RX_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0631)    mov A,  [INIT_RX_fStatus]
                                   (0632)    and A, INIT_RX_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: INIT_RX_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1352: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1354: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1357: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
135A: 50 48    MOV   A,72          (0648) ;     BYTE  fStatus - Status of command receive buffer.
135C: 02 DD    ADD   A,[221]       (0649) ;                     Returns non-zero value in A if command is valid.
135E: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
135F: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1361: B0 04    JNZ   0x1366        (0653) ;           0x10 => Software Buffer OverRun
1363: 10       PUSH  X             (0654) ;
1364: 80 33    JMP   0x1398        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1366: 39 00    CMP   A,0           (0660) ;    functions.
1368: B0 11    JNZ   0x137A        (0661) ;          
136A: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
136B: 76 DD    INC   [221]         (0663) ;          CUR_PP
136D: 52 00    MOV   A,[X+0]       (0664) ;
136F: 3C DD 0F CMP   [221],15      (0665) ;     Error Status is clear when read.
1372: BF F3    JNZ   0x1366        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1374: 10       PUSH  X             (0669) ;
                                   (0670)  INIT_RX_bErrCheck:
1375: 56 00 00 MOV   [X+0],0       (0671) _INIT_RX_bErrCheck:
1378: 80 1F    JMP   0x1398        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0674)    mov A,  [INIT_RX_fStatus]
137A: 10       PUSH  X             (0675)    and A, INIT_RX_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [INIT_RX_fStatus], ~INIT_RX_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
137B: 75       INC   X             (0679) .ENDSECTION
137C: 76 DD    INC   [221]         (0680) 
137E: 3C DD 0F CMP   [221],15      (0681) .SECTION
1381: AF F3    JZ    0x1375        (0682) ;-----------------------------------------------------------------------------
1383: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: INIT_RX_bCmdLength
1385: A0 12    JZ    0x1398        (0684) ;
1387: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1389: BF F1    JNZ   0x137B        (0686) ;     Get length of command string
                                   (0687) ;
138B: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
138E: 76 DD    INC   [221]         (0689) ;     none.
1390: 3C DD 0F CMP   [221],15      (0690) ;
1393: B0 04    JNZ   0x1398        (0691) ;  RETURNS:
1395: 55 DD 0F MOV   [221],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1398: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1399: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
139A: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
139D: B0 0B    JNZ   0x13A9        (0699) ;    functions.
139F: 20       POP   X             (0700) ;          
13A0: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
13A2: 50 00    MOV   A,0           (0702) ;          CUR_PP
13A4: 70 3F    AND   F,63
13A6: 71 C0    OR    F,192         (0703) ;
                                   (0704)  INIT_RX_bCmdLength:
13A8: 7F       RET                 (0705) _INIT_RX_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
13A9: 20       POP   X             (0708)    mov A,  [INIT_RX_bRxCnt]
13AA: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
13AC: 70 3F    AND   F,63
13AE: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
13B0: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: INIT_RX_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
13B1: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
13B4: 50 48    MOV   A,72          (0744) ;     each lexically distinct element into a null-terminated string by replacing
13B6: 02 DD    ADD   A,[221]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
13B8: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
13B9: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     INIT_RX_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, INIT_RX_szGetParam, is
13BC: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_timeout.asm
                                   (0102) ;;*****************************************************************************
13BF: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: HELLO_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "HELLO_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
13C0: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
13C3: 7F       RET                 (0131) export  HELLO_TIMEOUT_EnableInt
                                   (0132) export _HELLO_TIMEOUT_EnableInt
                                   (0133) export  HELLO_TIMEOUT_DisableInt
                                   (0134) export _HELLO_TIMEOUT_DisableInt
                                   (0135) export  HELLO_TIMEOUT_Start
                                   (0136) export _HELLO_TIMEOUT_Start
                                   (0137) export  HELLO_TIMEOUT_Stop
                                   (0138) export _HELLO_TIMEOUT_Stop
                                   (0139) export  HELLO_TIMEOUT_WritePeriod
                                   (0140) export _HELLO_TIMEOUT_WritePeriod
                                   (0141) export  HELLO_TIMEOUT_WriteCompareValue
                                   (0142) export _HELLO_TIMEOUT_WriteCompareValue
                                   (0143) export  HELLO_TIMEOUT_wReadCompareValue
                                   (0144) export _HELLO_TIMEOUT_wReadCompareValue
                                   (0145) export  HELLO_TIMEOUT_wReadTimer
                                   (0146) export _HELLO_TIMEOUT_wReadTimer
                                   (0147) export  HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
13C4: 43 23 01 OR    REG[35],1     (0157) export _wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
13C7: 7F       RET                 (0159) export  wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA hello_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: HELLO_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
13C8: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
13CB: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  HELLO_TIMEOUT_EnableInt:
                                   (0200) _HELLO_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    HELLO_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: HELLO_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
13CC: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
13CE: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
13CF: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
13D1: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  HELLO_TIMEOUT_DisableInt:
                                   (0228) _HELLO_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    HELLO_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: HELLO_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
13D2: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
13D4: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
13D5: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
13D7: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  HELLO_TIMEOUT_Start:
                                   (0256) _HELLO_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    HELLO_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: HELLO_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
13D8: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
13DA: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
13DB: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
13DD: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  HELLO_TIMEOUT_Stop:
                                   (0284) _HELLO_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    HELLO_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: HELLO_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  HELLO_TIMEOUT_WritePeriod:
                                   (0313) _HELLO_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[HELLO_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[HELLO_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: HELLO_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call HELLO_TIMEOUT_Stop to disable).
13DE: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
13DF: 38 03    ADD   SP,3          (0334) ;
13E1: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
13E3: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
13E4: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
13E6: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
13E7: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
13E9: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
13EA: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
13EC: 5D 26    MOV   A,REG[38]     (0343) ;
13EE: 54 01    MOV   [X+1],A       (0344)  HELLO_TIMEOUT_WriteCompareValue:
13F0: 5D 22    MOV   A,REG[34]     (0345) _HELLO_TIMEOUT_WriteCompareValue:
13F2: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
13F4: 50 00    MOV   A,0           (0347)    mov   reg[HELLO_TIMEOUT_COMPARE_LSB_REG], A
13F6: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
13F9: A0 03    JZ    0x13FD        (0349)    mov   reg[HELLO_TIMEOUT_COMPARE_MSB_REG], A
13FB: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
13FD: 54 00    MOV   [X+0],A       (0352) 
13FF: 70 FE    AND   F,254         (0353) .ENDSECTION
1401: 41 23 FE AND   REG[35],254   (0354) 
1404: 18       POP   A             (0355) 
1405: 60 26    MOV   REG[38],A     (0356) .SECTION
1407: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1408: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadCompareValue
140A: 18       POP   A             (0359) ;
140B: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
140D: 18       POP   A             (0361) ;     Reads the Compare registers.
140E: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
140F: 70 3F    AND   F,63
1411: 71 C0    OR    F,192         (0363) ;
1413: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  HELLO_TIMEOUT_wReadCompareValue:
                                   (0374) _HELLO_TIMEOUT_wReadCompareValue:
                                   (0375)  wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[HELLO_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[HELLO_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1414: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1416: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1418: 5C       MOV   X,A           (0409) ;
1419: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
141C: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\hello_4int.asm
141D: 10       PUSH  X             (0104) ;;*****************************************************************************
141E: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_4INT.asm
1420: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1421: 58 09    MOV   X,[9]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1423: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
1425: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1426: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1428: B0 04    JNZ   0x142D        (0115) 
142A: 18       POP   A             (0116) include "m8c.inc"
142B: 80 5E    JMP   0x148A        (0117) include "memory.inc"
                                   (0118) include "HELLO_4.inc"
                                   (0119) 
                                   (0120) 
142D: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
142E: 21 E0    AND   A,224         (0124) export  _HELLO_4_ISR
1430: A0 12    JZ    0x1443        (0125) 
                                   (0126) 
1432: 2C 08    OR    [8],A         (0127) IF (HELLO_4_RXBUF_ENABLE)
                                   (0128) export  HELLO_4_aRxBuffer
1434: 49 3E 00 TST   REG[62],0     (0129) export _HELLO_4_aRxBuffer
                                   (0130) export  HELLO_4_bRxCnt
1437: 21 20    AND   A,32          (0131) export _HELLO_4_bRxCnt
1439: A0 50    JZ    0x148A        (0132) export  HELLO_4_fStatus
                                   (0133) export _HELLO_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
143B: 41 3F FE AND   REG[63],254   (0136) 
143E: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
1441: 80 48    JMP   0x148A        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_4_RXBUF_ENABLE)
1443: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_4_fStatus:
                                   (0144) _HELLO_4_fStatus:      BLK  1
1445: 47 08 01 TST   [8],1         (0145)  HELLO_4_bRxCnt:
1448: B0 41    JNZ   0x148A        (0146) _HELLO_4_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_4_RAM(RAM,REL,CON)
144A: 39 00    CMP   A,0           (0148)  HELLO_4_aRxBuffer:    
144C: B0 14    JNZ   0x1461        (0149) _HELLO_4_aRxBuffer:    BLK HELLO_4_RX_BUFFER_SIZE
144E: 2E 08 01 OR    [8],1         (0150) ENDIF
                                   (0151) 
1451: 62 D3 00 MOV   REG[211],0    (0152) 
1454: 70 3F    AND   F,63
1456: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1458: 56 18 00 MOV   [X+24],0      (0154) 
145B: 70 3F    AND   F,63
145D: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
145F: 80 2A    JMP   0x148A        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1461: 3C 09 0F CMP   [9],15        (0167) ;------------------------
1464: C0 14    JC    0x1479        (0168) 
1466: 2E 08 10 OR    [8],16        (0169) 
                                   (0170) ;------------------------
1469: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
146C: 70 3F    AND   F,63
146E: 71 80    OR    F,128         (0172) ;------------------------
1470: 56 18 00 MOV   [X+24],0      (0173) 
1473: 70 3F    AND   F,63
1475: 71 00    OR    F,0           (0174) 
1477: 80 12    JMP   0x148A        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1479: 75       INC   X             (0179) 
147A: 5A 09    MOV   [9],X         (0180) 
147C: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
147D: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1480: 70 3F    AND   F,63
1482: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_4_ISR
1484: 54 18    MOV   [X+24],A      (0185) ;
1486: 70 3F    AND   F,63
1488: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
148A: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
148B: 60 D3    MOV   REG[211],A    (0191) _HELLO_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
148D: 20       POP   X             (0195)    ; Insert your custom code below this banner
148E: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1490: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\hello_4.asm
                                   (0121) ;;*****************************************************************************
1493: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_4.inc"
1494: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
1497: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_4_EnableInt
                                   (0155) export  _HELLO_4_EnableInt
                                   (0156) export   HELLO_4_DisableInt
                                   (0157) export  _HELLO_4_DisableInt
                                   (0158) export   HELLO_4_Start
                                   (0159) export  _HELLO_4_Start
                                   (0160) export   HELLO_4_Stop
                                   (0161) export  _HELLO_4_Stop
                                   (0162) export   HELLO_4_bReadRxData
                                   (0163) export  _HELLO_4_bReadRxData
                                   (0164) export   HELLO_4_bReadRxStatus
                                   (0165) export  _HELLO_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_4_ReadRxData
                                   (0170) export _bHELLO_4_ReadRxData
                                   (0171) export  bHELLO_4_ReadRxStatus
                                   (0172) export _bHELLO_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_4_cGetChar
1498: 29 01    OR    A,1           (0179) export _HELLO_4_cGetChar
149A: 60 3F    MOV   REG[63],A     (0180) export  HELLO_4_cReadChar
                                   (0181) export _HELLO_4_cReadChar
149C: 7F       RET                 (0182) export  HELLO_4_iReadChar
                                   (0183) export _HELLO_4_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_4_RXBUF_ENABLE)
                                   (0186) export  HELLO_4_CmdReset
                                   (0187) export _HELLO_4_CmdReset
                                   (0188) export  HELLO_4_bCmdCheck
                                   (0189) export _HELLO_4_bCmdCheck
                                   (0190) export  HELLO_4_bCmdLength
                                   (0191) export _HELLO_4_bCmdLength
                                   (0192) export  HELLO_4_bErrCheck
                                   (0193) export _HELLO_4_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_4_szGetParam
                                   (0196) export _HELLO_4_szGetParam
                                   (0197) export  HELLO_4_szGetRestOfParams
                                   (0198) export _HELLO_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
149D: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
14A0: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_4_EnableInt:
                                   (0238) _HELLO_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
14A1: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
14A3: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_4_DisableInt:
                                   (0267) _HELLO_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
14A4: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
14A6: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_4_Start:
                                   (0297) _HELLO_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
14A7: 49 3F 08 TST   REG[63],8     (0311) ;
14AA: AF FC    JZ    0x14A7        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
14AC: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
14AE: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_4_Stop:
                                   (0326) _HELLO_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
14AF: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
14B1: 08       PUSH  A             (0347) ;
14B2: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
14B4: B0 04    JNZ   0x14B9        (0349) ;    The A and X registers may be modified by this or future implementations
14B6: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
14B7: 80 0B    JMP   0x14C3        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
14B9: 5D 3E    MOV   A,REG[62]     (0354) ;
14BB: 4B       SWAP  A,X           (0355)  HELLO_4_bReadRxData:
                                   (0356) _HELLO_4_bReadRxData:
14BC: 18       POP   A             (0357)  bHELLO_4_ReadRxData:
14BD: 21 A0    AND   A,160         (0358) _bHELLO_4_ReadRxData:
14BF: B0 03    JNZ   0x14C3        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
14C1: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
14C2: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
14C3: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_4_bReadRxStatus
                                   (0368) ;
14C5: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_4_bReadRxStatus:
                                   (0388) _HELLO_4_bReadRxStatus:
                                   (0389)  bHELLO_4_ReadRxStatus:
                                   (0390) _bHELLO_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
14C6: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
14C8: 21 E8    AND   A,232         (0408) ;
14CA: 08       PUSH  A             (0409) ;  ARGUMENTS:
14CB: 21 08    AND   A,8           (0410) ;      none
14CD: B0 07    JNZ   0x14D5        (0411) ;
14CF: 18       POP   A             (0412) ;  RETURNS:
14D0: 29 01    OR    A,1           (0413) ;     char that is returned from UART
14D2: 4B       SWAP  A,X           (0414) ;
14D3: 80 07    JMP   0x14DB        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
14D5: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
14D6: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
14D8: 4B       SWAP  A,X           (0420) ;    functions.
14D9: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
14DB: 7F       RET                 (0426)  HELLO_4_cGetChar:
                                   (0427) _HELLO_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_4_CONTROL_REG],HELLO_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_4_cReadChar:
                                   (0463) _HELLO_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
14DC: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
14DF: 55 18 00 MOV   [24],0        (0470)    pop  A
14E2: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
14E5: 55 DC 00 MOV   [220],0       (0472) 
14E8: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
14EB: 55 09 00 MOV   [9],0         (0474)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
14EE: 26 08 00 AND   [8],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
14F1: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_4_RX_PARITY_ERROR | HELLO_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
14F2: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
14F5: 51 08    MOV   A,[8]         (0511) ;        0x40CC    Overrun Error
14F7: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
14F9: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_4_iReadChar:
                                   (0523) _HELLO_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_4_RX_ERROR|HELLO_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_4_RXBUF_ENABLE)
                                   (0552) .SECTION
14FA: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
14FD: 51 08    MOV   A,[8]         (0554) ;-----------------------------------------------------------------------------
14FF: 21 F0    AND   A,240         (0555) ;
1501: 26 08 0F AND   [8],15        (0556) ;     Command Buffer commands
                                   (0557) ;
1504: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_4_CmdReset:
1505: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_4_CmdReset:
1508: 51 09    MOV   A,[9]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_4_aRxBuffer
150A: 7F       RET                 (0590)    mov [HELLO_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
                                   (0594)    mov [HELLO_4_bRxCnt], 0x00
                                   (0595)    and [HELLO_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_4_bCmdCheck:
                                   (0628) _HELLO_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0631)    mov A,  [HELLO_4_fStatus]
                                   (0632)    and A, HELLO_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
150B: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
150D: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1510: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1513: 50 18    MOV   A,24          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1515: 02 DC    ADD   A,[220]       (0649) ;                     Returns non-zero value in A if command is valid.
1517: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1518: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
151A: B0 04    JNZ   0x151F        (0653) ;           0x10 => Software Buffer OverRun
151C: 10       PUSH  X             (0654) ;
151D: 80 33    JMP   0x1551        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
151F: 39 00    CMP   A,0           (0660) ;    functions.
1521: B0 11    JNZ   0x1533        (0661) ;          
1523: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1524: 76 DC    INC   [220]         (0663) ;          CUR_PP
1526: 52 00    MOV   A,[X+0]       (0664) ;
1528: 3C DC 0F CMP   [220],15      (0665) ;     Error Status is clear when read.
152B: BF F3    JNZ   0x151F        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
152D: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_4_bErrCheck:
152E: 56 00 00 MOV   [X+0],0       (0671) _HELLO_4_bErrCheck:
1531: 80 1F    JMP   0x1551        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0674)    mov A,  [HELLO_4_fStatus]
1533: 10       PUSH  X             (0675)    and A, HELLO_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_4_fStatus], ~HELLO_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1534: 75       INC   X             (0679) .ENDSECTION
1535: 76 DC    INC   [220]         (0680) 
1537: 3C DC 0F CMP   [220],15      (0681) .SECTION
153A: AF F3    JZ    0x152E        (0682) ;-----------------------------------------------------------------------------
153C: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_4_bCmdLength
153E: A0 12    JZ    0x1551        (0684) ;
1540: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1542: BF F1    JNZ   0x1534        (0686) ;     Get length of command string
                                   (0687) ;
1544: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1547: 76 DC    INC   [220]         (0689) ;     none.
1549: 3C DC 0F CMP   [220],15      (0690) ;
154C: B0 04    JNZ   0x1551        (0691) ;  RETURNS:
154E: 55 DC 0F MOV   [220],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1551: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1552: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1553: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1556: B0 0B    JNZ   0x1562        (0699) ;    functions.
1558: 20       POP   X             (0700) ;          
1559: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
155B: 50 00    MOV   A,0           (0702) ;          CUR_PP
155D: 70 3F    AND   F,63
155F: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_4_bCmdLength:
1561: 7F       RET                 (0705) _HELLO_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
1562: 20       POP   X             (0708)    mov A,  [HELLO_4_bRxCnt]
1563: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1565: 70 3F    AND   F,63
1567: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1569: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
156A: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
156D: 50 18    MOV   A,24          (0744) ;     each lexically distinct element into a null-terminated string by replacing
156F: 02 DC    ADD   A,[220]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1571: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1572: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_4_szGetParam, is
1575: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_3int.asm
1576: 10       PUSH  X             (0104) ;;*****************************************************************************
1577: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_3INT.asm
1579: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
157A: 58 0B    MOV   X,[11]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
157C: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
157E: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
157F: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1581: B0 04    JNZ   0x1586        (0115) 
1583: 18       POP   A             (0116) include "m8c.inc"
1584: 80 5E    JMP   0x15E3        (0117) include "memory.inc"
                                   (0118) include "HELLO_3.inc"
                                   (0119) 
                                   (0120) 
1586: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1587: 21 E0    AND   A,224         (0124) export  _HELLO_3_ISR
1589: A0 12    JZ    0x159C        (0125) 
                                   (0126) 
158B: 2C 0A    OR    [10],A        (0127) IF (HELLO_3_RXBUF_ENABLE)
                                   (0128) export  HELLO_3_aRxBuffer
158D: 49 3A 00 TST   REG[58],0     (0129) export _HELLO_3_aRxBuffer
                                   (0130) export  HELLO_3_bRxCnt
1590: 21 20    AND   A,32          (0131) export _HELLO_3_bRxCnt
1592: A0 50    JZ    0x15E3        (0132) export  HELLO_3_fStatus
                                   (0133) export _HELLO_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1594: 41 3B FE AND   REG[59],254   (0136) 
1597: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
159A: 80 48    JMP   0x15E3        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_3_RXBUF_ENABLE)
159C: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_3_fStatus:
                                   (0144) _HELLO_3_fStatus:      BLK  1
159E: 47 0A 01 TST   [10],1        (0145)  HELLO_3_bRxCnt:
15A1: B0 41    JNZ   0x15E3        (0146) _HELLO_3_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_3_RAM(RAM,REL,CON)
15A3: 39 00    CMP   A,0           (0148)  HELLO_3_aRxBuffer:    
15A5: B0 14    JNZ   0x15BA        (0149) _HELLO_3_aRxBuffer:    BLK HELLO_3_RX_BUFFER_SIZE
15A7: 2E 0A 01 OR    [10],1        (0150) ENDIF
                                   (0151) 
15AA: 62 D3 00 MOV   REG[211],0    (0152) 
15AD: 70 3F    AND   F,63
15AF: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
15B1: 56 28 00 MOV   [X+40],0      (0154) 
15B4: 70 3F    AND   F,63
15B6: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
15B8: 80 2A    JMP   0x15E3        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
15BA: 3C 0B 0F CMP   [11],15       (0167) ;------------------------
15BD: C0 14    JC    0x15D2        (0168) 
15BF: 2E 0A 10 OR    [10],16       (0169) 
                                   (0170) ;------------------------
15C2: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
15C5: 70 3F    AND   F,63
15C7: 71 80    OR    F,128         (0172) ;------------------------
15C9: 56 28 00 MOV   [X+40],0      (0173) 
15CC: 70 3F    AND   F,63
15CE: 71 00    OR    F,0           (0174) 
15D0: 80 12    JMP   0x15E3        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
15D2: 75       INC   X             (0179) 
15D3: 5A 0B    MOV   [11],X        (0180) 
15D5: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
15D6: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
15D9: 70 3F    AND   F,63
15DB: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_3_ISR
15DD: 54 28    MOV   [X+40],A      (0185) ;
15DF: 70 3F    AND   F,63
15E1: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
15E3: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
15E4: 60 D3    MOV   REG[211],A    (0191) _HELLO_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
15E6: 20       POP   X             (0195)    ; Insert your custom code below this banner
15E7: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
15E9: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\hello_3.asm
                                   (0121) ;;*****************************************************************************
15EC: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_3.inc"
15ED: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
15F0: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_3_EnableInt
                                   (0155) export  _HELLO_3_EnableInt
                                   (0156) export   HELLO_3_DisableInt
                                   (0157) export  _HELLO_3_DisableInt
                                   (0158) export   HELLO_3_Start
                                   (0159) export  _HELLO_3_Start
                                   (0160) export   HELLO_3_Stop
                                   (0161) export  _HELLO_3_Stop
                                   (0162) export   HELLO_3_bReadRxData
                                   (0163) export  _HELLO_3_bReadRxData
                                   (0164) export   HELLO_3_bReadRxStatus
                                   (0165) export  _HELLO_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_3_ReadRxData
                                   (0170) export _bHELLO_3_ReadRxData
                                   (0171) export  bHELLO_3_ReadRxStatus
                                   (0172) export _bHELLO_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_3_cGetChar
15F1: 29 01    OR    A,1           (0179) export _HELLO_3_cGetChar
15F3: 60 3B    MOV   REG[59],A     (0180) export  HELLO_3_cReadChar
                                   (0181) export _HELLO_3_cReadChar
15F5: 7F       RET                 (0182) export  HELLO_3_iReadChar
                                   (0183) export _HELLO_3_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_3_RXBUF_ENABLE)
                                   (0186) export  HELLO_3_CmdReset
                                   (0187) export _HELLO_3_CmdReset
                                   (0188) export  HELLO_3_bCmdCheck
                                   (0189) export _HELLO_3_bCmdCheck
                                   (0190) export  HELLO_3_bCmdLength
                                   (0191) export _HELLO_3_bCmdLength
                                   (0192) export  HELLO_3_bErrCheck
                                   (0193) export _HELLO_3_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_3_szGetParam
                                   (0196) export _HELLO_3_szGetParam
                                   (0197) export  HELLO_3_szGetRestOfParams
                                   (0198) export _HELLO_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
15F6: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
15F9: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_3_EnableInt:
                                   (0238) _HELLO_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
15FA: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
15FC: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_3_DisableInt:
                                   (0267) _HELLO_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
15FD: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
15FF: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_3_Start:
                                   (0297) _HELLO_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1600: 49 3B 08 TST   REG[59],8     (0311) ;
1603: AF FC    JZ    0x1600        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1605: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1607: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_3_Stop:
                                   (0326) _HELLO_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1608: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
160A: 08       PUSH  A             (0347) ;
160B: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
160D: B0 04    JNZ   0x1612        (0349) ;    The A and X registers may be modified by this or future implementations
160F: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1610: 80 0B    JMP   0x161C        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1612: 5D 3A    MOV   A,REG[58]     (0354) ;
1614: 4B       SWAP  A,X           (0355)  HELLO_3_bReadRxData:
                                   (0356) _HELLO_3_bReadRxData:
1615: 18       POP   A             (0357)  bHELLO_3_ReadRxData:
1616: 21 A0    AND   A,160         (0358) _bHELLO_3_ReadRxData:
1618: B0 03    JNZ   0x161C        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
161A: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
161B: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
161C: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_3_bReadRxStatus
                                   (0368) ;
161E: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_3_bReadRxStatus:
                                   (0388) _HELLO_3_bReadRxStatus:
                                   (0389)  bHELLO_3_ReadRxStatus:
                                   (0390) _bHELLO_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
161F: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1621: 21 E8    AND   A,232         (0408) ;
1623: 08       PUSH  A             (0409) ;  ARGUMENTS:
1624: 21 08    AND   A,8           (0410) ;      none
1626: B0 07    JNZ   0x162E        (0411) ;
1628: 18       POP   A             (0412) ;  RETURNS:
1629: 29 01    OR    A,1           (0413) ;     char that is returned from UART
162B: 4B       SWAP  A,X           (0414) ;
162C: 80 07    JMP   0x1634        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
162E: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
162F: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1631: 4B       SWAP  A,X           (0420) ;    functions.
1632: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1634: 7F       RET                 (0426)  HELLO_3_cGetChar:
                                   (0427) _HELLO_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_3_CONTROL_REG],HELLO_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_3_cReadChar:
                                   (0463) _HELLO_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
1635: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1638: 55 28 00 MOV   [40],0        (0470)    pop  A
163B: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
163E: 55 DB 00 MOV   [219],0       (0472) 
1641: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1644: 55 0B 00 MOV   [11],0        (0474)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
1647: 26 0A 00 AND   [10],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
164A: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_3_RX_PARITY_ERROR | HELLO_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
164B: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
164E: 51 0A    MOV   A,[10]        (0511) ;        0x40CC    Overrun Error
1650: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1652: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_3_iReadChar:
                                   (0523) _HELLO_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_3_RX_ERROR|HELLO_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_3_RXBUF_ENABLE)
                                   (0552) .SECTION
1653: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1656: 51 0A    MOV   A,[10]        (0554) ;-----------------------------------------------------------------------------
1658: 21 F0    AND   A,240         (0555) ;
165A: 26 0A 0F AND   [10],15       (0556) ;     Command Buffer commands
                                   (0557) ;
165D: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_3_CmdReset:
165E: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_3_CmdReset:
1661: 51 0B    MOV   A,[11]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_3_aRxBuffer
1663: 7F       RET                 (0590)    mov [HELLO_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
                                   (0594)    mov [HELLO_3_bRxCnt], 0x00
                                   (0595)    and [HELLO_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_3_bCmdCheck:
                                   (0628) _HELLO_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0631)    mov A,  [HELLO_3_fStatus]
                                   (0632)    and A, HELLO_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1664: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1666: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1669: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
166C: 50 28    MOV   A,40          (0648) ;     BYTE  fStatus - Status of command receive buffer.
166E: 02 DB    ADD   A,[219]       (0649) ;                     Returns non-zero value in A if command is valid.
1670: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1671: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1673: B0 04    JNZ   0x1678        (0653) ;           0x10 => Software Buffer OverRun
1675: 10       PUSH  X             (0654) ;
1676: 80 33    JMP   0x16AA        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1678: 39 00    CMP   A,0           (0660) ;    functions.
167A: B0 11    JNZ   0x168C        (0661) ;          
167C: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
167D: 76 DB    INC   [219]         (0663) ;          CUR_PP
167F: 52 00    MOV   A,[X+0]       (0664) ;
1681: 3C DB 0F CMP   [219],15      (0665) ;     Error Status is clear when read.
1684: BF F3    JNZ   0x1678        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1686: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_3_bErrCheck:
1687: 56 00 00 MOV   [X+0],0       (0671) _HELLO_3_bErrCheck:
168A: 80 1F    JMP   0x16AA        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0674)    mov A,  [HELLO_3_fStatus]
168C: 10       PUSH  X             (0675)    and A, HELLO_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_3_fStatus], ~HELLO_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
168D: 75       INC   X             (0679) .ENDSECTION
168E: 76 DB    INC   [219]         (0680) 
1690: 3C DB 0F CMP   [219],15      (0681) .SECTION
1693: AF F3    JZ    0x1687        (0682) ;-----------------------------------------------------------------------------
1695: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_3_bCmdLength
1697: A0 12    JZ    0x16AA        (0684) ;
1699: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
169B: BF F1    JNZ   0x168D        (0686) ;     Get length of command string
                                   (0687) ;
169D: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
16A0: 76 DB    INC   [219]         (0689) ;     none.
16A2: 3C DB 0F CMP   [219],15      (0690) ;
16A5: B0 04    JNZ   0x16AA        (0691) ;  RETURNS:
16A7: 55 DB 0F MOV   [219],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
16AA: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
16AB: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
16AC: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
16AF: B0 0B    JNZ   0x16BB        (0699) ;    functions.
16B1: 20       POP   X             (0700) ;          
16B2: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
16B4: 50 00    MOV   A,0           (0702) ;          CUR_PP
16B6: 70 3F    AND   F,63
16B8: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_3_bCmdLength:
16BA: 7F       RET                 (0705) _HELLO_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
16BB: 20       POP   X             (0708)    mov A,  [HELLO_3_bRxCnt]
16BC: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
16BE: 70 3F    AND   F,63
16C0: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
16C2: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
16C3: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
16C6: 50 28    MOV   A,40          (0744) ;     each lexically distinct element into a null-terminated string by replacing
16C8: 02 DB    ADD   A,[219]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
16CA: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
16CB: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_3_szGetParam, is
16CE: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_2int.asm
16CF: 10       PUSH  X             (0104) ;;*****************************************************************************
16D0: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_2INT.asm
16D2: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
16D3: 58 0D    MOV   X,[13]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
16D5: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
16D7: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
16D8: 21 08    AND   A,8           (0114) ;;*****************************************************************************
16DA: B0 04    JNZ   0x16DF        (0115) 
16DC: 18       POP   A             (0116) include "m8c.inc"
16DD: 80 5E    JMP   0x173C        (0117) include "memory.inc"
                                   (0118) include "HELLO_2.inc"
                                   (0119) 
                                   (0120) 
16DF: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
16E0: 21 E0    AND   A,224         (0124) export  _HELLO_2_ISR
16E2: A0 12    JZ    0x16F5        (0125) 
                                   (0126) 
16E4: 2C 0C    OR    [12],A        (0127) IF (HELLO_2_RXBUF_ENABLE)
                                   (0128) export  HELLO_2_aRxBuffer
16E6: 49 2E 00 TST   REG[46],0     (0129) export _HELLO_2_aRxBuffer
                                   (0130) export  HELLO_2_bRxCnt
16E9: 21 20    AND   A,32          (0131) export _HELLO_2_bRxCnt
16EB: A0 50    JZ    0x173C        (0132) export  HELLO_2_fStatus
                                   (0133) export _HELLO_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
16ED: 41 2F FE AND   REG[47],254   (0136) 
16F0: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
16F3: 80 48    JMP   0x173C        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_2_RXBUF_ENABLE)
16F5: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_2_fStatus:
                                   (0144) _HELLO_2_fStatus:      BLK  1
16F7: 47 0C 01 TST   [12],1        (0145)  HELLO_2_bRxCnt:
16FA: B0 41    JNZ   0x173C        (0146) _HELLO_2_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_2_RAM(RAM,REL,CON)
16FC: 39 00    CMP   A,0           (0148)  HELLO_2_aRxBuffer:    
16FE: B0 14    JNZ   0x1713        (0149) _HELLO_2_aRxBuffer:    BLK HELLO_2_RX_BUFFER_SIZE
1700: 2E 0C 01 OR    [12],1        (0150) ENDIF
                                   (0151) 
1703: 62 D3 00 MOV   REG[211],0    (0152) 
1706: 70 3F    AND   F,63
1708: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
170A: 56 B8 00 MOV   [X-72],0      (0154) 
170D: 70 3F    AND   F,63
170F: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1711: 80 2A    JMP   0x173C        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1713: 3C 0D 0F CMP   [13],15       (0167) ;------------------------
1716: C0 14    JC    0x172B        (0168) 
1718: 2E 0C 10 OR    [12],16       (0169) 
                                   (0170) ;------------------------
171B: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
171E: 70 3F    AND   F,63
1720: 71 80    OR    F,128         (0172) ;------------------------
1722: 56 B8 00 MOV   [X-72],0      (0173) 
1725: 70 3F    AND   F,63
1727: 71 00    OR    F,0           (0174) 
1729: 80 12    JMP   0x173C        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
172B: 75       INC   X             (0179) 
172C: 5A 0D    MOV   [13],X        (0180) 
172E: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
172F: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1732: 70 3F    AND   F,63
1734: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_2_ISR
1736: 54 B8    MOV   [X-72],A      (0185) ;
1738: 70 3F    AND   F,63
173A: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
173C: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
173D: 60 D3    MOV   REG[211],A    (0191) _HELLO_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
173F: 20       POP   X             (0195)    ; Insert your custom code below this banner
1740: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1742: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_2.asm
                                   (0121) ;;*****************************************************************************
1745: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_2.inc"
1746: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
1749: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_2_EnableInt
                                   (0155) export  _HELLO_2_EnableInt
                                   (0156) export   HELLO_2_DisableInt
                                   (0157) export  _HELLO_2_DisableInt
                                   (0158) export   HELLO_2_Start
                                   (0159) export  _HELLO_2_Start
                                   (0160) export   HELLO_2_Stop
                                   (0161) export  _HELLO_2_Stop
                                   (0162) export   HELLO_2_bReadRxData
                                   (0163) export  _HELLO_2_bReadRxData
                                   (0164) export   HELLO_2_bReadRxStatus
                                   (0165) export  _HELLO_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_2_ReadRxData
                                   (0170) export _bHELLO_2_ReadRxData
                                   (0171) export  bHELLO_2_ReadRxStatus
                                   (0172) export _bHELLO_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_2_cGetChar
174A: 29 01    OR    A,1           (0179) export _HELLO_2_cGetChar
174C: 60 2F    MOV   REG[47],A     (0180) export  HELLO_2_cReadChar
                                   (0181) export _HELLO_2_cReadChar
174E: 7F       RET                 (0182) export  HELLO_2_iReadChar
                                   (0183) export _HELLO_2_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_2_RXBUF_ENABLE)
                                   (0186) export  HELLO_2_CmdReset
                                   (0187) export _HELLO_2_CmdReset
                                   (0188) export  HELLO_2_bCmdCheck
                                   (0189) export _HELLO_2_bCmdCheck
                                   (0190) export  HELLO_2_bCmdLength
                                   (0191) export _HELLO_2_bCmdLength
                                   (0192) export  HELLO_2_bErrCheck
                                   (0193) export _HELLO_2_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_2_szGetParam
                                   (0196) export _HELLO_2_szGetParam
                                   (0197) export  HELLO_2_szGetRestOfParams
                                   (0198) export _HELLO_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
174F: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1752: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_2_EnableInt:
                                   (0238) _HELLO_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1753: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1755: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_2_DisableInt:
                                   (0267) _HELLO_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1756: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
1758: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_2_Start:
                                   (0297) _HELLO_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1759: 49 2F 08 TST   REG[47],8     (0311) ;
175C: AF FC    JZ    0x1759        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
175E: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1760: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_2_Stop:
                                   (0326) _HELLO_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1761: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
1763: 08       PUSH  A             (0347) ;
1764: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1766: B0 04    JNZ   0x176B        (0349) ;    The A and X registers may be modified by this or future implementations
1768: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1769: 80 0B    JMP   0x1775        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
176B: 5D 2E    MOV   A,REG[46]     (0354) ;
176D: 4B       SWAP  A,X           (0355)  HELLO_2_bReadRxData:
                                   (0356) _HELLO_2_bReadRxData:
176E: 18       POP   A             (0357)  bHELLO_2_ReadRxData:
176F: 21 A0    AND   A,160         (0358) _bHELLO_2_ReadRxData:
1771: B0 03    JNZ   0x1775        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1773: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1774: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1775: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_2_bReadRxStatus
                                   (0368) ;
1777: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_2_bReadRxStatus:
                                   (0388) _HELLO_2_bReadRxStatus:
                                   (0389)  bHELLO_2_ReadRxStatus:
                                   (0390) _bHELLO_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1778: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
177A: 21 E8    AND   A,232         (0408) ;
177C: 08       PUSH  A             (0409) ;  ARGUMENTS:
177D: 21 08    AND   A,8           (0410) ;      none
177F: B0 07    JNZ   0x1787        (0411) ;
1781: 18       POP   A             (0412) ;  RETURNS:
1782: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1784: 4B       SWAP  A,X           (0414) ;
1785: 80 07    JMP   0x178D        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1787: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1788: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
178A: 4B       SWAP  A,X           (0420) ;    functions.
178B: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
178D: 7F       RET                 (0426)  HELLO_2_cGetChar:
                                   (0427) _HELLO_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_2_CONTROL_REG],HELLO_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_2_cReadChar:
                                   (0463) _HELLO_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
178E: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1791: 55 B8 00 MOV   [184],0       (0470)    pop  A
1794: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1797: 55 DA 00 MOV   [218],0       (0472) 
179A: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
179D: 55 0D 00 MOV   [13],0        (0474)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
17A0: 26 0C 00 AND   [12],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
17A3: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_2_RX_PARITY_ERROR | HELLO_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
17A4: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
17A7: 51 0C    MOV   A,[12]        (0511) ;        0x40CC    Overrun Error
17A9: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
17AB: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_2_iReadChar:
                                   (0523) _HELLO_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_2_RX_ERROR|HELLO_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_2_RXBUF_ENABLE)
                                   (0552) .SECTION
17AC: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
17AF: 51 0C    MOV   A,[12]        (0554) ;-----------------------------------------------------------------------------
17B1: 21 F0    AND   A,240         (0555) ;
17B3: 26 0C 0F AND   [12],15       (0556) ;     Command Buffer commands
                                   (0557) ;
17B6: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_2_CmdReset:
17B7: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_2_CmdReset:
17BA: 51 0D    MOV   A,[13]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_2_aRxBuffer
17BC: 7F       RET                 (0590)    mov [HELLO_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
                                   (0594)    mov [HELLO_2_bRxCnt], 0x00
                                   (0595)    and [HELLO_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_2_bCmdCheck:
                                   (0628) _HELLO_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0631)    mov A,  [HELLO_2_fStatus]
                                   (0632)    and A, HELLO_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
17BD: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
17BF: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
17C2: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
17C5: 50 B8    MOV   A,184         (0648) ;     BYTE  fStatus - Status of command receive buffer.
17C7: 02 DA    ADD   A,[218]       (0649) ;                     Returns non-zero value in A if command is valid.
17C9: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
17CA: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
17CC: B0 04    JNZ   0x17D1        (0653) ;           0x10 => Software Buffer OverRun
17CE: 10       PUSH  X             (0654) ;
17CF: 80 33    JMP   0x1803        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
17D1: 39 00    CMP   A,0           (0660) ;    functions.
17D3: B0 11    JNZ   0x17E5        (0661) ;          
17D5: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
17D6: 76 DA    INC   [218]         (0663) ;          CUR_PP
17D8: 52 00    MOV   A,[X+0]       (0664) ;
17DA: 3C DA 0F CMP   [218],15      (0665) ;     Error Status is clear when read.
17DD: BF F3    JNZ   0x17D1        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
17DF: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_2_bErrCheck:
17E0: 56 00 00 MOV   [X+0],0       (0671) _HELLO_2_bErrCheck:
17E3: 80 1F    JMP   0x1803        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0674)    mov A,  [HELLO_2_fStatus]
17E5: 10       PUSH  X             (0675)    and A, HELLO_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_2_fStatus], ~HELLO_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
17E6: 75       INC   X             (0679) .ENDSECTION
17E7: 76 DA    INC   [218]         (0680) 
17E9: 3C DA 0F CMP   [218],15      (0681) .SECTION
17EC: AF F3    JZ    0x17E0        (0682) ;-----------------------------------------------------------------------------
17EE: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_2_bCmdLength
17F0: A0 12    JZ    0x1803        (0684) ;
17F2: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
17F4: BF F1    JNZ   0x17E6        (0686) ;     Get length of command string
                                   (0687) ;
17F6: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
17F9: 76 DA    INC   [218]         (0689) ;     none.
17FB: 3C DA 0F CMP   [218],15      (0690) ;
17FE: B0 04    JNZ   0x1803        (0691) ;  RETURNS:
1800: 55 DA 0F MOV   [218],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1803: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1804: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1805: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1808: B0 0B    JNZ   0x1814        (0699) ;    functions.
180A: 20       POP   X             (0700) ;          
180B: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
180D: 50 00    MOV   A,0           (0702) ;          CUR_PP
180F: 70 3F    AND   F,63
1811: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_2_bCmdLength:
1813: 7F       RET                 (0705) _HELLO_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
1814: 20       POP   X             (0708)    mov A,  [HELLO_2_bRxCnt]
1815: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1817: 70 3F    AND   F,63
1819: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
181B: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
181C: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
181F: 50 B8    MOV   A,184         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1821: 02 DA    ADD   A,[218]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1823: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1824: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_2_szGetParam, is
1827: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_1int.asm
1828: 10       PUSH  X             (0104) ;;*****************************************************************************
1829: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_1INT.asm
182B: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
182C: 58 0F    MOV   X,[15]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
182E: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1830: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1831: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1833: B0 04    JNZ   0x1838        (0115) 
1835: 18       POP   A             (0116) include "m8c.inc"
1836: 80 5E    JMP   0x1895        (0117) include "memory.inc"
                                   (0118) include "HELLO_1.inc"
                                   (0119) 
                                   (0120) 
1838: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1839: 21 E0    AND   A,224         (0124) export  _HELLO_1_ISR
183B: A0 12    JZ    0x184E        (0125) 
                                   (0126) 
183D: 2C 0E    OR    [14],A        (0127) IF (HELLO_1_RXBUF_ENABLE)
                                   (0128) export  HELLO_1_aRxBuffer
183F: 49 2A 00 TST   REG[42],0     (0129) export _HELLO_1_aRxBuffer
                                   (0130) export  HELLO_1_bRxCnt
1842: 21 20    AND   A,32          (0131) export _HELLO_1_bRxCnt
1844: A0 50    JZ    0x1895        (0132) export  HELLO_1_fStatus
                                   (0133) export _HELLO_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
1846: 41 2B FE AND   REG[43],254   (0136) 
1849: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
184C: 80 48    JMP   0x1895        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_1_RXBUF_ENABLE)
184E: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_1_fStatus:
                                   (0144) _HELLO_1_fStatus:      BLK  1
1850: 47 0E 01 TST   [14],1        (0145)  HELLO_1_bRxCnt:
1853: B0 41    JNZ   0x1895        (0146) _HELLO_1_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_1_RAM(RAM,REL,CON)
1855: 39 00    CMP   A,0           (0148)  HELLO_1_aRxBuffer:    
1857: B0 14    JNZ   0x186C        (0149) _HELLO_1_aRxBuffer:    BLK HELLO_1_RX_BUFFER_SIZE
1859: 2E 0E 01 OR    [14],1        (0150) ENDIF
                                   (0151) 
185C: 62 D3 00 MOV   REG[211],0    (0152) 
185F: 70 3F    AND   F,63
1861: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1863: 56 78 00 MOV   [X+120],0     (0154) 
1866: 70 3F    AND   F,63
1868: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
186A: 80 2A    JMP   0x1895        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
186C: 3C 0F 0F CMP   [15],15       (0167) ;------------------------
186F: C0 14    JC    0x1884        (0168) 
1871: 2E 0E 10 OR    [14],16       (0169) 
                                   (0170) ;------------------------
1874: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1877: 70 3F    AND   F,63
1879: 71 80    OR    F,128         (0172) ;------------------------
187B: 56 78 00 MOV   [X+120],0     (0173) 
187E: 70 3F    AND   F,63
1880: 71 00    OR    F,0           (0174) 
1882: 80 12    JMP   0x1895        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1884: 75       INC   X             (0179) 
1885: 5A 0F    MOV   [15],X        (0180) 
1887: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1888: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
188B: 70 3F    AND   F,63
188D: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_1_ISR
188F: 54 78    MOV   [X+120],A     (0185) ;
1891: 70 3F    AND   F,63
1893: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1895: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1896: 60 D3    MOV   REG[211],A    (0191) _HELLO_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1898: 20       POP   X             (0195)    ; Insert your custom code below this banner
1899: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
189B: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_1.asm
                                   (0121) ;;*****************************************************************************
189E: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_1.inc"
189F: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
18A2: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_1_EnableInt
                                   (0155) export  _HELLO_1_EnableInt
                                   (0156) export   HELLO_1_DisableInt
                                   (0157) export  _HELLO_1_DisableInt
                                   (0158) export   HELLO_1_Start
                                   (0159) export  _HELLO_1_Start
                                   (0160) export   HELLO_1_Stop
                                   (0161) export  _HELLO_1_Stop
                                   (0162) export   HELLO_1_bReadRxData
                                   (0163) export  _HELLO_1_bReadRxData
                                   (0164) export   HELLO_1_bReadRxStatus
                                   (0165) export  _HELLO_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_1_ReadRxData
                                   (0170) export _bHELLO_1_ReadRxData
                                   (0171) export  bHELLO_1_ReadRxStatus
                                   (0172) export _bHELLO_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_1_cGetChar
18A3: 29 01    OR    A,1           (0179) export _HELLO_1_cGetChar
18A5: 60 2B    MOV   REG[43],A     (0180) export  HELLO_1_cReadChar
                                   (0181) export _HELLO_1_cReadChar
18A7: 7F       RET                 (0182) export  HELLO_1_iReadChar
                                   (0183) export _HELLO_1_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_1_RXBUF_ENABLE)
                                   (0186) export  HELLO_1_CmdReset
                                   (0187) export _HELLO_1_CmdReset
                                   (0188) export  HELLO_1_bCmdCheck
                                   (0189) export _HELLO_1_bCmdCheck
                                   (0190) export  HELLO_1_bCmdLength
                                   (0191) export _HELLO_1_bCmdLength
                                   (0192) export  HELLO_1_bErrCheck
                                   (0193) export _HELLO_1_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_1_szGetParam
                                   (0196) export _HELLO_1_szGetParam
                                   (0197) export  HELLO_1_szGetRestOfParams
                                   (0198) export _HELLO_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
18A8: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
18AB: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_1_EnableInt:
                                   (0238) _HELLO_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
18AC: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
18AE: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_1_DisableInt:
                                   (0267) _HELLO_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
18AF: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
18B1: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_1_Start:
                                   (0297) _HELLO_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
18B2: 49 2B 08 TST   REG[43],8     (0311) ;
18B5: AF FC    JZ    0x18B2        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
18B7: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
18B9: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_1_Stop:
                                   (0326) _HELLO_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
18BA: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
18BC: 08       PUSH  A             (0347) ;
18BD: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
18BF: B0 04    JNZ   0x18C4        (0349) ;    The A and X registers may be modified by this or future implementations
18C1: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
18C2: 80 0B    JMP   0x18CE        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
18C4: 5D 2A    MOV   A,REG[42]     (0354) ;
18C6: 4B       SWAP  A,X           (0355)  HELLO_1_bReadRxData:
                                   (0356) _HELLO_1_bReadRxData:
18C7: 18       POP   A             (0357)  bHELLO_1_ReadRxData:
18C8: 21 A0    AND   A,160         (0358) _bHELLO_1_ReadRxData:
18CA: B0 03    JNZ   0x18CE        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
18CC: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
18CD: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
18CE: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_1_bReadRxStatus
                                   (0368) ;
18D0: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_1_bReadRxStatus:
                                   (0388) _HELLO_1_bReadRxStatus:
                                   (0389)  bHELLO_1_ReadRxStatus:
                                   (0390) _bHELLO_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
18D1: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
18D3: 21 E8    AND   A,232         (0408) ;
18D5: 08       PUSH  A             (0409) ;  ARGUMENTS:
18D6: 21 08    AND   A,8           (0410) ;      none
18D8: B0 07    JNZ   0x18E0        (0411) ;
18DA: 18       POP   A             (0412) ;  RETURNS:
18DB: 29 01    OR    A,1           (0413) ;     char that is returned from UART
18DD: 4B       SWAP  A,X           (0414) ;
18DE: 80 07    JMP   0x18E6        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
18E0: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
18E1: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
18E3: 4B       SWAP  A,X           (0420) ;    functions.
18E4: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
18E6: 7F       RET                 (0426)  HELLO_1_cGetChar:
                                   (0427) _HELLO_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_1_CONTROL_REG],HELLO_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_1_cReadChar:
                                   (0463) _HELLO_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
18E7: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
18EA: 55 78 00 MOV   [120],0       (0470)    pop  A
18ED: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
18F0: 55 D9 00 MOV   [217],0       (0472) 
18F3: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
18F6: 55 0F 00 MOV   [15],0        (0474)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
18F9: 26 0E 00 AND   [14],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
18FC: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_1_RX_PARITY_ERROR | HELLO_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
18FD: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1900: 51 0E    MOV   A,[14]        (0511) ;        0x40CC    Overrun Error
1902: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1904: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_1_iReadChar:
                                   (0523) _HELLO_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_1_RX_ERROR|HELLO_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_1_RXBUF_ENABLE)
                                   (0552) .SECTION
1905: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1908: 51 0E    MOV   A,[14]        (0554) ;-----------------------------------------------------------------------------
190A: 21 F0    AND   A,240         (0555) ;
190C: 26 0E 0F AND   [14],15       (0556) ;     Command Buffer commands
                                   (0557) ;
190F: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_1_CmdReset:
1910: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_1_CmdReset:
1913: 51 0F    MOV   A,[15]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_1_aRxBuffer
1915: 7F       RET                 (0590)    mov [HELLO_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
                                   (0594)    mov [HELLO_1_bRxCnt], 0x00
                                   (0595)    and [HELLO_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_1_bCmdCheck:
                                   (0628) _HELLO_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0631)    mov A,  [HELLO_1_fStatus]
                                   (0632)    and A, HELLO_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1916: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1918: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
191B: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
191E: 50 78    MOV   A,120         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1920: 02 D9    ADD   A,[217]       (0649) ;                     Returns non-zero value in A if command is valid.
1922: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1923: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1925: B0 04    JNZ   0x192A        (0653) ;           0x10 => Software Buffer OverRun
1927: 10       PUSH  X             (0654) ;
1928: 80 33    JMP   0x195C        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
192A: 39 00    CMP   A,0           (0660) ;    functions.
192C: B0 11    JNZ   0x193E        (0661) ;          
192E: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
192F: 76 D9    INC   [217]         (0663) ;          CUR_PP
1931: 52 00    MOV   A,[X+0]       (0664) ;
1933: 3C D9 0F CMP   [217],15      (0665) ;     Error Status is clear when read.
1936: BF F3    JNZ   0x192A        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1938: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_1_bErrCheck:
1939: 56 00 00 MOV   [X+0],0       (0671) _HELLO_1_bErrCheck:
193C: 80 1F    JMP   0x195C        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0674)    mov A,  [HELLO_1_fStatus]
193E: 10       PUSH  X             (0675)    and A, HELLO_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_1_fStatus], ~HELLO_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
193F: 75       INC   X             (0679) .ENDSECTION
1940: 76 D9    INC   [217]         (0680) 
1942: 3C D9 0F CMP   [217],15      (0681) .SECTION
1945: AF F3    JZ    0x1939        (0682) ;-----------------------------------------------------------------------------
1947: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_1_bCmdLength
1949: A0 12    JZ    0x195C        (0684) ;
194B: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
194D: BF F1    JNZ   0x193F        (0686) ;     Get length of command string
                                   (0687) ;
194F: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1952: 76 D9    INC   [217]         (0689) ;     none.
1954: 3C D9 0F CMP   [217],15      (0690) ;
1957: B0 04    JNZ   0x195C        (0691) ;  RETURNS:
1959: 55 D9 0F MOV   [217],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
195C: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
195D: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
195E: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1961: B0 0B    JNZ   0x196D        (0699) ;    functions.
1963: 20       POP   X             (0700) ;          
1964: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1966: 50 00    MOV   A,0           (0702) ;          CUR_PP
1968: 70 3F    AND   F,63
196A: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_1_bCmdLength:
196C: 7F       RET                 (0705) _HELLO_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
196D: 20       POP   X             (0708)    mov A,  [HELLO_1_bRxCnt]
196E: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1970: 70 3F    AND   F,63
1972: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1974: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1975: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1978: 50 78    MOV   A,120         (0744) ;     each lexically distinct element into a null-terminated string by replacing
197A: 02 D9    ADD   A,[217]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
197C: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
197D: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_1_szGetParam, is
1980: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_4int.asm
1981: 10       PUSH  X             (0104) ;;*****************************************************************************
1982: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_4INT.asm
1984: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1985: 58 11    MOV   X,[17]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1987: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1989: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
198A: 21 08    AND   A,8           (0114) ;;*****************************************************************************
198C: B0 04    JNZ   0x1991        (0115) 
198E: 18       POP   A             (0116) include "m8c.inc"
198F: 80 5E    JMP   0x19EE        (0117) include "memory.inc"
                                   (0118) include "CHILD_4.inc"
                                   (0119) 
                                   (0120) 
1991: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1992: 21 E0    AND   A,224         (0124) export  _CHILD_4_ISR
1994: A0 12    JZ    0x19A7        (0125) 
                                   (0126) 
1996: 2C 10    OR    [16],A        (0127) IF (CHILD_4_RXBUF_ENABLE)
                                   (0128) export  CHILD_4_aRxBuffer
1998: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_4_aRxBuffer
                                   (0130) export  CHILD_4_bRxCnt
199B: 21 20    AND   A,32          (0131) export _CHILD_4_bRxCnt
199D: A0 50    JZ    0x19EE        (0132) export  CHILD_4_fStatus
                                   (0133) export _CHILD_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
199F: 41 2B FE AND   REG[43],254   (0136) 
19A2: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
19A5: 80 48    JMP   0x19EE        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_4_RXBUF_ENABLE)
19A7: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_4_fStatus:
                                   (0144) _CHILD_4_fStatus:      BLK  1
19A9: 47 10 01 TST   [16],1        (0145)  CHILD_4_bRxCnt:
19AC: B0 41    JNZ   0x19EE        (0146) _CHILD_4_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_4_RAM(RAM,REL,CON)
19AE: 39 00    CMP   A,0           (0148)  CHILD_4_aRxBuffer:    
19B0: B0 14    JNZ   0x19C5        (0149) _CHILD_4_aRxBuffer:    BLK CHILD_4_RX_BUFFER_SIZE
19B2: 2E 10 01 OR    [16],1        (0150) ENDIF
                                   (0151) 
19B5: 62 D3 00 MOV   REG[211],0    (0152) 
19B8: 70 3F    AND   F,63
19BA: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
19BC: 56 88 00 MOV   [X-120],0     (0154) 
19BF: 70 3F    AND   F,63
19C1: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
19C3: 80 2A    JMP   0x19EE        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
19C5: 3C 11 0F CMP   [17],15       (0167) ;------------------------
19C8: C0 14    JC    0x19DD        (0168) 
19CA: 2E 10 10 OR    [16],16       (0169) 
                                   (0170) ;------------------------
19CD: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
19D0: 70 3F    AND   F,63
19D2: 71 80    OR    F,128         (0172) ;------------------------
19D4: 56 88 00 MOV   [X-120],0     (0173) 
19D7: 70 3F    AND   F,63
19D9: 71 00    OR    F,0           (0174) 
19DB: 80 12    JMP   0x19EE        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
19DD: 75       INC   X             (0179) 
19DE: 5A 11    MOV   [17],X        (0180) 
19E0: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
19E1: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
19E4: 70 3F    AND   F,63
19E6: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_4_ISR
19E8: 54 88    MOV   [X-120],A     (0185) ;
19EA: 70 3F    AND   F,63
19EC: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
19EE: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
19EF: 60 D3    MOV   REG[211],A    (0191) _CHILD_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
19F1: 20       POP   X             (0195)    ; Insert your custom code below this banner
19F2: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
19F4: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_4_timeout.asm
                                   (0102) ;;*****************************************************************************
19F7: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_4_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_4_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
19F8: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
19FB: 7F       RET                 (0131) export  CHILD_4_TIMEOUT_EnableInt
                                   (0132) export _CHILD_4_TIMEOUT_EnableInt
                                   (0133) export  CHILD_4_TIMEOUT_DisableInt
                                   (0134) export _CHILD_4_TIMEOUT_DisableInt
                                   (0135) export  CHILD_4_TIMEOUT_Start
                                   (0136) export _CHILD_4_TIMEOUT_Start
                                   (0137) export  CHILD_4_TIMEOUT_Stop
                                   (0138) export _CHILD_4_TIMEOUT_Stop
                                   (0139) export  CHILD_4_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_4_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_4_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_4_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_4_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_4_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_4_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_4_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
19FC: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
19FF: 7F       RET                 (0159) export  wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response4_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_4_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1A00: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1A03: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_4_TIMEOUT_EnableInt:
                                   (0200) _CHILD_4_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_4_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_4_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1A04: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1A06: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1A07: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1A09: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_4_TIMEOUT_DisableInt:
                                   (0228) _CHILD_4_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_4_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1A0A: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1A0C: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1A0D: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1A0F: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_4_TIMEOUT_Start:
                                   (0256) _CHILD_4_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_4_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1A10: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1A12: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1A13: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1A15: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_4_TIMEOUT_Stop:
                                   (0284) _CHILD_4_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_4_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_4_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_4_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_4_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_4_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_4_TIMEOUT_Stop to disable).
1A16: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1A17: 38 03    ADD   SP,3          (0334) ;
1A19: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1A1B: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1A1C: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1A1E: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1A1F: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1A21: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1A22: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1A24: 5D 26    MOV   A,REG[38]     (0343) ;
1A26: 54 01    MOV   [X+1],A       (0344)  CHILD_4_TIMEOUT_WriteCompareValue:
1A28: 5D 22    MOV   A,REG[34]     (0345) _CHILD_4_TIMEOUT_WriteCompareValue:
1A2A: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1A2C: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG], A
1A2E: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1A31: A0 03    JZ    0x1A35        (0349)    mov   reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG], A
1A33: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1A35: 54 00    MOV   [X+0],A       (0352) 
1A37: 70 FE    AND   F,254         (0353) .ENDSECTION
1A39: 41 23 FE AND   REG[35],254   (0354) 
1A3C: 18       POP   A             (0355) 
1A3D: 60 26    MOV   REG[38],A     (0356) .SECTION
1A3F: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1A40: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadCompareValue
1A42: 18       POP   A             (0359) ;
1A43: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1A45: 18       POP   A             (0361) ;     Reads the Compare registers.
1A46: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1A47: 70 3F    AND   F,63
1A49: 71 C0    OR    F,192         (0363) ;
1A4B: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1A4C: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1A4E: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1A50: 5C       MOV   X,A           (0409) ;
1A51: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1A54: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_4.asm
                                   (0121) ;;*****************************************************************************
1A57: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_4.inc"
1A58: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1A5B: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_4_EnableInt
                                   (0155) export  _CHILD_4_EnableInt
                                   (0156) export   CHILD_4_DisableInt
                                   (0157) export  _CHILD_4_DisableInt
                                   (0158) export   CHILD_4_Start
                                   (0159) export  _CHILD_4_Start
                                   (0160) export   CHILD_4_Stop
                                   (0161) export  _CHILD_4_Stop
                                   (0162) export   CHILD_4_bReadRxData
                                   (0163) export  _CHILD_4_bReadRxData
                                   (0164) export   CHILD_4_bReadRxStatus
                                   (0165) export  _CHILD_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_4_ReadRxData
                                   (0170) export _bCHILD_4_ReadRxData
                                   (0171) export  bCHILD_4_ReadRxStatus
                                   (0172) export _bCHILD_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_4_cGetChar
1A5C: 29 01    OR    A,1           (0179) export _CHILD_4_cGetChar
1A5E: 60 2B    MOV   REG[43],A     (0180) export  CHILD_4_cReadChar
                                   (0181) export _CHILD_4_cReadChar
1A60: 7F       RET                 (0182) export  CHILD_4_iReadChar
                                   (0183) export _CHILD_4_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_4_RXBUF_ENABLE)
                                   (0186) export  CHILD_4_CmdReset
                                   (0187) export _CHILD_4_CmdReset
                                   (0188) export  CHILD_4_bCmdCheck
                                   (0189) export _CHILD_4_bCmdCheck
                                   (0190) export  CHILD_4_bCmdLength
                                   (0191) export _CHILD_4_bCmdLength
                                   (0192) export  CHILD_4_bErrCheck
                                   (0193) export _CHILD_4_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_4_szGetParam
                                   (0196) export _CHILD_4_szGetParam
                                   (0197) export  CHILD_4_szGetRestOfParams
                                   (0198) export _CHILD_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1A61: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1A64: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_4_EnableInt:
                                   (0238) _CHILD_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1A65: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1A67: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_4_DisableInt:
                                   (0267) _CHILD_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1A68: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1A6A: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_4_Start:
                                   (0297) _CHILD_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1A6B: 49 2B 08 TST   REG[43],8     (0311) ;
1A6E: AF FC    JZ    0x1A6B        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1A70: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1A72: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_4_Stop:
                                   (0326) _CHILD_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1A73: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1A75: 08       PUSH  A             (0347) ;
1A76: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1A78: B0 04    JNZ   0x1A7D        (0349) ;    The A and X registers may be modified by this or future implementations
1A7A: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1A7B: 80 0B    JMP   0x1A87        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1A7D: 5D 2A    MOV   A,REG[42]     (0354) ;
1A7F: 4B       SWAP  A,X           (0355)  CHILD_4_bReadRxData:
                                   (0356) _CHILD_4_bReadRxData:
1A80: 18       POP   A             (0357)  bCHILD_4_ReadRxData:
1A81: 21 A0    AND   A,160         (0358) _bCHILD_4_ReadRxData:
1A83: B0 03    JNZ   0x1A87        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1A85: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1A86: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1A87: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_4_bReadRxStatus
                                   (0368) ;
1A89: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_4_bReadRxStatus:
                                   (0388) _CHILD_4_bReadRxStatus:
                                   (0389)  bCHILD_4_ReadRxStatus:
                                   (0390) _bCHILD_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1A8A: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1A8C: 21 E8    AND   A,232         (0408) ;
1A8E: 08       PUSH  A             (0409) ;  ARGUMENTS:
1A8F: 21 08    AND   A,8           (0410) ;      none
1A91: B0 07    JNZ   0x1A99        (0411) ;
1A93: 18       POP   A             (0412) ;  RETURNS:
1A94: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1A96: 4B       SWAP  A,X           (0414) ;
1A97: 80 07    JMP   0x1A9F        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1A99: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1A9A: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1A9C: 4B       SWAP  A,X           (0420) ;    functions.
1A9D: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1A9F: 7F       RET                 (0426)  CHILD_4_cGetChar:
                                   (0427) _CHILD_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_4_CONTROL_REG],CHILD_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_4_cReadChar:
                                   (0463) _CHILD_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
1AA0: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1AA3: 55 88 00 MOV   [136],0       (0470)    pop  A
1AA6: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1AA9: 55 D8 00 MOV   [216],0       (0472) 
1AAC: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1AAF: 55 11 00 MOV   [17],0        (0474)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
1AB2: 26 10 00 AND   [16],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1AB5: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_4_RX_PARITY_ERROR | CHILD_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1AB6: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1AB9: 51 10    MOV   A,[16]        (0511) ;        0x40CC    Overrun Error
1ABB: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1ABD: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_4_iReadChar:
                                   (0523) _CHILD_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_4_RX_ERROR|CHILD_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_4_RXBUF_ENABLE)
                                   (0552) .SECTION
1ABE: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1AC1: 51 10    MOV   A,[16]        (0554) ;-----------------------------------------------------------------------------
1AC3: 21 F0    AND   A,240         (0555) ;
1AC5: 26 10 0F AND   [16],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1AC8: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_4_CmdReset:
1AC9: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_4_CmdReset:
1ACC: 51 11    MOV   A,[17]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_4_aRxBuffer
1ACE: 7F       RET                 (0590)    mov [CHILD_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
                                   (0594)    mov [CHILD_4_bRxCnt], 0x00
                                   (0595)    and [CHILD_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_4_bCmdCheck:
                                   (0628) _CHILD_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0631)    mov A,  [CHILD_4_fStatus]
                                   (0632)    and A, CHILD_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1ACF: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1AD1: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1AD4: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1AD7: 50 88    MOV   A,136         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1AD9: 02 D8    ADD   A,[216]       (0649) ;                     Returns non-zero value in A if command is valid.
1ADB: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1ADC: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1ADE: B0 04    JNZ   0x1AE3        (0653) ;           0x10 => Software Buffer OverRun
1AE0: 10       PUSH  X             (0654) ;
1AE1: 80 33    JMP   0x1B15        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1AE3: 39 00    CMP   A,0           (0660) ;    functions.
1AE5: B0 11    JNZ   0x1AF7        (0661) ;          
1AE7: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1AE8: 76 D8    INC   [216]         (0663) ;          CUR_PP
1AEA: 52 00    MOV   A,[X+0]       (0664) ;
1AEC: 3C D8 0F CMP   [216],15      (0665) ;     Error Status is clear when read.
1AEF: BF F3    JNZ   0x1AE3        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1AF1: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_4_bErrCheck:
1AF2: 56 00 00 MOV   [X+0],0       (0671) _CHILD_4_bErrCheck:
1AF5: 80 1F    JMP   0x1B15        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0674)    mov A,  [CHILD_4_fStatus]
1AF7: 10       PUSH  X             (0675)    and A, CHILD_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_4_fStatus], ~CHILD_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1AF8: 75       INC   X             (0679) .ENDSECTION
1AF9: 76 D8    INC   [216]         (0680) 
1AFB: 3C D8 0F CMP   [216],15      (0681) .SECTION
1AFE: AF F3    JZ    0x1AF2        (0682) ;-----------------------------------------------------------------------------
1B00: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_4_bCmdLength
1B02: A0 12    JZ    0x1B15        (0684) ;
1B04: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1B06: BF F1    JNZ   0x1AF8        (0686) ;     Get length of command string
                                   (0687) ;
1B08: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1B0B: 76 D8    INC   [216]         (0689) ;     none.
1B0D: 3C D8 0F CMP   [216],15      (0690) ;
1B10: B0 04    JNZ   0x1B15        (0691) ;  RETURNS:
1B12: 55 D8 0F MOV   [216],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1B15: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1B16: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1B17: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1B1A: B0 0B    JNZ   0x1B26        (0699) ;    functions.
1B1C: 20       POP   X             (0700) ;          
1B1D: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1B1F: 50 00    MOV   A,0           (0702) ;          CUR_PP
1B21: 70 3F    AND   F,63
1B23: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_4_bCmdLength:
1B25: 7F       RET                 (0705) _CHILD_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
1B26: 20       POP   X             (0708)    mov A,  [CHILD_4_bRxCnt]
1B27: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1B29: 70 3F    AND   F,63
1B2B: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1B2D: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1B2E: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1B31: 50 88    MOV   A,136         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1B33: 02 D8    ADD   A,[216]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1B35: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1B36: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_4_szGetParam, is
1B39: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_3int.asm
1B3A: 10       PUSH  X             (0104) ;;*****************************************************************************
1B3B: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_3INT.asm
1B3D: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1B3E: 58 13    MOV   X,[19]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1B40: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1B42: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1B43: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1B45: B0 04    JNZ   0x1B4A        (0115) 
1B47: 18       POP   A             (0116) include "m8c.inc"
1B48: 80 5E    JMP   0x1BA7        (0117) include "memory.inc"
                                   (0118) include "CHILD_3.inc"
                                   (0119) 
                                   (0120) 
1B4A: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1B4B: 21 E0    AND   A,224         (0124) export  _CHILD_3_ISR
1B4D: A0 12    JZ    0x1B60        (0125) 
                                   (0126) 
1B4F: 2C 12    OR    [18],A        (0127) IF (CHILD_3_RXBUF_ENABLE)
                                   (0128) export  CHILD_3_aRxBuffer
1B51: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_3_aRxBuffer
                                   (0130) export  CHILD_3_bRxCnt
1B54: 21 20    AND   A,32          (0131) export _CHILD_3_bRxCnt
1B56: A0 50    JZ    0x1BA7        (0132) export  CHILD_3_fStatus
                                   (0133) export _CHILD_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1B58: 41 2B FE AND   REG[43],254   (0136) 
1B5B: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1B5E: 80 48    JMP   0x1BA7        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_3_RXBUF_ENABLE)
1B60: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_3_fStatus:
                                   (0144) _CHILD_3_fStatus:      BLK  1
1B62: 47 12 01 TST   [18],1        (0145)  CHILD_3_bRxCnt:
1B65: B0 41    JNZ   0x1BA7        (0146) _CHILD_3_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_3_RAM(RAM,REL,CON)
1B67: 39 00    CMP   A,0           (0148)  CHILD_3_aRxBuffer:    
1B69: B0 14    JNZ   0x1B7E        (0149) _CHILD_3_aRxBuffer:    BLK CHILD_3_RX_BUFFER_SIZE
1B6B: 2E 12 01 OR    [18],1        (0150) ENDIF
                                   (0151) 
1B6E: 62 D3 00 MOV   REG[211],0    (0152) 
1B71: 70 3F    AND   F,63
1B73: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1B75: 56 38 00 MOV   [X+56],0      (0154) 
1B78: 70 3F    AND   F,63
1B7A: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1B7C: 80 2A    JMP   0x1BA7        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1B7E: 3C 13 0F CMP   [19],15       (0167) ;------------------------
1B81: C0 14    JC    0x1B96        (0168) 
1B83: 2E 12 10 OR    [18],16       (0169) 
                                   (0170) ;------------------------
1B86: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1B89: 70 3F    AND   F,63
1B8B: 71 80    OR    F,128         (0172) ;------------------------
1B8D: 56 38 00 MOV   [X+56],0      (0173) 
1B90: 70 3F    AND   F,63
1B92: 71 00    OR    F,0           (0174) 
1B94: 80 12    JMP   0x1BA7        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1B96: 75       INC   X             (0179) 
1B97: 5A 13    MOV   [19],X        (0180) 
1B99: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1B9A: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1B9D: 70 3F    AND   F,63
1B9F: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_3_ISR
1BA1: 54 38    MOV   [X+56],A      (0185) ;
1BA3: 70 3F    AND   F,63
1BA5: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1BA7: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1BA8: 60 D3    MOV   REG[211],A    (0191) _CHILD_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1BAA: 20       POP   X             (0195)    ; Insert your custom code below this banner
1BAB: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1BAD: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_3_timeout.asm
                                   (0102) ;;*****************************************************************************
1BB0: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_3_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_3_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1BB1: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1BB4: 7F       RET                 (0131) export  CHILD_3_TIMEOUT_EnableInt
                                   (0132) export _CHILD_3_TIMEOUT_EnableInt
                                   (0133) export  CHILD_3_TIMEOUT_DisableInt
                                   (0134) export _CHILD_3_TIMEOUT_DisableInt
                                   (0135) export  CHILD_3_TIMEOUT_Start
                                   (0136) export _CHILD_3_TIMEOUT_Start
                                   (0137) export  CHILD_3_TIMEOUT_Stop
                                   (0138) export _CHILD_3_TIMEOUT_Stop
                                   (0139) export  CHILD_3_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_3_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_3_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_3_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_3_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_3_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_3_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_3_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
1BB5: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1BB8: 7F       RET                 (0159) export  wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response3_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_3_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1BB9: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1BBC: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_3_TIMEOUT_EnableInt:
                                   (0200) _CHILD_3_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_3_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_3_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1BBD: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1BBF: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1BC0: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1BC2: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_3_TIMEOUT_DisableInt:
                                   (0228) _CHILD_3_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_3_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1BC3: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1BC5: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1BC6: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1BC8: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_3_TIMEOUT_Start:
                                   (0256) _CHILD_3_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_3_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1BC9: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1BCB: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1BCC: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1BCE: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_3_TIMEOUT_Stop:
                                   (0284) _CHILD_3_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_3_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_3_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_3_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_3_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_3_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_3_TIMEOUT_Stop to disable).
1BCF: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1BD0: 38 03    ADD   SP,3          (0334) ;
1BD2: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1BD4: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1BD5: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1BD7: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1BD8: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1BDA: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1BDB: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1BDD: 5D 26    MOV   A,REG[38]     (0343) ;
1BDF: 54 01    MOV   [X+1],A       (0344)  CHILD_3_TIMEOUT_WriteCompareValue:
1BE1: 5D 22    MOV   A,REG[34]     (0345) _CHILD_3_TIMEOUT_WriteCompareValue:
1BE3: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1BE5: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG], A
1BE7: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1BEA: A0 03    JZ    0x1BEE        (0349)    mov   reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG], A
1BEC: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1BEE: 54 00    MOV   [X+0],A       (0352) 
1BF0: 70 FE    AND   F,254         (0353) .ENDSECTION
1BF2: 41 23 FE AND   REG[35],254   (0354) 
1BF5: 18       POP   A             (0355) 
1BF6: 60 26    MOV   REG[38],A     (0356) .SECTION
1BF8: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1BF9: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadCompareValue
1BFB: 18       POP   A             (0359) ;
1BFC: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1BFE: 18       POP   A             (0361) ;     Reads the Compare registers.
1BFF: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1C00: 70 3F    AND   F,63
1C02: 71 C0    OR    F,192         (0363) ;
1C04: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1C05: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1C07: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1C09: 5C       MOV   X,A           (0409) ;
1C0A: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1C0D: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_3.asm
                                   (0121) ;;*****************************************************************************
1C10: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_3.inc"
1C11: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1C14: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_3_EnableInt
                                   (0155) export  _CHILD_3_EnableInt
                                   (0156) export   CHILD_3_DisableInt
                                   (0157) export  _CHILD_3_DisableInt
                                   (0158) export   CHILD_3_Start
                                   (0159) export  _CHILD_3_Start
                                   (0160) export   CHILD_3_Stop
                                   (0161) export  _CHILD_3_Stop
                                   (0162) export   CHILD_3_bReadRxData
                                   (0163) export  _CHILD_3_bReadRxData
                                   (0164) export   CHILD_3_bReadRxStatus
                                   (0165) export  _CHILD_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_3_ReadRxData
                                   (0170) export _bCHILD_3_ReadRxData
                                   (0171) export  bCHILD_3_ReadRxStatus
                                   (0172) export _bCHILD_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_3_cGetChar
1C15: 29 01    OR    A,1           (0179) export _CHILD_3_cGetChar
1C17: 60 2B    MOV   REG[43],A     (0180) export  CHILD_3_cReadChar
                                   (0181) export _CHILD_3_cReadChar
1C19: 7F       RET                 (0182) export  CHILD_3_iReadChar
                                   (0183) export _CHILD_3_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_3_RXBUF_ENABLE)
                                   (0186) export  CHILD_3_CmdReset
                                   (0187) export _CHILD_3_CmdReset
                                   (0188) export  CHILD_3_bCmdCheck
                                   (0189) export _CHILD_3_bCmdCheck
                                   (0190) export  CHILD_3_bCmdLength
                                   (0191) export _CHILD_3_bCmdLength
                                   (0192) export  CHILD_3_bErrCheck
                                   (0193) export _CHILD_3_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_3_szGetParam
                                   (0196) export _CHILD_3_szGetParam
                                   (0197) export  CHILD_3_szGetRestOfParams
                                   (0198) export _CHILD_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1C1A: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1C1D: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_3_EnableInt:
                                   (0238) _CHILD_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1C1E: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1C20: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_3_DisableInt:
                                   (0267) _CHILD_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1C21: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1C23: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_3_Start:
                                   (0297) _CHILD_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1C24: 49 2B 08 TST   REG[43],8     (0311) ;
1C27: AF FC    JZ    0x1C24        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1C29: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1C2B: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_3_Stop:
                                   (0326) _CHILD_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1C2C: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1C2E: 08       PUSH  A             (0347) ;
1C2F: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1C31: B0 04    JNZ   0x1C36        (0349) ;    The A and X registers may be modified by this or future implementations
1C33: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1C34: 80 0B    JMP   0x1C40        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1C36: 5D 2A    MOV   A,REG[42]     (0354) ;
1C38: 4B       SWAP  A,X           (0355)  CHILD_3_bReadRxData:
                                   (0356) _CHILD_3_bReadRxData:
1C39: 18       POP   A             (0357)  bCHILD_3_ReadRxData:
1C3A: 21 A0    AND   A,160         (0358) _bCHILD_3_ReadRxData:
1C3C: B0 03    JNZ   0x1C40        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1C3E: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1C3F: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1C40: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_3_bReadRxStatus
                                   (0368) ;
1C42: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_3_bReadRxStatus:
                                   (0388) _CHILD_3_bReadRxStatus:
                                   (0389)  bCHILD_3_ReadRxStatus:
                                   (0390) _bCHILD_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1C43: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1C45: 21 E8    AND   A,232         (0408) ;
1C47: 08       PUSH  A             (0409) ;  ARGUMENTS:
1C48: 21 08    AND   A,8           (0410) ;      none
1C4A: B0 07    JNZ   0x1C52        (0411) ;
1C4C: 18       POP   A             (0412) ;  RETURNS:
1C4D: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1C4F: 4B       SWAP  A,X           (0414) ;
1C50: 80 07    JMP   0x1C58        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1C52: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1C53: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1C55: 4B       SWAP  A,X           (0420) ;    functions.
1C56: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1C58: 7F       RET                 (0426)  CHILD_3_cGetChar:
                                   (0427) _CHILD_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_3_CONTROL_REG],CHILD_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_3_cReadChar:
                                   (0463) _CHILD_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
1C59: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1C5C: 55 38 00 MOV   [56],0        (0470)    pop  A
1C5F: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1C62: 55 D7 00 MOV   [CHILD+3],0   (0472) 
1C65: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1C68: 55 13 00 MOV   [19],0        (0474)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
1C6B: 26 12 00 AND   [18],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1C6E: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_3_RX_PARITY_ERROR | CHILD_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1C6F: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1C72: 51 12    MOV   A,[18]        (0511) ;        0x40CC    Overrun Error
1C74: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1C76: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_3_iReadChar:
                                   (0523) _CHILD_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_3_RX_ERROR|CHILD_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_3_RXBUF_ENABLE)
                                   (0552) .SECTION
1C77: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1C7A: 51 12    MOV   A,[18]        (0554) ;-----------------------------------------------------------------------------
1C7C: 21 F0    AND   A,240         (0555) ;
1C7E: 26 12 0F AND   [18],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1C81: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_3_CmdReset:
1C82: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_3_CmdReset:
1C85: 51 13    MOV   A,[19]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_3_aRxBuffer
1C87: 7F       RET                 (0590)    mov [CHILD_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
                                   (0594)    mov [CHILD_3_bRxCnt], 0x00
                                   (0595)    and [CHILD_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_3_bCmdCheck:
                                   (0628) _CHILD_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0631)    mov A,  [CHILD_3_fStatus]
                                   (0632)    and A, CHILD_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1C88: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1C8A: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1C8D: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1C90: 50 38    MOV   A,56          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1C92: 02 D7    ADD   A,[CHILD+3]   (0649) ;                     Returns non-zero value in A if command is valid.
1C94: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1C95: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1C97: B0 04    JNZ   0x1C9C        (0653) ;           0x10 => Software Buffer OverRun
1C99: 10       PUSH  X             (0654) ;
1C9A: 80 33    JMP   0x1CCE        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1C9C: 39 00    CMP   A,0           (0660) ;    functions.
1C9E: B0 11    JNZ   0x1CB0        (0661) ;          
1CA0: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1CA1: 76 D7    INC   [CHILD+3]     (0663) ;          CUR_PP
1CA3: 52 00    MOV   A,[X+0]       (0664) ;
1CA5: 3C D7 0F CMP   [CHILD+3],15  (0665) ;     Error Status is clear when read.
1CA8: BF F3    JNZ   0x1C9C        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1CAA: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_3_bErrCheck:
1CAB: 56 00 00 MOV   [X+0],0       (0671) _CHILD_3_bErrCheck:
1CAE: 80 1F    JMP   0x1CCE        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0674)    mov A,  [CHILD_3_fStatus]
1CB0: 10       PUSH  X             (0675)    and A, CHILD_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_3_fStatus], ~CHILD_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1CB1: 75       INC   X             (0679) .ENDSECTION
1CB2: 76 D7    INC   [CHILD+3]     (0680) 
1CB4: 3C D7 0F CMP   [CHILD+3],15  (0681) .SECTION
1CB7: AF F3    JZ    0x1CAB        (0682) ;-----------------------------------------------------------------------------
1CB9: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_3_bCmdLength
1CBB: A0 12    JZ    0x1CCE        (0684) ;
1CBD: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1CBF: BF F1    JNZ   0x1CB1        (0686) ;     Get length of command string
                                   (0687) ;
1CC1: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1CC4: 76 D7    INC   [CHILD+3]     (0689) ;     none.
1CC6: 3C D7 0F CMP   [CHILD+3],15  (0690) ;
1CC9: B0 04    JNZ   0x1CCE        (0691) ;  RETURNS:
1CCB: 55 D7 0F MOV   [CHILD+3],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1CCE: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1CCF: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1CD0: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1CD3: B0 0B    JNZ   0x1CDF        (0699) ;    functions.
1CD5: 20       POP   X             (0700) ;          
1CD6: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1CD8: 50 00    MOV   A,0           (0702) ;          CUR_PP
1CDA: 70 3F    AND   F,63
1CDC: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_3_bCmdLength:
1CDE: 7F       RET                 (0705) _CHILD_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
1CDF: 20       POP   X             (0708)    mov A,  [CHILD_3_bRxCnt]
1CE0: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1CE2: 70 3F    AND   F,63
1CE4: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1CE6: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1CE7: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1CEA: 50 38    MOV   A,56          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1CEC: 02 D7    ADD   A,[CHILD+3]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1CEE: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1CEF: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_3_szGetParam, is
1CF2: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_2int.asm
1CF3: 10       PUSH  X             (0104) ;;*****************************************************************************
1CF4: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_2INT.asm
1CF6: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1CF7: 58 15    MOV   X,[21]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1CF9: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1CFB: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1CFC: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1CFE: B0 04    JNZ   0x1D03        (0115) 
1D00: 18       POP   A             (0116) include "m8c.inc"
1D01: 80 5E    JMP   0x1D60        (0117) include "memory.inc"
                                   (0118) include "CHILD_2.inc"
                                   (0119) 
                                   (0120) 
1D03: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1D04: 21 E0    AND   A,224         (0124) export  _CHILD_2_ISR
1D06: A0 12    JZ    0x1D19        (0125) 
                                   (0126) 
1D08: 2C 14    OR    [20],A        (0127) IF (CHILD_2_RXBUF_ENABLE)
                                   (0128) export  CHILD_2_aRxBuffer
1D0A: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_2_aRxBuffer
                                   (0130) export  CHILD_2_bRxCnt
1D0D: 21 20    AND   A,32          (0131) export _CHILD_2_bRxCnt
1D0F: A0 50    JZ    0x1D60        (0132) export  CHILD_2_fStatus
                                   (0133) export _CHILD_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
1D11: 41 2B FE AND   REG[43],254   (0136) 
1D14: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1D17: 80 48    JMP   0x1D60        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_2_RXBUF_ENABLE)
1D19: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_2_fStatus:
                                   (0144) _CHILD_2_fStatus:      BLK  1
1D1B: 47 14 01 TST   [20],1        (0145)  CHILD_2_bRxCnt:
1D1E: B0 41    JNZ   0x1D60        (0146) _CHILD_2_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_2_RAM(RAM,REL,CON)
1D20: 39 00    CMP   A,0           (0148)  CHILD_2_aRxBuffer:    
1D22: B0 14    JNZ   0x1D37        (0149) _CHILD_2_aRxBuffer:    BLK CHILD_2_RX_BUFFER_SIZE
1D24: 2E 14 01 OR    [20],1        (0150) ENDIF
                                   (0151) 
1D27: 62 D3 00 MOV   REG[211],0    (0152) 
1D2A: 70 3F    AND   F,63
1D2C: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1D2E: 56 98 00 MOV   [X-104],0     (0154) 
1D31: 70 3F    AND   F,63
1D33: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1D35: 80 2A    JMP   0x1D60        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1D37: 3C 15 0F CMP   [21],15       (0167) ;------------------------
1D3A: C0 14    JC    0x1D4F        (0168) 
1D3C: 2E 14 10 OR    [20],16       (0169) 
                                   (0170) ;------------------------
1D3F: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1D42: 70 3F    AND   F,63
1D44: 71 80    OR    F,128         (0172) ;------------------------
1D46: 56 98 00 MOV   [X-104],0     (0173) 
1D49: 70 3F    AND   F,63
1D4B: 71 00    OR    F,0           (0174) 
1D4D: 80 12    JMP   0x1D60        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1D4F: 75       INC   X             (0179) 
1D50: 5A 15    MOV   [21],X        (0180) 
1D52: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1D53: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1D56: 70 3F    AND   F,63
1D58: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_2_ISR
1D5A: 54 98    MOV   [X-104],A     (0185) ;
1D5C: 70 3F    AND   F,63
1D5E: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1D60: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1D61: 60 D3    MOV   REG[211],A    (0191) _CHILD_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1D63: 20       POP   X             (0195)    ; Insert your custom code below this banner
1D64: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1D66: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_2_timeout.asm
                                   (0102) ;;*****************************************************************************
1D69: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_2_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_2_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1D6A: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1D6D: 7F       RET                 (0131) export  CHILD_2_TIMEOUT_EnableInt
                                   (0132) export _CHILD_2_TIMEOUT_EnableInt
                                   (0133) export  CHILD_2_TIMEOUT_DisableInt
                                   (0134) export _CHILD_2_TIMEOUT_DisableInt
                                   (0135) export  CHILD_2_TIMEOUT_Start
                                   (0136) export _CHILD_2_TIMEOUT_Start
                                   (0137) export  CHILD_2_TIMEOUT_Stop
                                   (0138) export _CHILD_2_TIMEOUT_Stop
                                   (0139) export  CHILD_2_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_2_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_2_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_2_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_2_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_2_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_2_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_2_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
1D6E: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1D71: 7F       RET                 (0159) export  wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response2_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_2_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1D72: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1D75: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_2_TIMEOUT_EnableInt:
                                   (0200) _CHILD_2_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_2_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_2_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1D76: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1D78: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1D79: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1D7B: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_2_TIMEOUT_DisableInt:
                                   (0228) _CHILD_2_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_2_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1D7C: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1D7E: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1D7F: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1D81: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_2_TIMEOUT_Start:
                                   (0256) _CHILD_2_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_2_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1D82: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1D84: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1D85: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1D87: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_2_TIMEOUT_Stop:
                                   (0284) _CHILD_2_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_2_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_2_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_2_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_2_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_2_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_2_TIMEOUT_Stop to disable).
1D88: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1D89: 38 03    ADD   SP,3          (0334) ;
1D8B: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1D8D: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1D8E: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1D90: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1D91: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1D93: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1D94: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1D96: 5D 26    MOV   A,REG[38]     (0343) ;
1D98: 54 01    MOV   [X+1],A       (0344)  CHILD_2_TIMEOUT_WriteCompareValue:
1D9A: 5D 22    MOV   A,REG[34]     (0345) _CHILD_2_TIMEOUT_WriteCompareValue:
1D9C: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1D9E: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG], A
1DA0: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1DA3: A0 03    JZ    0x1DA7        (0349)    mov   reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG], A
1DA5: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1DA7: 54 00    MOV   [X+0],A       (0352) 
1DA9: 70 FE    AND   F,254         (0353) .ENDSECTION
1DAB: 41 23 FE AND   REG[35],254   (0354) 
1DAE: 18       POP   A             (0355) 
1DAF: 60 26    MOV   REG[38],A     (0356) .SECTION
1DB1: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1DB2: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadCompareValue
1DB4: 18       POP   A             (0359) ;
1DB5: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1DB7: 18       POP   A             (0361) ;     Reads the Compare registers.
1DB8: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1DB9: 70 3F    AND   F,63
1DBB: 71 C0    OR    F,192         (0363) ;
1DBD: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1DBE: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1DC0: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1DC2: 5C       MOV   X,A           (0409) ;
1DC3: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1DC6: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_2.asm
                                   (0121) ;;*****************************************************************************
1DC9: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_2.inc"
1DCA: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1DCD: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_2_EnableInt
                                   (0155) export  _CHILD_2_EnableInt
                                   (0156) export   CHILD_2_DisableInt
                                   (0157) export  _CHILD_2_DisableInt
                                   (0158) export   CHILD_2_Start
                                   (0159) export  _CHILD_2_Start
                                   (0160) export   CHILD_2_Stop
                                   (0161) export  _CHILD_2_Stop
                                   (0162) export   CHILD_2_bReadRxData
                                   (0163) export  _CHILD_2_bReadRxData
                                   (0164) export   CHILD_2_bReadRxStatus
                                   (0165) export  _CHILD_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_2_ReadRxData
                                   (0170) export _bCHILD_2_ReadRxData
                                   (0171) export  bCHILD_2_ReadRxStatus
                                   (0172) export _bCHILD_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_2_cGetChar
1DCE: 29 01    OR    A,1           (0179) export _CHILD_2_cGetChar
1DD0: 60 2B    MOV   REG[43],A     (0180) export  CHILD_2_cReadChar
                                   (0181) export _CHILD_2_cReadChar
1DD2: 7F       RET                 (0182) export  CHILD_2_iReadChar
                                   (0183) export _CHILD_2_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_2_RXBUF_ENABLE)
                                   (0186) export  CHILD_2_CmdReset
                                   (0187) export _CHILD_2_CmdReset
                                   (0188) export  CHILD_2_bCmdCheck
                                   (0189) export _CHILD_2_bCmdCheck
                                   (0190) export  CHILD_2_bCmdLength
                                   (0191) export _CHILD_2_bCmdLength
                                   (0192) export  CHILD_2_bErrCheck
                                   (0193) export _CHILD_2_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_2_szGetParam
                                   (0196) export _CHILD_2_szGetParam
                                   (0197) export  CHILD_2_szGetRestOfParams
                                   (0198) export _CHILD_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1DD3: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1DD6: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_2_EnableInt:
                                   (0238) _CHILD_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1DD7: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1DD9: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_2_DisableInt:
                                   (0267) _CHILD_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1DDA: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1DDC: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_2_Start:
                                   (0297) _CHILD_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1DDD: 49 2B 08 TST   REG[43],8     (0311) ;
1DE0: AF FC    JZ    0x1DDD        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1DE2: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1DE4: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_2_Stop:
                                   (0326) _CHILD_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1DE5: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1DE7: 08       PUSH  A             (0347) ;
1DE8: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1DEA: B0 04    JNZ   0x1DEF        (0349) ;    The A and X registers may be modified by this or future implementations
1DEC: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1DED: 80 0B    JMP   0x1DF9        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1DEF: 5D 2A    MOV   A,REG[42]     (0354) ;
1DF1: 4B       SWAP  A,X           (0355)  CHILD_2_bReadRxData:
                                   (0356) _CHILD_2_bReadRxData:
1DF2: 18       POP   A             (0357)  bCHILD_2_ReadRxData:
1DF3: 21 A0    AND   A,160         (0358) _bCHILD_2_ReadRxData:
1DF5: B0 03    JNZ   0x1DF9        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1DF7: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1DF8: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1DF9: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_2_bReadRxStatus
                                   (0368) ;
1DFB: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_2_bReadRxStatus:
                                   (0388) _CHILD_2_bReadRxStatus:
                                   (0389)  bCHILD_2_ReadRxStatus:
                                   (0390) _bCHILD_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1DFC: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1DFE: 21 E8    AND   A,232         (0408) ;
1E00: 08       PUSH  A             (0409) ;  ARGUMENTS:
1E01: 21 08    AND   A,8           (0410) ;      none
1E03: B0 07    JNZ   0x1E0B        (0411) ;
1E05: 18       POP   A             (0412) ;  RETURNS:
1E06: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1E08: 4B       SWAP  A,X           (0414) ;
1E09: 80 07    JMP   0x1E11        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1E0B: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1E0C: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1E0E: 4B       SWAP  A,X           (0420) ;    functions.
1E0F: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1E11: 7F       RET                 (0426)  CHILD_2_cGetChar:
                                   (0427) _CHILD_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_2_CONTROL_REG],CHILD_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_2_cReadChar:
                                   (0463) _CHILD_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
1E12: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1E15: 55 98 00 MOV   [152],0       (0470)    pop  A
1E18: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1E1B: 55 D6 00 MOV   [CHILD+2],0   (0472) 
1E1E: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1E21: 55 15 00 MOV   [21],0        (0474)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
1E24: 26 14 00 AND   [20],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1E27: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_2_RX_PARITY_ERROR | CHILD_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1E28: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1E2B: 51 14    MOV   A,[20]        (0511) ;        0x40CC    Overrun Error
1E2D: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1E2F: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_2_iReadChar:
                                   (0523) _CHILD_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_2_RX_ERROR|CHILD_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1E30: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1E33: 51 14    MOV   A,[20]        (0554) ;-----------------------------------------------------------------------------
1E35: 21 F0    AND   A,240         (0555) ;
1E37: 26 14 0F AND   [20],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1E3A: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_2_CmdReset:
1E3B: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_2_CmdReset:
1E3E: 51 15    MOV   A,[21]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_2_aRxBuffer
1E40: 7F       RET                 (0590)    mov [CHILD_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
                                   (0594)    mov [CHILD_2_bRxCnt], 0x00
                                   (0595)    and [CHILD_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_2_bCmdCheck:
                                   (0628) _CHILD_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0631)    mov A,  [CHILD_2_fStatus]
                                   (0632)    and A, CHILD_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1E41: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1E43: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1E46: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1E49: 50 98    MOV   A,152         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1E4B: 02 D6    ADD   A,[CHILD+2]   (0649) ;                     Returns non-zero value in A if command is valid.
1E4D: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1E4E: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1E50: B0 04    JNZ   0x1E55        (0653) ;           0x10 => Software Buffer OverRun
1E52: 10       PUSH  X             (0654) ;
1E53: 80 33    JMP   0x1E87        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1E55: 39 00    CMP   A,0           (0660) ;    functions.
1E57: B0 11    JNZ   0x1E69        (0661) ;          
1E59: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1E5A: 76 D6    INC   [CHILD+2]     (0663) ;          CUR_PP
1E5C: 52 00    MOV   A,[X+0]       (0664) ;
1E5E: 3C D6 0F CMP   [CHILD+2],15  (0665) ;     Error Status is clear when read.
1E61: BF F3    JNZ   0x1E55        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1E63: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_2_bErrCheck:
1E64: 56 00 00 MOV   [X+0],0       (0671) _CHILD_2_bErrCheck:
1E67: 80 1F    JMP   0x1E87        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0674)    mov A,  [CHILD_2_fStatus]
1E69: 10       PUSH  X             (0675)    and A, CHILD_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_2_fStatus], ~CHILD_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1E6A: 75       INC   X             (0679) .ENDSECTION
1E6B: 76 D6    INC   [CHILD+2]     (0680) 
1E6D: 3C D6 0F CMP   [CHILD+2],15  (0681) .SECTION
1E70: AF F3    JZ    0x1E64        (0682) ;-----------------------------------------------------------------------------
1E72: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_2_bCmdLength
1E74: A0 12    JZ    0x1E87        (0684) ;
1E76: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1E78: BF F1    JNZ   0x1E6A        (0686) ;     Get length of command string
                                   (0687) ;
1E7A: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1E7D: 76 D6    INC   [CHILD+2]     (0689) ;     none.
1E7F: 3C D6 0F CMP   [CHILD+2],15  (0690) ;
1E82: B0 04    JNZ   0x1E87        (0691) ;  RETURNS:
1E84: 55 D6 0F MOV   [CHILD+2],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1E87: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1E88: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1E89: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1E8C: B0 0B    JNZ   0x1E98        (0699) ;    functions.
1E8E: 20       POP   X             (0700) ;          
1E8F: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1E91: 50 00    MOV   A,0           (0702) ;          CUR_PP
1E93: 70 3F    AND   F,63
1E95: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_2_bCmdLength:
1E97: 7F       RET                 (0705) _CHILD_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
1E98: 20       POP   X             (0708)    mov A,  [CHILD_2_bRxCnt]
1E99: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1E9B: 70 3F    AND   F,63
1E9D: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1E9F: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1EA0: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1EA3: 50 98    MOV   A,152         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1EA5: 02 D6    ADD   A,[CHILD+2]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1EA7: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1EA8: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_2_szGetParam, is
1EAB: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_1int.asm
1EAC: 10       PUSH  X             (0104) ;;*****************************************************************************
1EAD: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_1INT.asm
1EAF: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1EB0: 58 17    MOV   X,[23]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1EB2: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1EB4: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1EB5: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1EB7: B0 04    JNZ   0x1EBC        (0115) 
1EB9: 18       POP   A             (0116) include "m8c.inc"
1EBA: 80 5E    JMP   0x1F19        (0117) include "memory.inc"
                                   (0118) include "CHILD_1.inc"
                                   (0119) 
                                   (0120) 
1EBC: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1EBD: 21 E0    AND   A,224         (0124) export  _CHILD_1_ISR
1EBF: A0 12    JZ    0x1ED2        (0125) 
                                   (0126) 
1EC1: 2C 16    OR    [22],A        (0127) IF (CHILD_1_RXBUF_ENABLE)
                                   (0128) export  CHILD_1_aRxBuffer
1EC3: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_1_aRxBuffer
                                   (0130) export  CHILD_1_bRxCnt
1EC6: 21 20    AND   A,32          (0131) export _CHILD_1_bRxCnt
1EC8: A0 50    JZ    0x1F19        (0132) export  CHILD_1_fStatus
                                   (0133) export _CHILD_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
1ECA: 41 2B FE AND   REG[43],254   (0136) 
1ECD: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1ED0: 80 48    JMP   0x1F19        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_1_RXBUF_ENABLE)
1ED2: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_1_fStatus:
                                   (0144) _CHILD_1_fStatus:      BLK  1
1ED4: 47 16 01 TST   [22],1        (0145)  CHILD_1_bRxCnt:
1ED7: B0 41    JNZ   0x1F19        (0146) _CHILD_1_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_1_RAM(RAM,REL,CON)
1ED9: 39 00    CMP   A,0           (0148)  CHILD_1_aRxBuffer:    
1EDB: B0 14    JNZ   0x1EF0        (0149) _CHILD_1_aRxBuffer:    BLK CHILD_1_RX_BUFFER_SIZE
1EDD: 2E 16 01 OR    [22],1        (0150) ENDIF
                                   (0151) 
1EE0: 62 D3 00 MOV   REG[211],0    (0152) 
1EE3: 70 3F    AND   F,63
1EE5: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1EE7: 56 A8 00 MOV   [X-88],0      (0154) 
1EEA: 70 3F    AND   F,63
1EEC: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1EEE: 80 2A    JMP   0x1F19        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1EF0: 3C 17 0F CMP   [23],15       (0167) ;------------------------
1EF3: C0 14    JC    0x1F08        (0168) 
1EF5: 2E 16 10 OR    [22],16       (0169) 
                                   (0170) ;------------------------
1EF8: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1EFB: 70 3F    AND   F,63
1EFD: 71 80    OR    F,128         (0172) ;------------------------
1EFF: 56 A8 00 MOV   [X-88],0      (0173) 
1F02: 70 3F    AND   F,63
1F04: 71 00    OR    F,0           (0174) 
1F06: 80 12    JMP   0x1F19        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1F08: 75       INC   X             (0179) 
1F09: 5A 17    MOV   [23],X        (0180) 
1F0B: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1F0C: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1F0F: 70 3F    AND   F,63
1F11: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_1_ISR
1F13: 54 A8    MOV   [X-88],A      (0185) ;
1F15: 70 3F    AND   F,63
1F17: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1F19: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1F1A: 60 D3    MOV   REG[211],A    (0191) _CHILD_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1F1C: 20       POP   X             (0195)    ; Insert your custom code below this banner
1F1D: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1F1F: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_1_timeout.asm
                                   (0102) ;;*****************************************************************************
1F22: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_1_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_1_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1F23: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1F26: 7F       RET                 (0131) export  CHILD_1_TIMEOUT_EnableInt
                                   (0132) export _CHILD_1_TIMEOUT_EnableInt
                                   (0133) export  CHILD_1_TIMEOUT_DisableInt
                                   (0134) export _CHILD_1_TIMEOUT_DisableInt
                                   (0135) export  CHILD_1_TIMEOUT_Start
                                   (0136) export _CHILD_1_TIMEOUT_Start
                                   (0137) export  CHILD_1_TIMEOUT_Stop
                                   (0138) export _CHILD_1_TIMEOUT_Stop
                                   (0139) export  CHILD_1_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_1_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_1_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_1_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_1_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_1_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_1_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_1_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
1F27: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1F2A: 7F       RET                 (0159) export  wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response1_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_1_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1F2B: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1F2E: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_1_TIMEOUT_EnableInt:
                                   (0200) _CHILD_1_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_1_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_1_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1F2F: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1F31: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1F32: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1F34: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_1_TIMEOUT_DisableInt:
                                   (0228) _CHILD_1_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_1_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1F35: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1F37: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1F38: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1F3A: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_1_TIMEOUT_Start:
                                   (0256) _CHILD_1_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_1_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1F3B: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1F3D: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1F3E: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1F40: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_1_TIMEOUT_Stop:
                                   (0284) _CHILD_1_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_1_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_1_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_1_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_1_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_1_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_1_TIMEOUT_Stop to disable).
1F41: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1F42: 38 03    ADD   SP,3          (0334) ;
1F44: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1F46: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1F47: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1F49: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1F4A: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1F4C: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1F4D: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1F4F: 5D 26    MOV   A,REG[38]     (0343) ;
1F51: 54 01    MOV   [X+1],A       (0344)  CHILD_1_TIMEOUT_WriteCompareValue:
1F53: 5D 22    MOV   A,REG[34]     (0345) _CHILD_1_TIMEOUT_WriteCompareValue:
1F55: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1F57: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG], A
1F59: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1F5C: A0 03    JZ    0x1F60        (0349)    mov   reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG], A
1F5E: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1F60: 54 00    MOV   [X+0],A       (0352) 
1F62: 70 FE    AND   F,254         (0353) .ENDSECTION
1F64: 41 23 FE AND   REG[35],254   (0354) 
1F67: 18       POP   A             (0355) 
1F68: 60 26    MOV   REG[38],A     (0356) .SECTION
1F6A: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1F6B: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadCompareValue
1F6D: 18       POP   A             (0359) ;
1F6E: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1F70: 18       POP   A             (0361) ;     Reads the Compare registers.
1F71: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1F72: 70 3F    AND   F,63
1F74: 71 C0    OR    F,192         (0363) ;
1F76: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1F77: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1F79: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1F7B: 5C       MOV   X,A           (0409) ;
1F7C: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1F7F: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_1.asm
                                   (0121) ;;*****************************************************************************
1F82: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_1.inc"
1F83: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1F86: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_1_EnableInt
                                   (0155) export  _CHILD_1_EnableInt
                                   (0156) export   CHILD_1_DisableInt
                                   (0157) export  _CHILD_1_DisableInt
                                   (0158) export   CHILD_1_Start
                                   (0159) export  _CHILD_1_Start
                                   (0160) export   CHILD_1_Stop
                                   (0161) export  _CHILD_1_Stop
                                   (0162) export   CHILD_1_bReadRxData
                                   (0163) export  _CHILD_1_bReadRxData
                                   (0164) export   CHILD_1_bReadRxStatus
                                   (0165) export  _CHILD_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_1_ReadRxData
                                   (0170) export _bCHILD_1_ReadRxData
                                   (0171) export  bCHILD_1_ReadRxStatus
                                   (0172) export _bCHILD_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_1_cGetChar
1F87: 29 01    OR    A,1           (0179) export _CHILD_1_cGetChar
1F89: 60 2B    MOV   REG[43],A     (0180) export  CHILD_1_cReadChar
                                   (0181) export _CHILD_1_cReadChar
1F8B: 7F       RET                 (0182) export  CHILD_1_iReadChar
                                   (0183) export _CHILD_1_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_1_RXBUF_ENABLE)
                                   (0186) export  CHILD_1_CmdReset
                                   (0187) export _CHILD_1_CmdReset
                                   (0188) export  CHILD_1_bCmdCheck
                                   (0189) export _CHILD_1_bCmdCheck
                                   (0190) export  CHILD_1_bCmdLength
                                   (0191) export _CHILD_1_bCmdLength
                                   (0192) export  CHILD_1_bErrCheck
                                   (0193) export _CHILD_1_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_1_szGetParam
                                   (0196) export _CHILD_1_szGetParam
                                   (0197) export  CHILD_1_szGetRestOfParams
                                   (0198) export _CHILD_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1F8C: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1F8F: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_1_EnableInt:
                                   (0238) _CHILD_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1F90: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1F92: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_1_DisableInt:
                                   (0267) _CHILD_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1F93: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1F95: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_1_Start:
                                   (0297) _CHILD_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1F96: 49 2B 08 TST   REG[43],8     (0311) ;
1F99: AF FC    JZ    0x1F96        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1F9B: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1F9D: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_1_Stop:
                                   (0326) _CHILD_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1F9E: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1FA0: 08       PUSH  A             (0347) ;
1FA1: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1FA3: B0 04    JNZ   0x1FA8        (0349) ;    The A and X registers may be modified by this or future implementations
1FA5: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1FA6: 80 0B    JMP   0x1FB2        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1FA8: 5D 2A    MOV   A,REG[42]     (0354) ;
1FAA: 4B       SWAP  A,X           (0355)  CHILD_1_bReadRxData:
                                   (0356) _CHILD_1_bReadRxData:
1FAB: 18       POP   A             (0357)  bCHILD_1_ReadRxData:
1FAC: 21 A0    AND   A,160         (0358) _bCHILD_1_ReadRxData:
1FAE: B0 03    JNZ   0x1FB2        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1FB0: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1FB1: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1FB2: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_1_bReadRxStatus
                                   (0368) ;
1FB4: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_1_bReadRxStatus:
                                   (0388) _CHILD_1_bReadRxStatus:
                                   (0389)  bCHILD_1_ReadRxStatus:
                                   (0390) _bCHILD_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1FB5: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1FB7: 21 E8    AND   A,232         (0408) ;
1FB9: 08       PUSH  A             (0409) ;  ARGUMENTS:
1FBA: 21 08    AND   A,8           (0410) ;      none
1FBC: B0 07    JNZ   0x1FC4        (0411) ;
1FBE: 18       POP   A             (0412) ;  RETURNS:
1FBF: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1FC1: 4B       SWAP  A,X           (0414) ;
1FC2: 80 07    JMP   0x1FCA        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1FC4: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1FC5: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1FC7: 4B       SWAP  A,X           (0420) ;    functions.
1FC8: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1FCA: 7F       RET                 (0426)  CHILD_1_cGetChar:
                                   (0427) _CHILD_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_1_CONTROL_REG],CHILD_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_1_cReadChar:
                                   (0463) _CHILD_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
1FCB: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1FCE: 55 A8 00 MOV   [168],0       (0470)    pop  A
1FD1: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1FD4: 55 D5 00 MOV   [CHILD+1],0   (0472) 
1FD7: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1FDA: 55 17 00 MOV   [23],0        (0474)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
1FDD: 26 16 00 AND   [22],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1FE0: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_1_RX_PARITY_ERROR | CHILD_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1FE1: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1FE4: 51 16    MOV   A,[22]        (0511) ;        0x40CC    Overrun Error
1FE6: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1FE8: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_1_iReadChar:
                                   (0523) _CHILD_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_1_RX_ERROR|CHILD_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_1_RXBUF_ENABLE)
                                   (0552) .SECTION
1FE9: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1FEC: 51 16    MOV   A,[22]        (0554) ;-----------------------------------------------------------------------------
1FEE: 21 F0    AND   A,240         (0555) ;
1FF0: 26 16 0F AND   [22],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1FF3: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_1_CmdReset:
1FF4: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_1_CmdReset:
1FF7: 51 17    MOV   A,[23]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_1_aRxBuffer
1FF9: 7F       RET                 (0590)    mov [CHILD_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
                                   (0594)    mov [CHILD_1_bRxCnt], 0x00
                                   (0595)    and [CHILD_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_1_bCmdCheck:
                                   (0628) _CHILD_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0631)    mov A,  [CHILD_1_fStatus]
                                   (0632)    and A, CHILD_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1FFA: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1FFC: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1FFF: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
2002: 50 A8    MOV   A,168         (0648) ;     BYTE  fStatus - Status of command receive buffer.
2004: 02 D5    ADD   A,[CHILD+1]   (0649) ;                     Returns non-zero value in A if command is valid.
2006: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
2007: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
2009: B0 04    JNZ   0x200E        (0653) ;           0x10 => Software Buffer OverRun
200B: 10       PUSH  X             (0654) ;
200C: 80 33    JMP   0x2040        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
200E: 39 00    CMP   A,0           (0660) ;    functions.
2010: B0 11    JNZ   0x2022        (0661) ;          
2012: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
2013: 76 D5    INC   [CHILD+1]     (0663) ;          CUR_PP
2015: 52 00    MOV   A,[X+0]       (0664) ;
2017: 3C D5 0F CMP   [CHILD+1],15  (0665) ;     Error Status is clear when read.
201A: BF F3    JNZ   0x200E        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
201C: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_1_bErrCheck:
201D: 56 00 00 MOV   [X+0],0       (0671) _CHILD_1_bErrCheck:
2020: 80 1F    JMP   0x2040        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0674)    mov A,  [CHILD_1_fStatus]
2022: 10       PUSH  X             (0675)    and A, CHILD_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_1_fStatus], ~CHILD_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
2023: 75       INC   X             (0679) .ENDSECTION
2024: 76 D5    INC   [CHILD+1]     (0680) 
2026: 3C D5 0F CMP   [CHILD+1],15  (0681) .SECTION
2029: AF F3    JZ    0x201D        (0682) ;-----------------------------------------------------------------------------
202B: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_1_bCmdLength
202D: A0 12    JZ    0x2040        (0684) ;
202F: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
2031: BF F1    JNZ   0x2023        (0686) ;     Get length of command string
                                   (0687) ;
2033: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
2036: 76 D5    INC   [CHILD+1]     (0689) ;     none.
2038: 3C D5 0F CMP   [CHILD+1],15  (0690) ;
203B: B0 04    JNZ   0x2040        (0691) ;  RETURNS:
203D: 55 D5 0F MOV   [CHILD+1],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
2040: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
2041: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
2042: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
2045: B0 0B    JNZ   0x2051        (0699) ;    functions.
2047: 20       POP   X             (0700) ;          
2048: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
204A: 50 00    MOV   A,0           (0702) ;          CUR_PP
204C: 70 3F    AND   F,63
204E: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_1_bCmdLength:
2050: 7F       RET                 (0705) _CHILD_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
2051: 20       POP   X             (0708)    mov A,  [CHILD_1_bRxCnt]
2052: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
2054: 70 3F    AND   F,63
2056: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
2058: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
2059: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
205C: 50 A8    MOV   A,168         (0744) ;     each lexically distinct element into a null-terminated string by replacing
205E: 02 D5    ADD   A,[CHILD+1]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
2060: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
2061: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_1_szGetParam, is
_main:
__text_start:
2064: 62 D0 00 MOV   REG[208],0    (0750) ;     not called until the buffer has been loaded with an entire command
2067: 55 D4 00 MOV   [CHILD],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
(0163) // Author: Jason Tennyson
206A: 62 D0 00 MOV   REG[208],0
206D: 55 CF 00 MOV   [CONFIGURED+1],0
2070: 55 CE 00 MOV   [CONFIGURED],0
(0164) // Date: 3-18-11
2073: 62 D0 00 MOV   REG[208],0
2076: 55 D3 00 MOV   [TIMEOUT+1],0
2079: 55 D2 00 MOV   [TIMEOUT],0
(0165) // File: main.c
207C: 62 D0 00 MOV   REG[208],0
207F: 55 E1 00 MOV   [COMMAND_PARAM],0
(0166) //
2082: 62 D0 00 MOV   REG[208],0
2085: 55 D1 00 MOV   [STATE+1],0
2088: 55 D0 00 MOV   [STATE],0
(0167) // This is the design for the revolute modules for Jason Tennyson's Thesis.
208B: 62 D0 00 MOV   REG[208],0
208E: 55 E5 FB MOV   [ID],251
(0168) // This design is made for a PSoC CY8C28433-24PVXI.
(0169) //
2091: 71 01    OR    F,1
(0170) // Controller Packet Structure (each field is a byte)
(0171) // -----------------------------------------------------
2093: 43 E0 20 OR    REG[224],32
(0172) // All Packets:
(0173) // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0174) //
2096: 7C 30 16 LCALL _servoBootWait
(0175) // Servo Packet Structure (each field is a byte)
(0176) // -----------------------------------------------------
(0177) // Source Packets:
2099: 7C 2D 54 LCALL _servoFinder
209C: 80 12    JMP   0x20AF
(0178) // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
(0179) //
(0180) // Return Packets:
(0181) // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
(0182) 
209E: 92 82    CALL  _commandReady
20A0: 62 D0 00 MOV   REG[208],0
20A3: 3C CD 00 CMP   [__r0],0
20A6: B0 06    JNZ   0x20AD
20A8: 3C CC 00 CMP   [__r1],0
20AB: A0 03    JZ    0x20AF
(0183) #include <m8c.h>        	// Part-specific constants and macros.
(0184) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
(0185) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
20AD: 97 AE    CALL  _takeAction
20AF: 8F EE    JMP   0x209E
20B1: 8F FF    JMP   0x20B1
(0186) 
(0187) // These are declarations of all of the timer interrupts that are used for all configurations.
(0188) #pragma interrupt_handler TX_01234_TIMEOUT_ISR
(0189) #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
(0190) #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
(0191) #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
(0192) #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
(0193) #pragma interrupt_handler HELLO_TIMEOUT_ISR
_sayHello:
20B3: 50 00    MOV   A,0
20B5: 08       PUSH  A
20B6: 50 02    MOV   A,2
20B8: 08       PUSH  A
20B9: 90 5D    CALL  _configToggle
20BB: 38 FE    ADD   SP,254
(0194) #pragma interrupt_handler INIT_TIMEOUT_ISR
(0195) 
(0196) // These defines are used as parameters of the configToggle function. Passing one of
20BD: 10       PUSH  X
20BE: 50 FC    MOV   A,252
20C0: 7C 0E EC LCALL 0x0EEC
20C3: 20       POP   X
(0197) // these identifiers to configToggle will put the chip in that device configuration.
20C4: 10       PUSH  X
20C5: 50 FC    MOV   A,252
20C7: 7C 0E EC LCALL 0x0EEC
20CA: 20       POP   X
(0198) #define		WAIT						(1)
20CB: 10       PUSH  X
20CC: 62 D0 00 MOV   REG[208],0
20CF: 51 E5    MOV   A,[ID]
20D1: 7C 0E EC LCALL 0x0EEC
20D4: 20       POP   X
(0199) #define		MY_RESPONSE					(2)
20D5: 10       PUSH  X
20D6: 50 00    MOV   A,0
20D8: 7C 0E EC LCALL 0x0EEC
20DB: 20       POP   X
(0200) #define 	RESPONSE_1					(3)
20DC: 10       PUSH  X
20DD: 50 C8    MOV   A,200
20DF: 7C 0E EC LCALL 0x0EEC
20E2: 20       POP   X
(0201) #define 	RESPONSE_2					(4)
20E3: 10       PUSH  X
20E4: 62 D0 00 MOV   REG[208],0
20E7: 51 D4    MOV   A,[CHILD]
20E9: 7C 0E EC LCALL 0x0EEC
20EC: 20       POP   X
(0202) #define 	RESPONSE_3					(5)
20ED: 10       PUSH  X
20EE: 50 FD    MOV   A,253
20F0: 7C 0E EC LCALL 0x0EEC
20F3: 20       POP   X
(0203) #define 	RESPONSE_4					(6)
20F4: 10       PUSH  X
20F5: 50 FD    MOV   A,253
20F7: 7C 0E EC LCALL 0x0EEC
20FA: 20       POP   X
(0204) #define		HELLO_MODE					(7)
(0205) #define		INITIALIZE					(8)
(0206) #define		SERVO_COMM					(9)
20FB: 10       PUSH  X
20FC: 7C 0E BF LCALL 0x0EBF
20FF: 62 D0 00 MOV   REG[208],0
2102: 20       POP   X
2103: 53 CD    MOV   [__r0],A
2105: 47 CD 20 TST   [__r0],32
2108: AF F2    JZ    0x20FB
(0207) 
(0208) // These defines are used as comparisons to find what port the next module connected to.
(0209) #define		PORT_1						('1')
210A: 7C 2F F7 LCALL _xmitWait
(0210) #define		PORT_2						('2')
(0211) #define		PORT_3						('3')
210D: 50 00    MOV   A,0
210F: 08       PUSH  A
2110: 50 01    MOV   A,1
2112: 08       PUSH  A
2113: 90 03    CALL  _configToggle
2115: 38 FE    ADD   SP,254
2117: 7F       RET   
(0212) #define		PORT_4						('4')
(0213) 
(0214) // Module Type
(0215) #define		TYPE						(1)
(0216) 
(0217) // These defines are used as transmission indicators for transmissions between PSoC controllers.
_configToggle:
  mode                 --> X-5
2118: 10       PUSH  X
2119: 4F       MOV   X,SP
(0218) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0219) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0220) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
211A: 43 00 1F OR    REG[0],31
(0221) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
211D: 41 02 E0 AND   REG[2],224
(0222) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is complete.
(0223) #define		PING						(203)	// Indicates a ping message to or from the master.
(0224) #define		CLEAR_CONFIG				(204)	// Indicates that the master is asking for a config clear.
(0225) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
2120: 62 D0 00 MOV   REG[208],0
2123: 3C D0 00 CMP   [STATE],0
2126: B0 06    JNZ   0x212D
2128: 3C D1 00 CMP   [STATE+1],0
212B: A0 11    JZ    0x213D
(0226) #define		MASTER_ID					(0)		// The master node's ID.
(0227) #define		DEFAULT_ID					(251)	// The ID that all modules start with.
212D: 62 D0 00 MOV   REG[208],0
2130: 51 D0    MOV   A,[STATE]
2132: 08       PUSH  A
2133: 51 D1    MOV   A,[STATE+1]
2135: 08       PUSH  A
2136: 7C 2A EC LCALL _unloadConfig
2139: 38 FE    ADD   SP,254
(0228) #define		BROADCAST					(254)	// The broadcast ID for all controllers and servos.
213B: 80 04    JMP   0x2140
(0229) 
(0230) // SERVO DEFINES
(0231) // These numbers can all be found in the AX-12+ datasheet.
213D: 7C 2A D0 LCALL _unloadAllConfigs
(0232) // These defines cover the range of IDs these servos are capable of.
(0233) #define		SERVO_ID_MIN				(0)		// This is the lowest servo ID possible.
(0234) #define		SERVO_ID_MAX				(253)	// This is the highest servo ID possible.
(0235) // These defines are servo transmission indicators.
(0236) #define		SERVO_START					(255)	// This is the start byte for a servo transmission.
2140: 3D FB 00 CMP   [X-5],0
2143: B0 22    JNZ   0x2166
2145: 3D FC 01 CMP   [X-4],1
2148: B0 1D    JNZ   0x2166
(0237) // These defines are used to fill in the length parameter for a given command type. These are the only
(0238) // lengths used by this controller for servo configuration purposes. It is worth noting that any type
(0239) // and length of command can be issued from the master after configuration is complete.
(0240) #define		READ_LENGTH					(4)		// This is the length value for all reads.
214A: 7C 06 66 LCALL 0x0666
(0241) #define		WRITE_LENGTH				(4)		// This is the length value for all writes.
(0242) #define		PING_LENGTH					(2)		// This is the length value for a ping.
(0243) #define		RESET_LENGTH				(2)		// This is the length value for a reset.
214D: 10       PUSH  X
214E: 50 00    MOV   A,0
2150: 7C 0C E2 LCALL 0x0CE2
2153: 20       POP   X
(0244) // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
2154: 10       PUSH  X
2155: 50 00    MOV   A,0
2157: 7C 11 26 LCALL 0x1126
215A: 20       POP   X
(0245) #define		ID_ADDRESS					(3)		// This is the address where servo ID is stored.
(0246) #define		STATUS_RET_ADDRESS			(16)	// This is where the status return level is stored.
(0247) // These defines are used to fill in the instruction we are using on the servo.
215B: 62 D0 00 MOV   REG[208],0
215E: 55 D1 01 MOV   [STATE+1],1
2161: 55 D0 00 MOV   [STATE],0
(0248) #define		PING_SERVO					(1)		// This is the instruction number for ping.
2164: 81 A0    JMP   0x2305
(0249) #define		READ_SERVO					(2)		// This is the instruction number for a read.
2166: 3D FB 00 CMP   [X-5],0
2169: B0 4C    JNZ   0x21B6
216B: 3D FC 02 CMP   [X-4],2
216E: B0 47    JNZ   0x21B6
(0250) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0251) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
(0252) // These defines cover all of the status return level possibilities.
2170: 7C 08 28 LCALL 0x0828
(0253) #define		STATUS_RET_NEVER			(0)		// Only respond to ping commands.
(0254) #define		STATUS_RET_READ				(1)		// Only respond to read data commands (recommended).
(0255) #define		STATUS_RET_ALL				(2)		// Respond to every command.
2173: 62 D0 00 MOV   REG[208],0
2176: 55 D3 00 MOV   [TIMEOUT+1],0
2179: 55 D2 00 MOV   [TIMEOUT],0
(0256) 
(0257) // This is the status return level, which is set to one of the possible status return values above.
(0258) // We want the status return level to be return on read commands only so that we don't have garbage
217C: 10       PUSH  X
217D: 50 00    MOV   A,0
217F: 7C 0E B3 LCALL 0x0EB3
2182: 20       POP   X
(0259) // return packets flying around every time we tell the servo to move.
2183: 10       PUSH  X
2184: 50 00    MOV   A,0
2186: 7C 0D DA LCALL 0x0DDA
(0260) #define		STATUS_RET_LEVEL			(STATUS_RET_READ)
(0261) 
2189: 7C 0F 71 LCALL 0x0F71
(0262) // This is the number of attempts we make to contact the servo per sweep of attempts before
218C: 7C 0F 79 LCALL 0x0F79
218F: 20       POP   X
(0263) // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
(0264) #define		SERVO_COMM_ATTEMPTS			(10)
(0265) // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
(0266) // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
2190: 62 D0 00 MOV   REG[208],0
2193: 3C D2 00 CMP   [TIMEOUT],0
2196: B0 06    JNZ   0x219D
2198: 3C D3 00 CMP   [TIMEOUT+1],0
219B: AF F4    JZ    0x2190
(0267) // If we don't then do at least one more loop, the EEPROM write was done for no reason.
(0268) #define		SERVO_COMM_LOOPS			(2)
219D: 10       PUSH  X
219E: 7C 0F 7D LCALL 0x0F7D
21A1: 20       POP   X
(0269) // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
21A2: 62 D0 00 MOV   REG[208],0
21A5: 55 D3 00 MOV   [TIMEOUT+1],0
21A8: 55 D2 00 MOV   [TIMEOUT],0
(0270) #define		SERVO_BOOT_TIMEOUTS			(75)
(0271) 
(0272) // This function receives a mode identifier as a parameter and toggles the system configuration.
21AB: 62 D0 00 MOV   REG[208],0
21AE: 55 D1 02 MOV   [STATE+1],2
21B1: 55 D0 00 MOV   [STATE],0
(0273) void configToggle(int mode);
21B4: 81 50    JMP   0x2305
(0274) // This function unloads all configurations. This should only be needed at startup.
21B6: 3D FB 00 CMP   [X-5],0
21B9: B0 2A    JNZ   0x21E4
21BB: 3D FC 03 CMP   [X-4],3
21BE: B0 25    JNZ   0x21E4
(0275) void unloadAllConfigs(void);
(0276) // This function unloads the configuration corresponding to the number passed to it.
(0277) void unloadConfig(int config_num);
21C0: 7C 08 98 LCALL 0x0898
(0278) // This function is a response to the master sending out a hello message.
(0279) void sayHello(void);
(0280) // This function looks for commands and returns 1 if a command has been read, 0 if not.
21C3: 62 D0 00 MOV   REG[208],0
21C6: 55 D3 00 MOV   [TIMEOUT+1],0
21C9: 55 D2 00 MOV   [TIMEOUT],0
(0281) int commandReady(void);
(0282) // This function interprets the command that has just been read and performs an action accordingly.
(0283) void takeAction(void);
21CC: 10       PUSH  X
21CD: 50 00    MOV   A,0
21CF: 7C 1F 87 LCALL 0x1F87
(0284) // This function responds to a ping.
(0285) void pingResponse(void);
21D2: 7C 1F 1F LCALL 0x1F1F
(0286) // This function tells the master node that an ID assignment was completed on this module.
21D5: 7C 1F 27 LCALL 0x1F27
21D8: 20       POP   X
(0287) void assignedID(void);
(0288) // This function listens for children and registers the port that they talk to.
(0289) int childListen(void);
21D9: 62 D0 00 MOV   REG[208],0
21DC: 55 D1 03 MOV   [STATE+1],3
21DF: 55 D0 00 MOV   [STATE],0
(0290) // This function waits for a known child's response to a command to that child from the master.
21E2: 81 22    JMP   0x2305
(0291) int childResponse(void);
21E4: 3D FB 00 CMP   [X-5],0
21E7: B0 2A    JNZ   0x2212
21E9: 3D FC 04 CMP   [X-4],4
21EC: B0 25    JNZ   0x2212
(0292) // This function does everything it can to find the servo attached to this controller.
(0293) void servoFinder(void);
(0294) // This function carries out the passed servo instruction.
21EE: 7C 09 44 LCALL 0x0944
(0295) void servoInstruction(char id, char length, char instruction, char address, char value);
(0296) // This function does a simple for loop to stall and make doubly sure that the transmission finished.
(0297) // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
21F1: 62 D0 00 MOV   REG[208],0
21F4: 55 D3 00 MOV   [TIMEOUT+1],0
21F7: 55 D2 00 MOV   [TIMEOUT],0
(0298) void xmitWait(void);
(0299) // This function is called to do nothing while we wait for the servo to boot up.
(0300) void servoBootWait(void);
21FA: 10       PUSH  X
21FB: 50 00    MOV   A,0
21FD: 7C 1D CE LCALL 0x1DCE
(0301) // This function is used to wait for other controllers to find their servos while not
(0302) // driving any pins (which would keep a child from talking to its servo).
2200: 7C 1D 66 LCALL 0x1D66
(0303) void servoConfigWait(void);
2203: 7C 1D 6E LCALL 0x1D6E
2206: 20       POP   X
(0304) 
(0305) char CHILD;		// Keeps track of where the child is connected.
(0306) char ID;		// Stores the ID that the master gives this module.
2207: 62 D0 00 MOV   REG[208],0
220A: 55 D1 04 MOV   [STATE+1],4
220D: 55 D0 00 MOV   [STATE],0
(0307) 
2210: 80 F4    JMP   0x2305
(0308) int CONFIGURED;	// Keeps track of whether or not this module has been configured by the master.
2212: 3D FB 00 CMP   [X-5],0
2215: B0 2A    JNZ   0x2240
2217: 3D FC 05 CMP   [X-4],5
221A: B0 25    JNZ   0x2240
(0309) int TIMEOUT;	// This flag is set if a timeout occurs.
(0310) int STATE;		// This stores the ID of the currently-loaded configuration.
(0311) 
221C: 7C 09 F0 LCALL 0x09F0
(0312) char COMMAND_SOURCE;		// Stores who the current command is from.
(0313) char COMMAND_DESTINATION;	// Stores who the current command is for.
(0314) char COMMAND_TYPE;			// Stores the type of command that was just read.
221F: 62 D0 00 MOV   REG[208],0
2222: 55 D3 00 MOV   [TIMEOUT+1],0
2225: 55 D2 00 MOV   [TIMEOUT],0
(0315) char COMMAND_PARAM;			// Stores a parameter that accompanies the command (if any).
(0316) char COMMAND_LENGTH;		// Stores the length parameter of a servo command.
(0317) char COMMAND_ERROR;			// Stores the error code of a servo command.
2228: 10       PUSH  X
2229: 50 00    MOV   A,0
222B: 7C 1C 15 LCALL 0x1C15
(0318) 
(0319) char SERVO_ID;				// Stores the ID of the servo inside of this module.
222E: 7C 1B AD LCALL 0x1BAD
(0320) 
2231: 7C 1B B5 LCALL 0x1BB5
2234: 20       POP   X
(0321) void main(void)
(0322) {	
(0323) 	// Initial value assignment for variables of importance.
2235: 62 D0 00 MOV   REG[208],0
2238: 55 D1 05 MOV   [STATE+1],5
223B: 55 D0 00 MOV   [STATE],0
(0324) 	CHILD = 0;				// There is no child yet.
223E: 80 C6    JMP   0x2305
(0325) 	CONFIGURED = 0;			// This module is not configured yet.
2240: 3D FB 00 CMP   [X-5],0
2243: B0 2A    JNZ   0x226E
2245: 3D FC 06 CMP   [X-4],6
2248: B0 25    JNZ   0x226E
(0326) 	TIMEOUT = 0;			// Set the timeout flag low to start.
(0327) 	COMMAND_PARAM = 0;		// There is no parameter yet.
(0328) 	STATE = 0;				// There is no state yet.
224A: 7C 0A 9C LCALL 0x0A9C
(0329) 	ID = DEFAULT_ID;		// Set the ID of this controller to the default to start with.
(0330) 
(0331) 	M8C_EnableGInt;			// Turn on global interrupts for the transmission timeout timer.
224D: 62 D0 00 MOV   REG[208],0
2250: 55 D3 00 MOV   [TIMEOUT+1],0
2253: 55 D2 00 MOV   [TIMEOUT],0
(0332) 	
(0333) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
(0334) 	
2256: 10       PUSH  X
2257: 50 00    MOV   A,0
2259: 7C 1A 5C LCALL 0x1A5C
(0335) 	// We have to wait for the servo to power up and get ready for communications.
(0336) 	servoBootWait();
225C: 7C 19 F4 LCALL 0x19F4
(0337) 	
225F: 7C 19 FC LCALL 0x19FC
2262: 20       POP   X
(0338) 	// Find the servo that is inside of this module.
(0339) 	servoFinder();
(0340) 	
2263: 62 D0 00 MOV   REG[208],0
2266: 55 D1 06 MOV   [STATE+1],6
2269: 55 D0 00 MOV   [STATE],0
(0341) 	// Loop and wait for commands.
226C: 80 98    JMP   0x2305
(0342) 	while(1)
226E: 3D FB 00 CMP   [X-5],0
2271: B0 3F    JNZ   0x22B1
2273: 3D FC 07 CMP   [X-4],7
2276: B0 3A    JNZ   0x22B1
(0343) 	{	
(0344) 		if(commandReady())
(0345) 		{
2278: 7C 06 CD LCALL 0x06CD
(0346) 			// If the command is ready, take action.
(0347) 			takeAction();
(0348) 		}
227B: 62 D0 00 MOV   REG[208],0
227E: 55 D3 00 MOV   [TIMEOUT+1],0
2281: 55 D2 00 MOV   [TIMEOUT],0
(0349) 	}
(0350) }
(0351) 
(0352) // This function transmits a response to a hello command from the master.
(0353) void sayHello(void)
(0354) {	
2284: 10       PUSH  X
2285: 50 00    MOV   A,0
2287: 7C 18 A3 LCALL 0x18A3
228A: 20       POP   X
(0355) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(0356) 	
(0357) 	// Transmit a hello response to the master node.
(0358) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(0359) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
228B: 10       PUSH  X
228C: 50 00    MOV   A,0
228E: 7C 17 4A LCALL 0x174A
2291: 20       POP   X
(0360) 	TX_014_PutChar(ID);				// My ID (source)
(0361) 	TX_014_PutChar(MASTER_ID);		// Master ID (destination)
(0362) 	TX_014_PutChar(HELLO_BYTE);		// This is a hello command.
(0363) 	TX_014_PutChar(CHILD);			// Sends child port value, default 0.
(0364) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
2292: 10       PUSH  X
2293: 50 00    MOV   A,0
2295: 7C 15 F1 LCALL 0x15F1
2298: 20       POP   X
(0365) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
(0366) 	
(0367) 	// Wait for the transmission to finish.
(0368) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(0369) 	
2299: 10       PUSH  X
229A: 50 00    MOV   A,0
229C: 7C 14 98 LCALL 0x1498
(0370) 	// Make completely sure we're done.
(0371) 	xmitWait();
(0372) 
229F: 7C 13 BC LCALL 0x13BC
(0373) 	configToggle(WAIT);				// Switch back to wait mode.
22A2: 7C 13 C4 LCALL 0x13C4
22A5: 20       POP   X
(0374) }
(0375) 
(0376) // This function receives a mode flag and switches the microcontroller to the
22A6: 62 D0 00 MOV   REG[208],0
22A9: 55 D1 07 MOV   [STATE+1],7
22AC: 55 D0 00 MOV   [STATE],0
(0377) // desired hardware configuration.
22AF: 80 55    JMP   0x2305
(0378) void configToggle(int mode)
22B1: 3D FB 00 CMP   [X-5],0
22B4: B0 2A    JNZ   0x22DF
22B6: 3D FC 08 CMP   [X-4],8
22B9: B0 25    JNZ   0x22DF
(0379) {	
(0380) 	// Set the pins high and disconnect from the global bus.
(0381) 	// This helps keep false start bits from happening while we swap configs.
22BB: 7C 07 73 LCALL 0x0773
(0382) 	PRT0DR |= 0b00011111;	// Set pins P00 through P04 high.
(0383) 	PRT0GS &= 0b11100000;	// Disconnect pins P00 through P04 from the global bus.
(0384) 	
22BE: 62 D0 00 MOV   REG[208],0
22C1: 55 D3 00 MOV   [TIMEOUT+1],0
22C4: 55 D2 00 MOV   [TIMEOUT],0
(0385) 	// Unload the configuration of the current state.
(0386) 	// If there is no state, blindly wipe all configurations.
(0387) 	if(STATE)
22C7: 10       PUSH  X
22C8: 50 00    MOV   A,0
22CA: 7C 12 DF LCALL 0x12DF
(0388) 	{
(0389) 		unloadConfig(STATE);
22CD: 7C 12 03 LCALL 0x1203
(0390) 	}
22D0: 7C 12 0B LCALL 0x120B
22D3: 20       POP   X
(0391) 	else
(0392) 	{
(0393) 		unloadAllConfigs();
22D4: 62 D0 00 MOV   REG[208],0
22D7: 55 D1 08 MOV   [STATE+1],8
22DA: 55 D0 00 MOV   [STATE],0
(0394) 	}
22DD: 80 27    JMP   0x2305
(0395) 	
22DF: 3D FB 00 CMP   [X-5],0
22E2: B0 22    JNZ   0x2305
22E4: 3D FC 09 CMP   [X-4],9
22E7: B0 1D    JNZ   0x2305
(0396) 	// Go through the list of possible modes until we find the one that was passed in to us.
(0397) 	// Then, load that configuration and initialize whatever needs to be initialized.
(0398) 	if(mode == WAIT)
22E9: 7C 0B 51 LCALL 0x0B51
(0399) 	{
(0400) 		// Load the wait receiver configuration. This is the receiver configuration used after
(0401) 		// initialization is complete. It listens and forwards everything it hears.
22EC: 62 D0 00 MOV   REG[208],0
22EF: 55 D3 00 MOV   [TIMEOUT+1],0
22F2: 55 D2 00 MOV   [TIMEOUT],0
(0402) 		LoadConfig_waiting();
(0403) 		
(0404) 		// Start the receivers.
22F5: 10       PUSH  X
22F6: 50 00    MOV   A,0
22F8: 7C 0F EC LCALL 0x0FEC
22FB: 20       POP   X
(0405) 		WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
(0406) 		RX8_2_Start(RX8_2_PARITY_NONE);
(0407) 		
22FC: 62 D0 00 MOV   REG[208],0
22FF: 55 D1 09 MOV   [STATE+1],9
2302: 55 D0 00 MOV   [STATE],0
(0408) 		// Set the current state.
(0409) 		STATE = WAIT;
(0410) 	}
(0411) 	else if(mode == MY_RESPONSE)
2305: 62 D0 00 MOV   REG[208],0
2308: 3C CE 00 CMP   [CONFIGURED],0
230B: B0 06    JNZ   0x2312
230D: 3C CF 00 CMP   [CONFIGURED+1],0
2310: A0 09    JZ    0x231A
(0412) 	{
(0413) 		// Load the transmitter configuration. This is for transmitting messages on all ports.
2312: 43 02 1F OR    REG[2],31
(0414) 		LoadConfig_my_response();
2315: 41 08 FE AND   REG[8],254
(0415) 		
2318: 80 07    JMP   0x2320
(0416) 		// Clear the timeout flag.
(0417) 		TIMEOUT = 0;
(0418) 		
231A: 43 02 01 OR    REG[2],1
(0419) 		// Start the transmitters.
231D: 43 08 01 OR    REG[8],1
(0420) 		TX_014_Start(TX_014_PARITY_NONE);	// Transmits on P00, P01, and P04.
2320: 20       POP   X
2321: 7F       RET   
(0421) 		TX_23_Start(TX_23_PARITY_NONE);		// Transmits on P02 and P03.
(0422) 		
(0423) 		TX_01234_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0424) 		TX_01234_TIMEOUT_Start();			// Start the timer.
(0425) 		
(0426) 		// Do nothing while we wait for one timeout period (1 ms).
(0427) 		// This is to allow everyone to get in the right configuration before talking.
_commandReady:
  runningTotal         --> X+3
  i                    --> X+1
  tempByte             --> X+0
2322: 10       PUSH  X
2323: 4F       MOV   X,SP
2324: 38 05    ADD   SP,5
(0428) 		while(!TIMEOUT) { }
2326: 56 02 00 MOV   [X+2],0
2329: 56 01 00 MOV   [X+1],0
(0429) 		
232C: 56 00 00 MOV   [X+0],0
(0430) 		TX_01234_TIMEOUT_Stop();			// Stop the timer.
(0431) 		TIMEOUT = 0;						// Reset the timeout flag.
232F: 56 04 00 MOV   [X+4],0
2332: 56 03 00 MOV   [X+3],0
(0432) 	
(0433) 		// Set the current state.
(0434) 		STATE = MY_RESPONSE;
(0435) 	}
2335: 62 D0 00 MOV   REG[208],0
2338: 3C D0 00 CMP   [STATE],0
233B: B0 D4    JNZ   0x2410
233D: 3C D1 01 CMP   [STATE+1],1
2340: B0 CF    JNZ   0x2410
(0436) 	else if(mode == RESPONSE_1)
(0437) 	{
(0438) 		// Load the response wait on port 1.
(0439) 		LoadConfig_response1();
2342: 10       PUSH  X
2343: 7C 0C F1 LCALL 0x0CF1
2346: 62 D0 00 MOV   REG[208],0
2349: 20       POP   X
234A: 54 00    MOV   [X+0],A
(0440) 		
(0441) 		// Clear the timeout flag.
(0442) 		TIMEOUT = 0;
234C: 3D 00 FC CMP   [X+0],252
234F: B0 47    JNZ   0x2397
(0443) 		
2351: 80 0B    JMP   0x235D
(0444) 		// Start listening for a response through child port 1.
(0445) 		CHILD_1_Start(CHILD_1_PARITY_NONE);
(0446) 		
(0447) 		CHILD_1_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
2353: 10       PUSH  X
2354: 7C 0C F1 LCALL 0x0CF1
2357: 62 D0 00 MOV   REG[208],0
235A: 20       POP   X
235B: 54 00    MOV   [X+0],A
235D: 3D 00 FC CMP   [X+0],252
2360: AF F2    JZ    0x2353
(0448) 		CHILD_1_TIMEOUT_Start();			// Start the timer.
(0449) 		
(0450) 		// Set the current state.
(0451) 		STATE = RESPONSE_1;
2362: 3D 00 00 CMP   [X+0],0
2365: B4 EA    JNZ   0x2850
(0452) 	}
(0453) 	else if(mode == RESPONSE_2)
2367: 52 00    MOV   A,[X+0]
2369: 62 D0 00 MOV   REG[208],0
236C: 53 E4    MOV   [COMMAND_SOURCE],A
(0454) 	{
236E: 10       PUSH  X
236F: 7C 0C F1 LCALL 0x0CF1
2372: 20       POP   X
2373: 62 D0 00 MOV   REG[208],0
2376: 53 E3    MOV   [COMMAND_DESTINATION],A
(0455) 		// Load the response wait on port 2.
2378: 10       PUSH  X
2379: 7C 0C F1 LCALL 0x0CF1
237C: 20       POP   X
237D: 62 D0 00 MOV   REG[208],0
2380: 53 E2    MOV   [COMMAND_TYPE],A
(0456) 		LoadConfig_response2();
2382: 10       PUSH  X
2383: 7C 0C F1 LCALL 0x0CF1
2386: 20       POP   X
2387: 62 D0 00 MOV   REG[208],0
238A: 53 E1    MOV   [COMMAND_PARAM],A
(0457) 		
(0458) 		// Clear the timeout flag.
238C: 62 D0 00 MOV   REG[208],0
238F: 55 CC 01 MOV   [__r1],1
2392: 55 CD 00 MOV   [__r0],0
2395: 84 C3    JMP   0x2859
(0459) 		TIMEOUT = 0;
(0460) 		
(0461) 		// Start listening for a response through child port 2.
2397: 3D 00 FF CMP   [X+0],255
239A: B4 B5    JNZ   0x2850
(0462) 		CHILD_2_Start(CHILD_2_PARITY_NONE);
239C: 80 0B    JMP   0x23A8
(0463) 		
(0464) 		CHILD_2_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0465) 		CHILD_2_TIMEOUT_Start();			// Start the timer.
(0466) 		
239E: 10       PUSH  X
239F: 7C 0C F1 LCALL 0x0CF1
23A2: 62 D0 00 MOV   REG[208],0
23A5: 20       POP   X
23A6: 54 00    MOV   [X+0],A
23A8: 3D 00 FF CMP   [X+0],255
23AB: AF F2    JZ    0x239E
(0467) 		// Set the current state.
(0468) 		STATE = RESPONSE_2;
(0469) 	}
(0470) 	else if(mode == RESPONSE_3)
23AD: 62 D0 00 MOV   REG[208],0
23B0: 55 E4 00 MOV   [COMMAND_SOURCE],0
(0471) 	{
(0472) 		// Load the response wait on port 3.
23B3: 52 00    MOV   A,[X+0]
23B5: 62 D0 00 MOV   REG[208],0
23B8: 53 E3    MOV   [COMMAND_DESTINATION],A
(0473) 		LoadConfig_response3();
(0474) 		
(0475) 		// Clear the timeout flag.
(0476) 		TIMEOUT = 0;
(0477) 		
23BA: 10       PUSH  X
23BB: 7C 0C F1 LCALL 0x0CF1
23BE: 62 D0 00 MOV   REG[208],0
23C1: 20       POP   X
23C2: 54 00    MOV   [X+0],A
(0478) 		// Start listening for a response through child port 3.
(0479) 		CHILD_3_Start(CHILD_3_PARITY_NONE);
(0480) 		
23C4: 10       PUSH  X
23C5: 7C 0C F1 LCALL 0x0CF1
23C8: 20       POP   X
23C9: 62 D0 00 MOV   REG[208],0
23CC: 53 E2    MOV   [COMMAND_TYPE],A
(0481) 		CHILD_3_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0482) 		CHILD_3_TIMEOUT_Start();			// Start the timer.
(0483) 		
23CE: 56 02 00 MOV   [X+2],0
23D1: 56 01 00 MOV   [X+1],0
23D4: 80 0E    JMP   0x23E3
(0484) 		// Set the current state.
(0485) 		STATE = RESPONSE_3;
23D6: 10       PUSH  X
23D7: 7C 0C F1 LCALL 0x0CF1
23DA: 62 D0 00 MOV   REG[208],0
23DD: 20       POP   X
23DE: 77 02    INC   [X+2]
23E0: 0F 01 00 ADC   [X+1],0
23E3: 62 D0 00 MOV   REG[208],0
23E6: 52 00    MOV   A,[X+0]
23E8: 53 CC    MOV   [__r1],A
23EA: 55 CD 00 MOV   [__r0],0
23ED: 16 CC 01 SUB   [__r1],1
23F0: 1E CD 00 SBB   [__r0],0
23F3: 52 02    MOV   A,[X+2]
23F5: 12 CC    SUB   A,[__r1]
23F7: 51 CD    MOV   A,[__r0]
23F9: 31 80    XOR   A,128
23FB: 53 CA    MOV   [__rX],A
23FD: 52 01    MOV   A,[X+1]
23FF: 31 80    XOR   A,128
2401: 1A CA    SBB   A,[__rX]
2403: CF D2    JC    0x23D6
(0486) 	}
(0487) 	else if(mode == RESPONSE_4)
(0488) 	{
2405: 62 D0 00 MOV   REG[208],0
2408: 55 CC 01 MOV   [__r1],1
240B: 55 CD 00 MOV   [__r0],0
240E: 84 4A    JMP   0x2859
(0489) 		// Load the response wait on port 4.
(0490) 		LoadConfig_response4();
(0491) 		
2410: 62 D0 00 MOV   REG[208],0
2413: 3C D0 00 CMP   [STATE],0
2416: B0 6E    JNZ   0x2485
2418: 3C D1 07 CMP   [STATE+1],7
241B: B0 69    JNZ   0x2485
(0492) 		// Clear the timeout flag.
(0493) 		TIMEOUT = 0;
(0494) 		
241D: 10       PUSH  X
241E: 7C 18 BA LCALL 0x18BA
2421: 20       POP   X
2422: 39 FC    CMP   A,252
2424: B0 12    JNZ   0x2437
(0495) 		// Start listening for a response through child port 4.
(0496) 		CHILD_4_Start(CHILD_4_PARITY_NONE);
2426: 62 D0 00 MOV   REG[208],0
2429: 55 D4 31 MOV   [CHILD],49
(0497) 		
(0498) 		CHILD_4_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
242C: 62 D0 00 MOV   REG[208],0
242F: 55 CC 01 MOV   [__r1],1
2432: 55 CD 00 MOV   [__r0],0
2435: 84 23    JMP   0x2859
(0499) 		CHILD_4_TIMEOUT_Start();			// Start the timer.
(0500) 		
2437: 10       PUSH  X
2438: 7C 17 61 LCALL 0x1761
243B: 20       POP   X
243C: 39 FC    CMP   A,252
243E: B0 12    JNZ   0x2451
(0501) 		// Set the current state.
(0502) 		STATE = RESPONSE_4;
2440: 62 D0 00 MOV   REG[208],0
2443: 55 D4 32 MOV   [CHILD],50
(0503) 	}
(0504) 	else if(mode == HELLO_MODE)
2446: 62 D0 00 MOV   REG[208],0
2449: 55 CC 01 MOV   [__r1],1
244C: 55 CD 00 MOV   [__r0],0
244F: 84 09    JMP   0x2859
(0505) 	{
(0506) 		// Load the hello wait mode. This is for listening on all ports for a hello response.
2451: 10       PUSH  X
2452: 7C 16 08 LCALL 0x1608
2455: 20       POP   X
2456: 39 FC    CMP   A,252
2458: B0 12    JNZ   0x246B
(0507) 		LoadConfig_hello();
(0508) 		
245A: 62 D0 00 MOV   REG[208],0
245D: 55 D4 33 MOV   [CHILD],51
(0509) 		// Clear the timeout flag.
(0510) 		TIMEOUT = 0;
2460: 62 D0 00 MOV   REG[208],0
2463: 55 CC 01 MOV   [__r1],1
2466: 55 CD 00 MOV   [__r0],0
2469: 83 EF    JMP   0x2859
(0511) 		
(0512) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
246B: 10       PUSH  X
246C: 7C 14 AF LCALL 0x14AF
246F: 20       POP   X
2470: 39 FC    CMP   A,252
2472: B3 DD    JNZ   0x2850
(0513) 	
(0514) 		{
2474: 62 D0 00 MOV   REG[208],0
2477: 55 D4 34 MOV   [CHILD],52
(0515) 		// Start listening for a response through child port 1.
(0516) 		HELLO_1_Start(HELLO_1_PARITY_NONE);
247A: 62 D0 00 MOV   REG[208],0
247D: 55 CC 01 MOV   [__r1],1
2480: 55 CD 00 MOV   [__r0],0
2483: 83 D5    JMP   0x2859
(0517) 		}
(0518) 		
(0519) 		{
2485: 62 D0 00 MOV   REG[208],0
2488: 3C D0 00 CMP   [STATE],0
248B: B0 D2    JNZ   0x255E
248D: 3C D1 03 CMP   [STATE+1],3
2490: B0 CD    JNZ   0x255E
(0520) 		// Start listening for a response through child port 2.
(0521) 		HELLO_2_Start(HELLO_2_PARITY_NONE);
2492: 10       PUSH  X
2493: 7C 1F 9E LCALL 0x1F9E
2496: 62 D0 00 MOV   REG[208],0
2499: 20       POP   X
249A: 54 00    MOV   [X+0],A
249C: 39 00    CMP   A,0
249E: A3 B1    JZ    0x2850
(0522) 		}
(0523) 		
24A0: 3D 00 FF CMP   [X+0],255
24A3: B0 90    JNZ   0x2534
(0524) 		{
24A5: 80 7F    JMP   0x2525
(0525) 		// Start listening for a response through child port 3.
(0526) 		HELLO_3_Start(HELLO_3_PARITY_NONE);
(0527) 		}
(0528) 		
(0529) 		{
24A7: 10       PUSH  X
24A8: 7C 1F 9E LCALL 0x1F9E
24AB: 62 D0 00 MOV   REG[208],0
24AE: 20       POP   X
24AF: 54 00    MOV   [X+0],A
24B1: 39 00    CMP   A,0
24B3: A0 71    JZ    0x2525
(0530) 		// Start listening for a response through child port 4.
(0531) 		HELLO_4_Start(HELLO_4_PARITY_NONE);
(0532) 		}
(0533) 		
24B5: 3D 00 FF CMP   [X+0],255
24B8: A0 6C    JZ    0x2525
(0534) 		HELLO_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
(0535) 		HELLO_TIMEOUT_Start();		// Start the timer.
(0536) 		
24BA: 52 00    MOV   A,[X+0]
24BC: 05 04    ADD   [X+4],A
24BE: 0F 03 00 ADC   [X+3],0
24C1: 80 56    JMP   0x2518
(0537) 		// Set the current state.
(0538) 		STATE = HELLO_MODE;
(0539) 	}
(0540) 	else if(mode == INITIALIZE)
(0541) 	{
(0542) 		// Load the configuration for initialization. This config listens but does not forward.
24C3: 10       PUSH  X
24C4: 7C 1F 9E LCALL 0x1F9E
24C7: 62 D0 00 MOV   REG[208],0
24CA: 20       POP   X
24CB: 54 00    MOV   [X+0],A
24CD: 39 00    CMP   A,0
24CF: A0 48    JZ    0x2518
(0543) 		LoadConfig_initial();
(0544) 		
(0545) 		// Clear the timeout flag.
24D1: 52 00    MOV   A,[X+0]
24D3: 53 CC    MOV   [__r1],A
24D5: 55 CD 00 MOV   [__r0],0
24D8: 50 FF    MOV   A,255
24DA: 12 CC    SUB   A,[__r1]
24DC: 53 CC    MOV   [__r1],A
24DE: 50 00    MOV   A,0
24E0: 1A CD    SBB   A,[__r0]
24E2: 53 CD    MOV   [__r0],A
24E4: 50 01    MOV   A,1
24E6: 08       PUSH  A
24E7: 50 00    MOV   A,0
24E9: 08       PUSH  A
24EA: 52 03    MOV   A,[X+3]
24EC: 08       PUSH  A
24ED: 52 04    MOV   A,[X+4]
24EF: 08       PUSH  A
24F0: 7C 32 56 LCALL __divmod_16X16_16
24F3: 38 FE    ADD   SP,254
24F5: 18       POP   A
24F6: 53 CB    MOV   [__r3],A
24F8: 18       POP   A
24F9: 3A CD    CMP   A,[__r0]
24FB: B0 12    JNZ   0x250E
24FD: 51 CB    MOV   A,[__r3]
24FF: 3A CC    CMP   A,[__r1]
2501: B0 0C    JNZ   0x250E
(0546) 		TIMEOUT = 0;
(0547) 		
2503: 62 D0 00 MOV   REG[208],0
2506: 55 CC 01 MOV   [__r1],1
2509: 55 CD 00 MOV   [__r0],0
250C: 83 4C    JMP   0x2859
(0548) 		// Start the receiver.
(0549) 		INIT_RX_Start(INIT_RX_PARITY_NONE);
(0550) 		
(0551) 		INIT_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
250E: 62 D0 00 MOV   REG[208],0
2511: 52 00    MOV   A,[X+0]
2513: 05 04    ADD   [X+4],A
2515: 0F 03 00 ADC   [X+3],0
2518: 62 D0 00 MOV   REG[208],0
251B: 3C D2 00 CMP   [TIMEOUT],0
251E: B0 06    JNZ   0x2525
2520: 3C D3 00 CMP   [TIMEOUT+1],0
2523: AF 9F    JZ    0x24C3
2525: 62 D0 00 MOV   REG[208],0
2528: 3C D2 00 CMP   [TIMEOUT],0
252B: B0 06    JNZ   0x2532
252D: 3C D3 00 CMP   [TIMEOUT+1],0
2530: AF 76    JZ    0x24A7
(0552) 		INIT_TIMEOUT_Start();		// Start the timer.
(0553) 		
(0554) 		// Set the current state.
(0555) 		STATE = INITIALIZE;
(0556) 	}
(0557) 	else if(mode == SERVO_COMM)
(0558) 	{
2532: 83 1D    JMP   0x2850
(0559) 		// Load the configuration for servo communication. This config only transmits on P00.
2534: 3D 00 FC CMP   [X+0],252
2537: B3 18    JNZ   0x2850
(0560) 		LoadConfig_servo_transmit();
2539: 80 15    JMP   0x254F
(0561) 		
(0562) 		// Clear the timeout flag.
(0563) 		TIMEOUT = 0;
(0564) 		
253B: 10       PUSH  X
253C: 7C 1F 9E LCALL 0x1F9E
253F: 62 D0 00 MOV   REG[208],0
2542: 20       POP   X
2543: 39 FD    CMP   A,253
2545: B0 09    JNZ   0x254F
(0565) 		// Start the transmitter.
(0566) 		SERVO_TX_Start(SERVO_TX_PARITY_NONE);
2547: 55 CC 01 MOV   [__r1],1
254A: 55 CD 00 MOV   [__r0],0
254D: 83 0B    JMP   0x2859
254F: 62 D0 00 MOV   REG[208],0
2552: 3C D2 00 CMP   [TIMEOUT],0
2555: B0 06    JNZ   0x255C
2557: 3C D3 00 CMP   [TIMEOUT+1],0
255A: AF E0    JZ    0x253B
(0567) 	
(0568) 		// Set the current state.
(0569) 		STATE = SERVO_COMM;
(0570) 	}
(0571) 	
255C: 82 F3    JMP   0x2850
(0572) 	// If this module is configured, talk on all pins for potential children.
255E: 62 D0 00 MOV   REG[208],0
2561: 3C D0 00 CMP   [STATE],0
2564: B0 D2    JNZ   0x2637
2566: 3C D1 04 CMP   [STATE+1],4
2569: B0 CD    JNZ   0x2637
(0573) 	if(CONFIGURED)
(0574) 	{
256B: 10       PUSH  X
256C: 7C 1D E5 LCALL 0x1DE5
256F: 62 D0 00 MOV   REG[208],0
2572: 20       POP   X
2573: 54 00    MOV   [X+0],A
2575: 39 00    CMP   A,0
2577: A2 D8    JZ    0x2850
(0575) 		PRT0GS |= 0b00011111;	// Connect all pins to the global bus.
(0576) 		PRT2DR &= 0b11111110;	// Turn on the LED (active low).
2579: 3D 00 FF CMP   [X+0],255
257C: B0 90    JNZ   0x260D
(0577) 	}
257E: 80 7F    JMP   0x25FE
(0578) 	else
(0579) 	{
(0580) 		PRT0GS |= 0b00000001;	// Just connect pin 0;
(0581) 		PRT2DR |= 0b00000001;	// Turn off the LED (active low).
(0582) 	}
2580: 10       PUSH  X
2581: 7C 1D E5 LCALL 0x1DE5
2584: 62 D0 00 MOV   REG[208],0
2587: 20       POP   X
2588: 54 00    MOV   [X+0],A
258A: 39 00    CMP   A,0
258C: A0 71    JZ    0x25FE
(0583) }
(0584) 
(0585) // This function checks the current hardware configuration state. Once it finds this state, it
(0586) // uses the receivers that are in that configuration in the way they are intended to grab the
258E: 3D 00 FF CMP   [X+0],255
2591: A0 6C    JZ    0x25FE
(0587) // transmission information that we require (or just let commands pass through if we don't care).
(0588) int commandReady(void)
(0589) {
2593: 52 00    MOV   A,[X+0]
2595: 05 04    ADD   [X+4],A
2597: 0F 03 00 ADC   [X+3],0
259A: 80 56    JMP   0x25F1
(0590) 	int i = 0;			// This integer is used for looping through the remaining bytes of commands.
(0591) 	char tempByte = 0;	// This byte is used to store each byte for comparison as it comes in.
(0592) 	
(0593) 	int runningTotal = 0;	// This is used to check for a checksum in the case of a servo transmit.
(0594) 	
(0595) 	// This conditional checks which configuration is loaded and uses the proper devices to
259C: 10       PUSH  X
259D: 7C 1D E5 LCALL 0x1DE5
25A0: 62 D0 00 MOV   REG[208],0
25A3: 20       POP   X
25A4: 54 00    MOV   [X+0],A
25A6: 39 00    CMP   A,0
25A8: A0 48    JZ    0x25F1
(0596) 	// read a transmission and store the important information from that transmission.
(0597) 	if(STATE == WAIT)
(0598) 	{	
25AA: 52 00    MOV   A,[X+0]
25AC: 53 CC    MOV   [__r1],A
25AE: 55 CD 00 MOV   [__r0],0
25B1: 50 FF    MOV   A,255
25B3: 12 CC    SUB   A,[__r1]
25B5: 53 CC    MOV   [__r1],A
25B7: 50 00    MOV   A,0
25B9: 1A CD    SBB   A,[__r0]
25BB: 53 CD    MOV   [__r0],A
25BD: 50 01    MOV   A,1
25BF: 08       PUSH  A
25C0: 50 00    MOV   A,0
25C2: 08       PUSH  A
25C3: 52 03    MOV   A,[X+3]
25C5: 08       PUSH  A
25C6: 52 04    MOV   A,[X+4]
25C8: 08       PUSH  A
25C9: 7C 32 56 LCALL __divmod_16X16_16
25CC: 38 FE    ADD   SP,254
25CE: 18       POP   A
25CF: 53 CB    MOV   [__r3],A
25D1: 18       POP   A
25D2: 3A CD    CMP   A,[__r0]
25D4: B0 12    JNZ   0x25E7
25D6: 51 CB    MOV   A,[__r3]
25D8: 3A CC    CMP   A,[__r1]
25DA: B0 0C    JNZ   0x25E7
(0599) 		// In wait mode, the only thing that progresses things forward is a master node transmission.
(0600) 		// With this being the case, we use a blocking operation to sit and wait for a byte.
25DC: 62 D0 00 MOV   REG[208],0
25DF: 55 CC 01 MOV   [__r1],1
25E2: 55 CD 00 MOV   [__r0],0
25E5: 82 73    JMP   0x2859
(0601) 		tempByte = WAIT_RECV_cGetChar();
(0602) 		
(0603) 		// If a transmission has started for either a controller or a servo...
(0604) 		if(tempByte == START_TRANSMIT)
25E7: 62 D0 00 MOV   REG[208],0
25EA: 52 00    MOV   A,[X+0]
25EC: 05 04    ADD   [X+4],A
25EE: 0F 03 00 ADC   [X+3],0
25F1: 62 D0 00 MOV   REG[208],0
25F4: 3C D2 00 CMP   [TIMEOUT],0
25F7: B0 06    JNZ   0x25FE
25F9: 3C D3 00 CMP   [TIMEOUT+1],0
25FC: AF 9F    JZ    0x259C
25FE: 62 D0 00 MOV   REG[208],0
2601: 3C D2 00 CMP   [TIMEOUT],0
2604: B0 06    JNZ   0x260B
2606: 3C D3 00 CMP   [TIMEOUT+1],0
2609: AF 76    JZ    0x2580
(0605) 		{
(0606) 			// While we keep reading start bytes, sit and spin.
(0607) 			while(tempByte == START_TRANSMIT)
(0608) 			{
(0609) 				tempByte = WAIT_RECV_cGetChar();
(0610) 			}
(0611) 			
260B: 82 44    JMP   0x2850
(0612) 			// The tempByte variable contains the source ID. If the source is good, store all bytes.
260D: 3D 00 FC CMP   [X+0],252
2610: B2 3F    JNZ   0x2850
(0613) 			if(tempByte == MASTER_ID)
2612: 80 15    JMP   0x2628
(0614) 			{
(0615) 				COMMAND_SOURCE = tempByte;
(0616) 				COMMAND_DESTINATION = WAIT_RECV_cGetChar();
(0617) 				COMMAND_TYPE = WAIT_RECV_cGetChar();
2614: 10       PUSH  X
2615: 7C 1D E5 LCALL 0x1DE5
2618: 62 D0 00 MOV   REG[208],0
261B: 20       POP   X
261C: 39 FD    CMP   A,253
261E: B0 09    JNZ   0x2628
(0618) 				COMMAND_PARAM = WAIT_RECV_cGetChar();
(0619) 				
2620: 55 CC 01 MOV   [__r1],1
2623: 55 CD 00 MOV   [__r0],0
2626: 82 32    JMP   0x2859
2628: 62 D0 00 MOV   REG[208],0
262B: 3C D2 00 CMP   [TIMEOUT],0
262E: B0 06    JNZ   0x2635
2630: 3C D3 00 CMP   [TIMEOUT+1],0
2633: AF E0    JZ    0x2614
(0620) 				return 1;
(0621) 			}
(0622) 		}
(0623) 		else if(tempByte == SERVO_START)
(0624) 		{
2635: 82 1A    JMP   0x2850
(0625) 			// While we keep reading start bytes, sit and spin.
2637: 62 D0 00 MOV   REG[208],0
263A: 3C D0 00 CMP   [STATE],0
263D: B0 D2    JNZ   0x2710
263F: 3C D1 05 CMP   [STATE+1],5
2642: B0 CD    JNZ   0x2710
(0626) 			while(tempByte == SERVO_START)
(0627) 			{
2644: 10       PUSH  X
2645: 7C 1C 2C LCALL 0x1C2C
2648: 62 D0 00 MOV   REG[208],0
264B: 20       POP   X
264C: 54 00    MOV   [X+0],A
264E: 39 00    CMP   A,0
2650: A1 FF    JZ    0x2850
(0628) 				tempByte = WAIT_RECV_cGetChar();
(0629) 			}
2652: 3D 00 FF CMP   [X+0],255
2655: B0 90    JNZ   0x26E6
(0630) 			
2657: 80 7F    JMP   0x26D7
(0631) 			// We assume (and hopefully rightly so) that this is a command from master.
(0632) 			COMMAND_SOURCE = MASTER_ID;
(0633) 			// The first parameter after the servo start is the destination.
(0634) 			COMMAND_DESTINATION = tempByte;
(0635) 			// The second parameter after the servo start is the command length.
2659: 10       PUSH  X
265A: 7C 1C 2C LCALL 0x1C2C
265D: 62 D0 00 MOV   REG[208],0
2660: 20       POP   X
2661: 54 00    MOV   [X+0],A
2663: 39 00    CMP   A,0
2665: A0 71    JZ    0x26D7
(0636) 			// We don't need it to wait for the transmission to go through since the
(0637) 			// transmission goes through the chip with a delay of approximately 100 ns
(0638) 			// (it is already in and out by the time you read this byte).
(0639) 			tempByte = WAIT_RECV_cGetChar();
2667: 3D 00 FF CMP   [X+0],255
266A: A0 6C    JZ    0x26D7
(0640) 			// Now we store the command type. Depending on what the status return level
(0641) 			// is, we have special duties.
(0642) 			COMMAND_TYPE = WAIT_RECV_cGetChar();
266C: 52 00    MOV   A,[X+0]
266E: 05 04    ADD   [X+4],A
2670: 0F 03 00 ADC   [X+3],0
2673: 80 56    JMP   0x26CA
(0643) 			
(0644) 			// This basically waits for the rest of the command to pass through.
(0645) 			for(i = 0; i < (tempByte - 1); i++)
(0646) 			{
(0647) 				WAIT_RECV_cGetChar();
(0648) 			}
2675: 10       PUSH  X
2676: 7C 1C 2C LCALL 0x1C2C
2679: 62 D0 00 MOV   REG[208],0
267C: 20       POP   X
267D: 54 00    MOV   [X+0],A
267F: 39 00    CMP   A,0
2681: A0 48    JZ    0x26CA
(0649) 				
(0650) 			return 1;
(0651) 		}
2683: 52 00    MOV   A,[X+0]
2685: 53 CC    MOV   [__r1],A
2687: 55 CD 00 MOV   [__r0],0
268A: 50 FF    MOV   A,255
268C: 12 CC    SUB   A,[__r1]
268E: 53 CC    MOV   [__r1],A
2690: 50 00    MOV   A,0
2692: 1A CD    SBB   A,[__r0]
2694: 53 CD    MOV   [__r0],A
2696: 50 01    MOV   A,1
2698: 08       PUSH  A
2699: 50 00    MOV   A,0
269B: 08       PUSH  A
269C: 52 03    MOV   A,[X+3]
269E: 08       PUSH  A
269F: 52 04    MOV   A,[X+4]
26A1: 08       PUSH  A
26A2: 7C 32 56 LCALL __divmod_16X16_16
26A5: 38 FE    ADD   SP,254
26A7: 18       POP   A
26A8: 53 CB    MOV   [__r3],A
26AA: 18       POP   A
26AB: 3A CD    CMP   A,[__r0]
26AD: B0 12    JNZ   0x26C0
26AF: 51 CB    MOV   A,[__r3]
26B1: 3A CC    CMP   A,[__r1]
26B3: B0 0C    JNZ   0x26C0
(0652) 	}
(0653) 	else if(STATE == HELLO_MODE)
26B5: 62 D0 00 MOV   REG[208],0
26B8: 55 CC 01 MOV   [__r1],1
26BB: 55 CD 00 MOV   [__r0],0
26BE: 81 9A    JMP   0x2859
(0654) 	{
(0655) 		// Check all of the ports for a start byte. Only one port will produce one.
(0656) 		if(HELLO_1_cReadChar() == START_TRANSMIT)
(0657) 		{		
26C0: 62 D0 00 MOV   REG[208],0
26C3: 52 00    MOV   A,[X+0]
26C5: 05 04    ADD   [X+4],A
26C7: 0F 03 00 ADC   [X+3],0
26CA: 62 D0 00 MOV   REG[208],0
26CD: 3C D2 00 CMP   [TIMEOUT],0
26D0: B0 06    JNZ   0x26D7
26D2: 3C D3 00 CMP   [TIMEOUT+1],0
26D5: AF 9F    JZ    0x2675
26D7: 62 D0 00 MOV   REG[208],0
26DA: 3C D2 00 CMP   [TIMEOUT],0
26DD: B0 06    JNZ   0x26E4
26DF: 3C D3 00 CMP   [TIMEOUT+1],0
26E2: AF 76    JZ    0x2659
(0658) 			CHILD = PORT_1;
(0659) 			
(0660) 			return 1;
(0661) 		}
(0662) 		else if(HELLO_2_cReadChar() == START_TRANSMIT)
(0663) 		{		
(0664) 			CHILD = PORT_2;
26E4: 81 6B    JMP   0x2850
(0665) 			
26E6: 3D 00 FC CMP   [X+0],252
26E9: B1 66    JNZ   0x2850
(0666) 			return 1;
26EB: 80 15    JMP   0x2701
(0667) 		}
(0668) 		else if(HELLO_3_cReadChar() == START_TRANSMIT)
(0669) 		{
(0670) 			CHILD = PORT_3;
26ED: 10       PUSH  X
26EE: 7C 1C 2C LCALL 0x1C2C
26F1: 62 D0 00 MOV   REG[208],0
26F4: 20       POP   X
26F5: 39 FD    CMP   A,253
26F7: B0 09    JNZ   0x2701
(0671) 			
(0672) 			return 1;
26F9: 55 CC 01 MOV   [__r1],1
26FC: 55 CD 00 MOV   [__r0],0
26FF: 81 59    JMP   0x2859
2701: 62 D0 00 MOV   REG[208],0
2704: 3C D2 00 CMP   [TIMEOUT],0
2707: B0 06    JNZ   0x270E
2709: 3C D3 00 CMP   [TIMEOUT+1],0
270C: AF E0    JZ    0x26ED
(0673) 		}
(0674) 		else if(HELLO_4_cReadChar() == START_TRANSMIT)
(0675) 		{
(0676) 			CHILD = PORT_4;
(0677) 			
270E: 81 41    JMP   0x2850
(0678) 			return 1;
2710: 62 D0 00 MOV   REG[208],0
2713: 3C D0 00 CMP   [STATE],0
2716: B0 D2    JNZ   0x27E9
2718: 3C D1 06 CMP   [STATE+1],6
271B: B0 CD    JNZ   0x27E9
(0679) 		}
(0680) 	}
271D: 10       PUSH  X
271E: 7C 1A 73 LCALL 0x1A73
2721: 62 D0 00 MOV   REG[208],0
2724: 20       POP   X
2725: 54 00    MOV   [X+0],A
2727: 39 00    CMP   A,0
2729: A1 26    JZ    0x2850
(0681) 	else if(STATE == RESPONSE_1)
(0682) 	{
272B: 3D 00 FF CMP   [X+0],255
272E: B0 90    JNZ   0x27BF
(0683) 		if(tempByte = CHILD_1_cReadChar())
2730: 80 7F    JMP   0x27B0
(0684) 		{
(0685) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0686) 			{
(0687) 				// While we have not timed out, try to let all of the bytes through.
(0688) 				while(!TIMEOUT)
2732: 10       PUSH  X
2733: 7C 1A 73 LCALL 0x1A73
2736: 62 D0 00 MOV   REG[208],0
2739: 20       POP   X
273A: 54 00    MOV   [X+0],A
273C: 39 00    CMP   A,0
273E: A0 71    JZ    0x27B0
(0689) 				{
(0690) 					// Eat the remaining servo start bytes.
(0691) 					if(tempByte = CHILD_1_cReadChar())
(0692) 					{
2740: 3D 00 FF CMP   [X+0],255
2743: A0 6C    JZ    0x27B0
(0693) 						// Once we get past the start bytes, we can start adding the
(0694) 						// bytes to our running total and searching for a checksum.
(0695) 						if(tempByte != SERVO_START)
2745: 52 00    MOV   A,[X+0]
2747: 05 04    ADD   [X+4],A
2749: 0F 03 00 ADC   [X+3],0
274C: 80 56    JMP   0x27A3
(0696) 						{
(0697) 							// Add to the running total.
(0698) 							runningTotal += tempByte;
(0699) 							
(0700) 							// Either find a checksum or time out. Either way we're not stuck.
(0701) 							while(!TIMEOUT)
274E: 10       PUSH  X
274F: 7C 1A 73 LCALL 0x1A73
2752: 62 D0 00 MOV   REG[208],0
2755: 20       POP   X
2756: 54 00    MOV   [X+0],A
2758: 39 00    CMP   A,0
275A: A0 48    JZ    0x27A3
(0702) 							{
(0703) 								// If a nonzero byte has arrived...
(0704) 								if(tempByte = CHILD_1_cReadChar())
275C: 52 00    MOV   A,[X+0]
275E: 53 CC    MOV   [__r1],A
2760: 55 CD 00 MOV   [__r0],0
2763: 50 FF    MOV   A,255
2765: 12 CC    SUB   A,[__r1]
2767: 53 CC    MOV   [__r1],A
2769: 50 00    MOV   A,0
276B: 1A CD    SBB   A,[__r0]
276D: 53 CD    MOV   [__r0],A
276F: 50 01    MOV   A,1
2771: 08       PUSH  A
2772: 50 00    MOV   A,0
2774: 08       PUSH  A
2775: 52 03    MOV   A,[X+3]
2777: 08       PUSH  A
2778: 52 04    MOV   A,[X+4]
277A: 08       PUSH  A
277B: 7C 32 56 LCALL __divmod_16X16_16
277E: 38 FE    ADD   SP,254
2780: 18       POP   A
2781: 53 CB    MOV   [__r3],A
2783: 18       POP   A
2784: 3A CD    CMP   A,[__r0]
2786: B0 12    JNZ   0x2799
2788: 51 CB    MOV   A,[__r3]
278A: 3A CC    CMP   A,[__r1]
278C: B0 0C    JNZ   0x2799
(0705) 								{
(0706) 									// Check to see if it is a checksum.
278E: 62 D0 00 MOV   REG[208],0
2791: 55 CC 01 MOV   [__r1],1
2794: 55 CD 00 MOV   [__r0],0
2797: 80 C1    JMP   0x2859
(0707) 									if((runningTotal%256) == (255-tempByte))
(0708) 									{
(0709) 										return 1;
(0710) 									}
2799: 62 D0 00 MOV   REG[208],0
279C: 52 00    MOV   A,[X+0]
279E: 05 04    ADD   [X+4],A
27A0: 0F 03 00 ADC   [X+3],0
27A3: 62 D0 00 MOV   REG[208],0
27A6: 3C D2 00 CMP   [TIMEOUT],0
27A9: B0 06    JNZ   0x27B0
27AB: 3C D3 00 CMP   [TIMEOUT+1],0
27AE: AF 9F    JZ    0x274E
27B0: 62 D0 00 MOV   REG[208],0
27B3: 3C D2 00 CMP   [TIMEOUT],0
27B6: B0 06    JNZ   0x27BD
27B8: 3C D3 00 CMP   [TIMEOUT+1],0
27BB: AF 76    JZ    0x2732
(0711) 									else
(0712) 									{
(0713) 										runningTotal += tempByte;
(0714) 									}
(0715) 								}
(0716) 							}
(0717) 						}
27BD: 80 92    JMP   0x2850
(0718) 					}
27BF: 3D 00 FC CMP   [X+0],252
27C2: B0 8D    JNZ   0x2850
(0719) 				}
27C4: 80 15    JMP   0x27DA
(0720) 			}
(0721) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
(0722) 			{
(0723) 				// We simply wait for the end transmit indicator.
27C6: 10       PUSH  X
27C7: 7C 1A 73 LCALL 0x1A73
27CA: 62 D0 00 MOV   REG[208],0
27CD: 20       POP   X
27CE: 39 FD    CMP   A,253
27D0: B0 09    JNZ   0x27DA
(0724) 				while(!TIMEOUT)
(0725) 				{
27D2: 55 CC 01 MOV   [__r1],1
27D5: 55 CD 00 MOV   [__r0],0
27D8: 80 80    JMP   0x2859
27DA: 62 D0 00 MOV   REG[208],0
27DD: 3C D2 00 CMP   [TIMEOUT],0
27E0: B0 06    JNZ   0x27E7
27E2: 3C D3 00 CMP   [TIMEOUT+1],0
27E5: AF E0    JZ    0x27C6
(0726) 					if(CHILD_1_cReadChar() == END_TRANSMIT)
(0727) 					{
(0728) 						return 1;
(0729) 					}
(0730) 				}
27E7: 80 68    JMP   0x2850
(0731) 			}
27E9: 62 D0 00 MOV   REG[208],0
27EC: 3C D0 00 CMP   [STATE],0
27EF: B0 60    JNZ   0x2850
27F1: 3C D1 08 CMP   [STATE+1],8
27F4: B0 5B    JNZ   0x2850
(0732) 		}
(0733) 	}
27F6: 10       PUSH  X
27F7: 7C 12 F6 LCALL 0x12F6
27FA: 62 D0 00 MOV   REG[208],0
27FD: 20       POP   X
27FE: 39 FF    CMP   A,255
2800: B0 4F    JNZ   0x2850
(0734) 	else if(STATE == RESPONSE_2)
2802: 80 40    JMP   0x2843
(0735) 	{
(0736) 		if(tempByte = CHILD_2_cReadChar())
(0737) 		{
(0738) 			if(tempByte == SERVO_START)		// We have a servo response coming.
2804: 10       PUSH  X
2805: 7C 12 F6 LCALL 0x12F6
2808: 62 D0 00 MOV   REG[208],0
280B: 20       POP   X
280C: 39 FF    CMP   A,255
280E: B0 34    JNZ   0x2843
(0739) 			{
(0740) 				// While we have not timed out, try to let all of the bytes through.
(0741) 				while(!TIMEOUT)
(0742) 				{
2810: 10       PUSH  X
2811: 7C 12 EE LCALL 0x12EE
2814: 20       POP   X
2815: 62 D0 00 MOV   REG[208],0
2818: 53 E4    MOV   [COMMAND_SOURCE],A
(0743) 					// Eat the remaining servo start bytes.
281A: 10       PUSH  X
281B: 7C 12 EE LCALL 0x12EE
281E: 20       POP   X
281F: 62 D0 00 MOV   REG[208],0
2822: 53 E0    MOV   [COMMAND_LENGTH],A
(0744) 					if(tempByte = CHILD_2_cReadChar())
2824: 10       PUSH  X
2825: 7C 12 EE LCALL 0x12EE
2828: 20       POP   X
2829: 62 D0 00 MOV   REG[208],0
282C: 53 DF    MOV   [COMMAND_ERROR],A
(0745) 					{
282E: 10       PUSH  X
282F: 7C 12 EE LCALL 0x12EE
2832: 20       POP   X
2833: 62 D0 00 MOV   REG[208],0
2836: 53 E1    MOV   [COMMAND_PARAM],A
(0746) 						// Once we get past the start bytes, we can start adding the
(0747) 						// bytes to our running total and searching for a checksum.
2838: 62 D0 00 MOV   REG[208],0
283B: 55 CC 01 MOV   [__r1],1
283E: 55 CD 00 MOV   [__r0],0
2841: 80 17    JMP   0x2859
2843: 62 D0 00 MOV   REG[208],0
2846: 3C D2 00 CMP   [TIMEOUT],0
2849: B0 06    JNZ   0x2850
284B: 3C D3 00 CMP   [TIMEOUT+1],0
284E: AF B5    JZ    0x2804
(0748) 						if(tempByte != SERVO_START)
(0749) 						{
(0750) 							// Add to the running total.
(0751) 							runningTotal += tempByte;
(0752) 							
(0753) 							// Either find a checksum or time out. Either way we're not stuck.
2850: 62 D0 00 MOV   REG[208],0
2853: 55 CC 00 MOV   [__r1],0
2856: 55 CD 00 MOV   [__r0],0
2859: 38 FB    ADD   SP,251
285B: 20       POP   X
285C: 7F       RET   
(0754) 							while(!TIMEOUT)
(0755) 							{
(0756) 								// If a nonzero byte has arrived...
(0757) 								if(tempByte = CHILD_2_cReadChar())
(0758) 								{
(0759) 									// Check to see if it is a checksum.
_takeAction:
  j                    --> X+7
  i                    --> X+5
  runningTotal         --> X+3
  tempByte             --> X+2
  i                    --> X+0
285D: 10       PUSH  X
285E: 4F       MOV   X,SP
285F: 38 09    ADD   SP,9
(0760) 									if((runningTotal%256) == (255-tempByte))
2861: 56 01 00 MOV   [X+1],0
2864: 56 00 00 MOV   [X+0],0
(0761) 									{
2867: 56 02 00 MOV   [X+2],0
(0762) 										return 1;
286A: 56 04 00 MOV   [X+4],0
286D: 56 03 00 MOV   [X+3],0
(0763) 									}
(0764) 									else
2870: 62 D0 00 MOV   REG[208],0
2873: 3C E2 C8 CMP   [COMMAND_TYPE],200
2876: B0 39    JNZ   0x28B0
(0765) 									{
(0766) 										runningTotal += tempByte;
2878: 62 D0 00 MOV   REG[208],0
287B: 3C CE 00 CMP   [CONFIGURED],0
287E: B0 0A    JNZ   0x2889
2880: 3C CF 00 CMP   [CONFIGURED+1],0
2883: B0 05    JNZ   0x2889
(0767) 									}
(0768) 								}
(0769) 							}
2885: 98 2C    CALL  _sayHello
(0770) 						}
2887: 81 83    JMP   0x2A0B
(0771) 					}
2889: 62 D0 00 MOV   REG[208],0
288C: 3C D4 00 CMP   [CHILD],0
288F: B0 14    JNZ   0x28A4
(0772) 				}
(0773) 			}
(0774) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
2891: 93 81    CALL  _childListen
2893: 62 D0 00 MOV   REG[208],0
2896: 3C CD 00 CMP   [__r0],0
2899: B0 06    JNZ   0x28A0
289B: 3C CC 00 CMP   [__r1],0
289E: A1 6C    JZ    0x2A0B
(0775) 			{
(0776) 				// We simply wait for the end transmit indicator.
(0777) 				while(!TIMEOUT)
28A0: 98 11    CALL  _sayHello
(0778) 				{
(0779) 					if(CHILD_2_cReadChar() == END_TRANSMIT)
28A2: 81 68    JMP   0x2A0B
(0780) 					{
28A4: 62 D0 00 MOV   REG[208],0
28A7: 3C D4 00 CMP   [CHILD],0
28AA: A1 60    JZ    0x2A0B
(0781) 						return 1;
(0782) 					}
(0783) 				}
28AC: 93 BE    CALL  _childResponse
(0784) 			}
(0785) 		}
28AE: 81 5C    JMP   0x2A0B
(0786) 	}
28B0: 62 D0 00 MOV   REG[208],0
28B3: 3C E2 CB CMP   [COMMAND_TYPE],203
28B6: B0 21    JNZ   0x28D8
(0787) 	else if(STATE == RESPONSE_3)
(0788) 	{
(0789) 		if(tempByte = CHILD_3_cReadChar())
28B8: 62 D0 00 MOV   REG[208],0
28BB: 51 E3    MOV   A,[COMMAND_DESTINATION]
28BD: 62 D0 00 MOV   REG[208],0
28C0: 3A E5    CMP   A,[ID]
28C2: B0 05    JNZ   0x28C8
(0790) 		{
(0791) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0792) 			{
28C4: 91 49    CALL  _pingResponse
(0793) 				// While we have not timed out, try to let all of the bytes through.
28C6: 81 44    JMP   0x2A0B
(0794) 				while(!TIMEOUT)
28C8: 62 D0 00 MOV   REG[208],0
28CB: 51 E5    MOV   A,[ID]
28CD: 62 D0 00 MOV   REG[208],0
28D0: 3A E3    CMP   A,[COMMAND_DESTINATION]
28D2: D1 38    JNC   0x2A0B
(0795) 				{
(0796) 					// Eat the remaining servo start bytes.
(0797) 					if(tempByte = CHILD_3_cReadChar())
28D4: 93 96    CALL  _childResponse
(0798) 					{
(0799) 						// Once we get past the start bytes, we can start adding the
28D6: 81 34    JMP   0x2A0B
(0800) 						// bytes to our running total and searching for a checksum.
28D8: 62 D0 00 MOV   REG[208],0
28DB: 3C E2 C9 CMP   [COMMAND_TYPE],201
28DE: B1 11    JNZ   0x29F0
(0801) 						if(tempByte != SERVO_START)
(0802) 						{
(0803) 							// Add to the running total.
28E0: 62 D0 00 MOV   REG[208],0
28E3: 51 E3    MOV   A,[COMMAND_DESTINATION]
28E5: 62 D0 00 MOV   REG[208],0
28E8: 3A E5    CMP   A,[ID]
28EA: B0 F5    JNZ   0x29E0
(0804) 							runningTotal += tempByte;
(0805) 							
28EC: 62 D0 00 MOV   REG[208],0
28EF: 50 00    MOV   A,0
28F1: 3A E1    CMP   A,[COMMAND_PARAM]
28F3: D1 17    JNC   0x2A0B
28F5: 62 D0 00 MOV   REG[208],0
28F8: 3C E1 FB CMP   [COMMAND_PARAM],251
28FB: D1 0F    JNC   0x2A0B
(0806) 							// Either find a checksum or time out. Either way we're not stuck.
(0807) 							while(!TIMEOUT)
(0808) 							{
28FD: 62 D0 00 MOV   REG[208],0
2900: 51 E1    MOV   A,[COMMAND_PARAM]
2902: 62 D0 00 MOV   REG[208],0
2905: 53 E5    MOV   [ID],A
(0809) 								// If a nonzero byte has arrived...
(0810) 								if(tempByte = CHILD_3_cReadChar())
(0811) 								{
2907: 62 D0 00 MOV   REG[208],0
290A: 55 CF 01 MOV   [CONFIGURED+1],1
290D: 55 CE 00 MOV   [CONFIGURED],0
(0812) 									// Check to see if it is a checksum.
(0813) 									if((runningTotal%256) == (255-tempByte))
(0814) 									{
2910: 62 D0 00 MOV   REG[208],0
2913: 51 E5    MOV   A,[ID]
2915: 62 D0 00 MOV   REG[208],0
2918: 3A E7    CMP   A,[SERVO_ID]
291A: A0 A8    JZ    0x29C3
(0815) 										return 1;
(0816) 									}
(0817) 									else
(0818) 									{
(0819) 										runningTotal += tempByte;
(0820) 									}
(0821) 								}
(0822) 							}
291C: 56 08 00 MOV   [X+8],0
291F: 56 07 00 MOV   [X+7],0
(0823) 						}
(0824) 					}
(0825) 				}
2922: 62 D0 00 MOV   REG[208],0
2925: 51 E5    MOV   A,[ID]
2927: 08       PUSH  A
2928: 50 03    MOV   A,3
292A: 08       PUSH  A
292B: 08       PUSH  A
292C: 50 04    MOV   A,4
292E: 08       PUSH  A
292F: 62 D0 00 MOV   REG[208],0
2932: 51 E7    MOV   A,[SERVO_ID]
2934: 08       PUSH  A
2935: 95 E2    CALL  _servoInstruction
2937: 38 FB    ADD   SP,251
(0826) 			}
(0827) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
(0828) 			{
2939: 56 06 00 MOV   [X+6],0
293C: 56 05 00 MOV   [X+5],0
(0829) 				// We simply wait for the end transmit indicator.
(0830) 				while(!TIMEOUT)
(0831) 				{
293F: 50 00    MOV   A,0
2941: 08       PUSH  A
2942: 08       PUSH  A
2943: 50 01    MOV   A,1
2945: 08       PUSH  A
2946: 50 02    MOV   A,2
2948: 08       PUSH  A
2949: 50 FE    MOV   A,254
294B: 08       PUSH  A
294C: 95 CB    CALL  _servoInstruction
294E: 38 FB    ADD   SP,251
2950: 80 43    JMP   0x2994
(0832) 					if(CHILD_3_cReadChar() == END_TRANSMIT)
(0833) 					{
(0834) 						return 1;
(0835) 					}
(0836) 				}
(0837) 			}
2952: 99 CE    CALL  _commandReady
2954: 62 D0 00 MOV   REG[208],0
2957: 3C CD 00 CMP   [__r0],0
295A: B0 06    JNZ   0x2961
295C: 3C CC 00 CMP   [__r1],0
295F: A0 34    JZ    0x2994
(0838) 		}
(0839) 	}
2961: 62 D0 00 MOV   REG[208],0
2964: 3C DF 00 CMP   [COMMAND_ERROR],0
2967: B0 2C    JNZ   0x2994
(0840) 	else if(STATE == RESPONSE_4)
(0841) 	{
(0842) 		if(tempByte = CHILD_4_cReadChar())
2969: 62 D0 00 MOV   REG[208],0
296C: 51 E4    MOV   A,[COMMAND_SOURCE]
296E: 62 D0 00 MOV   REG[208],0
2971: 3A E5    CMP   A,[ID]
2973: B0 20    JNZ   0x2994
(0843) 		{
(0844) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0845) 			{
2975: 62 D0 00 MOV   REG[208],0
2978: 55 D3 01 MOV   [TIMEOUT+1],1
297B: 55 D2 00 MOV   [TIMEOUT],0
(0846) 				// While we have not timed out, try to let all of the bytes through.
(0847) 				while(!TIMEOUT)
297E: 56 06 0A MOV   [X+6],10
2981: 56 05 00 MOV   [X+5],0
(0848) 				{
(0849) 					// Eat the remaining servo start bytes.
2984: 56 08 02 MOV   [X+8],2
2987: 56 07 00 MOV   [X+7],0
(0850) 					if(tempByte = CHILD_4_cReadChar())
(0851) 					{
298A: 62 D0 00 MOV   REG[208],0
298D: 51 E5    MOV   A,[ID]
298F: 62 D0 00 MOV   REG[208],0
2992: 53 E7    MOV   [SERVO_ID],A
2994: 62 D0 00 MOV   REG[208],0
2997: 3C D2 00 CMP   [TIMEOUT],0
299A: B0 06    JNZ   0x29A1
299C: 3C D3 00 CMP   [TIMEOUT+1],0
299F: AF B2    JZ    0x2952
29A1: 77 06    INC   [X+6]
29A3: 0F 05 00 ADC   [X+5],0
29A6: 52 06    MOV   A,[X+6]
29A8: 11 0A    SUB   A,10
29AA: 52 05    MOV   A,[X+5]
29AC: 31 80    XOR   A,128
29AE: 19 80    SBB   A,128
29B0: CF 8E    JC    0x293F
29B2: 77 08    INC   [X+8]
29B4: 0F 07 00 ADC   [X+7],0
29B7: 52 08    MOV   A,[X+8]
29B9: 11 02    SUB   A,2
29BB: 52 07    MOV   A,[X+7]
29BD: 31 80    XOR   A,128
29BF: 19 80    SBB   A,128
29C1: CF 60    JC    0x2922
(0852) 						// Once we get past the start bytes, we can start adding the
(0853) 						// bytes to our running total and searching for a checksum.
(0854) 						if(tempByte != SERVO_START)
(0855) 						{
(0856) 							// Add to the running total.
(0857) 							runningTotal += tempByte;
(0858) 							
(0859) 							// Either find a checksum or time out. Either way we're not stuck.
(0860) 							while(!TIMEOUT)
29C3: 62 D0 00 MOV   REG[208],0
29C6: 51 E5    MOV   A,[ID]
29C8: 62 D0 00 MOV   REG[208],0
29CB: 3A E7    CMP   A,[SERVO_ID]
29CD: A0 0E    JZ    0x29DC
(0861) 							{
(0862) 								// If a nonzero byte has arrived...
(0863) 								if(tempByte = CHILD_4_cReadChar())
29CF: 50 00    MOV   A,0
29D1: 08       PUSH  A
29D2: 50 01    MOV   A,1
29D4: 08       PUSH  A
29D5: 7C 21 18 LCALL _configToggle
29D8: 38 FE    ADD   SP,254
(0864) 								{
29DA: 80 30    JMP   0x2A0B
(0865) 									// Check to see if it is a checksum.
(0866) 									if((runningTotal%256) == (255-tempByte))
(0867) 									{
(0868) 										return 1;
29DC: 91 97    CALL  _assignedID
(0869) 									}
(0870) 									else
(0871) 									{
29DE: 80 2C    JMP   0x2A0B
(0872) 										runningTotal += tempByte;
29E0: 62 D0 00 MOV   REG[208],0
29E3: 51 E5    MOV   A,[ID]
29E5: 62 D0 00 MOV   REG[208],0
29E8: 3A E3    CMP   A,[COMMAND_DESTINATION]
29EA: D0 20    JNC   0x2A0B
(0873) 									}
(0874) 								}
(0875) 							}
29EC: 92 7E    CALL  _childResponse
(0876) 						}
(0877) 					}
29EE: 80 1C    JMP   0x2A0B
(0878) 				}
29F0: 62 D0 00 MOV   REG[208],0
29F3: 3C E2 01 CMP   [COMMAND_TYPE],1
29F6: A0 06    JZ    0x29FD
29F8: 3C E2 02 CMP   [COMMAND_TYPE],2
29FB: B0 0F    JNZ   0x2A0B
(0879) 			}
(0880) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
29FD: 62 D0 00 MOV   REG[208],0
2A00: 51 E5    MOV   A,[ID]
2A02: 62 D0 00 MOV   REG[208],0
2A05: 3A E3    CMP   A,[COMMAND_DESTINATION]
2A07: D0 03    JNC   0x2A0B
(0881) 			{
(0882) 				// We simply wait for the end transmit indicator.
(0883) 				while(!TIMEOUT)
2A09: 92 61    CALL  _childResponse
(0884) 				{
(0885) 					if(CHILD_4_cReadChar() == END_TRANSMIT)
2A0B: 38 F7    ADD   SP,247
2A0D: 20       POP   X
2A0E: 7F       RET   
(0886) 					{
(0887) 						return 1;
(0888) 					}
(0889) 				}
(0890) 			}
(0891) 		}
_pingResponse:
2A0F: 50 00    MOV   A,0
2A11: 08       PUSH  A
2A12: 50 02    MOV   A,2
2A14: 08       PUSH  A
2A15: 7C 21 18 LCALL _configToggle
2A18: 38 FE    ADD   SP,254
(0892) 	}
(0893) 	else if(STATE == INITIALIZE)
(0894) 	{
2A1A: 10       PUSH  X
2A1B: 50 FC    MOV   A,252
2A1D: 7C 0E EC LCALL 0x0EEC
2A20: 20       POP   X
(0895) 		if(INIT_RX_cReadChar() == SERVO_START)
2A21: 10       PUSH  X
2A22: 50 FC    MOV   A,252
2A24: 7C 0E 13 LCALL 0x0E13
2A27: 20       POP   X
(0896) 		{
2A28: 10       PUSH  X
2A29: 50 FC    MOV   A,252
2A2B: 7C 0E EC LCALL 0x0EEC
2A2E: 20       POP   X
(0897) 			while(!TIMEOUT)
2A2F: 10       PUSH  X
2A30: 50 FC    MOV   A,252
2A32: 7C 0E 13 LCALL 0x0E13
2A35: 20       POP   X
(0898) 			{
2A36: 10       PUSH  X
2A37: 62 D0 00 MOV   REG[208],0
2A3A: 51 E5    MOV   A,[ID]
2A3C: 7C 0E EC LCALL 0x0EEC
2A3F: 20       POP   X
(0899) 				// We officially have a transmission.
2A40: 10       PUSH  X
2A41: 62 D0 00 MOV   REG[208],0
2A44: 51 E5    MOV   A,[ID]
2A46: 7C 0E 13 LCALL 0x0E13
2A49: 20       POP   X
(0900) 				if(INIT_RX_cReadChar() == SERVO_START)
2A4A: 10       PUSH  X
2A4B: 50 00    MOV   A,0
2A4D: 7C 0E EC LCALL 0x0EEC
2A50: 20       POP   X
(0901) 				{
2A51: 10       PUSH  X
2A52: 50 00    MOV   A,0
2A54: 7C 0E 13 LCALL 0x0E13
2A57: 20       POP   X
(0902) 					// If we definitely have a transmission starting, grab all bytes from the rx buffer
2A58: 10       PUSH  X
2A59: 50 CB    MOV   A,203
2A5B: 7C 0E EC LCALL 0x0EEC
2A5E: 20       POP   X
(0903) 					// and store them in the proper variables for actions to be taken later.
2A5F: 10       PUSH  X
2A60: 50 CB    MOV   A,203
2A62: 7C 0E 13 LCALL 0x0E13
2A65: 20       POP   X
(0904) 					COMMAND_SOURCE = INIT_RX_cGetChar();
2A66: 10       PUSH  X
2A67: 50 01    MOV   A,1
2A69: 7C 0E EC LCALL 0x0EEC
2A6C: 20       POP   X
(0905) 					COMMAND_LENGTH = INIT_RX_cGetChar();
2A6D: 10       PUSH  X
2A6E: 50 01    MOV   A,1
2A70: 7C 0E 13 LCALL 0x0E13
2A73: 20       POP   X
(0906) 					COMMAND_ERROR = INIT_RX_cGetChar();
2A74: 10       PUSH  X
2A75: 62 D0 00 MOV   REG[208],0
2A78: 51 D4    MOV   A,[CHILD]
2A7A: 7C 0E EC LCALL 0x0EEC
2A7D: 20       POP   X
(0907) 					COMMAND_PARAM = INIT_RX_cGetChar();
2A7E: 10       PUSH  X
2A7F: 62 D0 00 MOV   REG[208],0
2A82: 51 D4    MOV   A,[CHILD]
2A84: 7C 0E 13 LCALL 0x0E13
2A87: 20       POP   X
(0908) 					
2A88: 10       PUSH  X
2A89: 50 FD    MOV   A,253
2A8B: 7C 0E EC LCALL 0x0EEC
2A8E: 20       POP   X
(0909) 					return 1;
2A8F: 10       PUSH  X
2A90: 50 FD    MOV   A,253
2A92: 7C 0E 13 LCALL 0x0E13
2A95: 20       POP   X
(0910) 				}
2A96: 10       PUSH  X
2A97: 50 FD    MOV   A,253
2A99: 7C 0E EC LCALL 0x0EEC
2A9C: 20       POP   X
(0911) 			}
2A9D: 10       PUSH  X
2A9E: 50 FD    MOV   A,253
2AA0: 7C 0E 13 LCALL 0x0E13
2AA3: 20       POP   X
(0912) 		}
(0913) 	}
(0914) 	
2AA4: 10       PUSH  X
2AA5: 7C 0E BF LCALL 0x0EBF
2AA8: 62 D0 00 MOV   REG[208],0
2AAB: 20       POP   X
2AAC: 53 CD    MOV   [__r0],A
2AAE: 47 CD 20 TST   [__r0],32
2AB1: AF F2    JZ    0x2AA4
(0915) 	return 0;
2AB3: 10       PUSH  X
2AB4: 7C 0D E6 LCALL 0x0DE6
2AB7: 62 D0 00 MOV   REG[208],0
2ABA: 20       POP   X
2ABB: 53 CD    MOV   [__r0],A
2ABD: 47 CD 20 TST   [__r0],32
2AC0: AF F2    JZ    0x2AB3
(0916) }
(0917) 
(0918) // This function interprets what has been read by the command ready function
2AC2: 95 33    CALL  _xmitWait
(0919) // and performs the appropriate action.
(0920) void takeAction(void)
2AC4: 50 00    MOV   A,0
2AC6: 08       PUSH  A
2AC7: 50 01    MOV   A,1
2AC9: 08       PUSH  A
2ACA: 7C 21 18 LCALL _configToggle
2ACD: 38 FE    ADD   SP,254
2ACF: 7F       RET   
(0921) {
(0922) 	int i = 0;							// An index variable for looping.
(0923) 	char tempByte = 0;					// A temporary byte storage variable.
(0924) 	int runningTotal = 0;				// A running total of bytes to check against a checksum.
(0925) 	
(0926) 	if(COMMAND_TYPE == HELLO_BYTE)		// The master is probing for new modules.
(0927) 	{
_unloadAllConfigs:
2AD0: 7C 06 AA LCALL 0x06AA
(0928) 		if(!CONFIGURED)
2AD3: 7C 07 1C LCALL 0x071C
(0929) 		{
2AD6: 7C 08 62 LCALL 0x0862
(0930) 			// Announce this module's presence if not configured.
2AD9: 7C 08 ED LCALL 0x08ED
(0931) 			sayHello();
2ADC: 7C 09 99 LCALL 0x0999
(0932) 		}
2ADF: 7C 0A 45 LCALL 0x0A45
(0933) 		else if(!CHILD)
2AE2: 7C 0A F7 LCALL 0x0AF7
(0934) 		{
2AE5: 7C 07 CA LCALL 0x07CA
(0935) 			// Listen for children if we have none.
2AE8: 7C 0B A6 LCALL 0x0BA6
2AEB: 7F       RET   
(0936) 			if(childListen())
(0937) 			{
(0938) 				// If a child was heard saying hello, forward the command with the port number added.
(0939) 				sayHello();
(0940) 			}
(0941) 		}
_unloadConfig:
  config_num           --> X-5
2AEC: 10       PUSH  X
2AED: 4F       MOV   X,SP
(0942) 		else if(CHILD)
2AEE: 3D FB 00 CMP   [X-5],0
2AF1: B0 0B    JNZ   0x2AFD
2AF3: 3D FC 01 CMP   [X-4],1
2AF6: B0 06    JNZ   0x2AFD
(0943) 		{
(0944) 			// If you have a child established, listen to that child.
2AF8: 7C 06 AA LCALL 0x06AA
(0945) 			childResponse();
2AFB: 80 77    JMP   0x2B73
(0946) 		}
2AFD: 3D FB 00 CMP   [X-5],0
2B00: B0 0B    JNZ   0x2B0C
2B02: 3D FC 07 CMP   [X-4],7
2B05: B0 06    JNZ   0x2B0C
(0947) 	}
(0948) 	else if(COMMAND_TYPE == PING)		// The master is trying to find a module that is configured.
2B07: 7C 07 1C LCALL 0x071C
(0949) 	{
2B0A: 80 68    JMP   0x2B73
(0950) 		// If this is to me, act accordingly.
2B0C: 3D FB 00 CMP   [X-5],0
2B0F: B0 0B    JNZ   0x2B1B
2B11: 3D FC 02 CMP   [X-4],2
2B14: B0 06    JNZ   0x2B1B
(0951) 		if(COMMAND_DESTINATION == ID)
(0952) 		{
2B16: 7C 08 62 LCALL 0x0862
(0953) 			// Ping back to the master.
2B19: 80 59    JMP   0x2B73
(0954) 			pingResponse();
2B1B: 3D FB 00 CMP   [X-5],0
2B1E: B0 0B    JNZ   0x2B2A
2B20: 3D FC 03 CMP   [X-4],3
2B23: B0 06    JNZ   0x2B2A
(0955) 		}
(0956) 		else if(COMMAND_DESTINATION > ID)
2B25: 7C 08 ED LCALL 0x08ED
(0957) 		{
2B28: 80 4A    JMP   0x2B73
(0958) 			// If you have a child established, listen to that child.
2B2A: 3D FB 00 CMP   [X-5],0
2B2D: B0 0B    JNZ   0x2B39
2B2F: 3D FC 04 CMP   [X-4],4
2B32: B0 06    JNZ   0x2B39
(0959) 			childResponse();
(0960) 		}
2B34: 7C 09 99 LCALL 0x0999
(0961) 	}
2B37: 80 3B    JMP   0x2B73
(0962) 	else if(COMMAND_TYPE == ID_ASSIGNMENT)	// The master is assigning an ID to someone.
2B39: 3D FB 00 CMP   [X-5],0
2B3C: B0 0B    JNZ   0x2B48
2B3E: 3D FC 05 CMP   [X-4],5
2B41: B0 06    JNZ   0x2B48
(0963) 	{
(0964) 		// If this is meant for me, change my ID.
2B43: 7C 0A 45 LCALL 0x0A45
(0965) 		if(COMMAND_DESTINATION == ID)
2B46: 80 2C    JMP   0x2B73
(0966) 		{
2B48: 3D FB 00 CMP   [X-5],0
2B4B: B0 0B    JNZ   0x2B57
2B4D: 3D FC 06 CMP   [X-4],6
2B50: B0 06    JNZ   0x2B57
(0967) 			if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
(0968) 			{
2B52: 7C 0A F7 LCALL 0x0AF7
(0969) 				// Assign this module the ID that has been passed by the master.
2B55: 80 1D    JMP   0x2B73
(0970) 				ID = COMMAND_PARAM;
2B57: 3D FB 00 CMP   [X-5],0
2B5A: B0 0B    JNZ   0x2B66
2B5C: 3D FC 08 CMP   [X-4],8
2B5F: B0 06    JNZ   0x2B66
(0971) 				
(0972) 				// This module is now configured.
2B61: 7C 07 CA LCALL 0x07CA
(0973) 				CONFIGURED = 1;
2B64: 80 0E    JMP   0x2B73
(0974) 				
2B66: 3D FB 00 CMP   [X-5],0
2B69: B0 09    JNZ   0x2B73
2B6B: 3D FC 09 CMP   [X-4],9
2B6E: B0 04    JNZ   0x2B73
(0975) 				// If the servo ID doesn't match what we want, change it to match.
(0976) 				if(ID != SERVO_ID)
2B70: 7C 0B A6 LCALL 0x0BA6
(0977) 				{
2B73: 20       POP   X
2B74: 7F       RET   
(0978) 					// These are our index variables for communication attempt timeouts.
(0979) 					int i;
(0980) 					int j;
(0981) 					
(0982) 					//while(ID != SERVO_ID)
(0983) 					
_assignedID:
2B75: 50 00    MOV   A,0
2B77: 08       PUSH  A
2B78: 50 02    MOV   A,2
2B7A: 08       PUSH  A
2B7B: 7C 21 18 LCALL _configToggle
2B7E: 38 FE    ADD   SP,254
(0984) 					for(j = 0; j < SERVO_COMM_LOOPS; j++)
(0985) 					{	
(0986) 						// Send a request to change the servo ID to match the controller ID.
2B80: 10       PUSH  X
2B81: 50 FC    MOV   A,252
2B83: 7C 0E EC LCALL 0x0EEC
2B86: 20       POP   X
(0987) 						servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
2B87: 10       PUSH  X
2B88: 50 FC    MOV   A,252
2B8A: 7C 0E 13 LCALL 0x0E13
2B8D: 20       POP   X
(0988) 					
2B8E: 10       PUSH  X
2B8F: 50 FC    MOV   A,252
2B91: 7C 0E EC LCALL 0x0EEC
2B94: 20       POP   X
(0989) 						// Try to read the servo's ID several times.
2B95: 10       PUSH  X
2B96: 50 FC    MOV   A,252
2B98: 7C 0E 13 LCALL 0x0E13
2B9B: 20       POP   X
(0990) 						for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
2B9C: 10       PUSH  X
2B9D: 62 D0 00 MOV   REG[208],0
2BA0: 51 E5    MOV   A,[ID]
2BA2: 7C 0E EC LCALL 0x0EEC
2BA5: 20       POP   X
(0991) 						{
2BA6: 10       PUSH  X
2BA7: 62 D0 00 MOV   REG[208],0
2BAA: 51 E5    MOV   A,[ID]
2BAC: 7C 0E 13 LCALL 0x0E13
2BAF: 20       POP   X
(0992) 							// Send a request for the servo ID, which is presumably now equal to ID.
2BB0: 10       PUSH  X
2BB1: 50 00    MOV   A,0
2BB3: 7C 0E EC LCALL 0x0EEC
2BB6: 20       POP   X
(0993) 							servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
2BB7: 10       PUSH  X
2BB8: 50 00    MOV   A,0
2BBA: 7C 0E 13 LCALL 0x0E13
2BBD: 20       POP   X
(0994) 							
2BBE: 10       PUSH  X
2BBF: 50 CA    MOV   A,202
2BC1: 7C 0E EC LCALL 0x0EEC
2BC4: 20       POP   X
(0995) 							// Wait for either a timeout or an indication that we want to exit the loop.
2BC5: 10       PUSH  X
2BC6: 50 CA    MOV   A,202
2BC8: 7C 0E 13 LCALL 0x0E13
2BCB: 20       POP   X
(0996) 							while(!TIMEOUT)
2BCC: 10       PUSH  X
2BCD: 50 FD    MOV   A,253
2BCF: 7C 0E EC LCALL 0x0EEC
2BD2: 20       POP   X
(0997) 							{
2BD3: 10       PUSH  X
2BD4: 50 FD    MOV   A,253
2BD6: 7C 0E 13 LCALL 0x0E13
2BD9: 20       POP   X
(0998) 								// If we have a command to interpret, read it.
2BDA: 10       PUSH  X
2BDB: 50 FD    MOV   A,253
2BDD: 7C 0E EC LCALL 0x0EEC
2BE0: 20       POP   X
(0999) 								if(commandReady())
2BE1: 10       PUSH  X
2BE2: 50 FD    MOV   A,253
2BE4: 7C 0E 13 LCALL 0x0E13
2BE7: 20       POP   X
(1000) 								{
(1001) 									if(!COMMAND_ERROR)
(1002) 									{
2BE8: 10       PUSH  X
2BE9: 7C 0E BF LCALL 0x0EBF
2BEC: 62 D0 00 MOV   REG[208],0
2BEF: 20       POP   X
2BF0: 53 CD    MOV   [__r0],A
2BF2: 47 CD 20 TST   [__r0],32
2BF5: AF F2    JZ    0x2BE8
(1003) 										// If we have a valid servo ID, exit the loop.
2BF7: 10       PUSH  X
2BF8: 7C 0D E6 LCALL 0x0DE6
2BFB: 62 D0 00 MOV   REG[208],0
2BFE: 20       POP   X
2BFF: 53 CD    MOV   [__r0],A
2C01: 47 CD 20 TST   [__r0],32
2C04: AF F2    JZ    0x2BF7
(1004) 										if(COMMAND_SOURCE == ID)
(1005) 										{
(1006) 											// Set the timeout flag to exit the while loop.
2C06: 93 EF    CALL  _xmitWait
(1007) 											TIMEOUT = 1;
(1008) 											// Set i such that the for loop is exited.
2C08: 50 00    MOV   A,0
2C0A: 08       PUSH  A
2C0B: 50 01    MOV   A,1
2C0D: 08       PUSH  A
2C0E: 7C 21 18 LCALL _configToggle
2C11: 38 FE    ADD   SP,254
2C13: 7F       RET   
(1009) 											i = SERVO_COMM_ATTEMPTS;
(1010) 											// Set j such that we exit the outer loop as well.
(1011) 											j = SERVO_COMM_LOOPS;
(1012) 											// Store the ID value.
(1013) 											SERVO_ID = ID;
(1014) 										}
_childListen:
2C14: 50 00    MOV   A,0
2C16: 08       PUSH  A
2C17: 50 07    MOV   A,7
2C19: 08       PUSH  A
2C1A: 7C 21 18 LCALL _configToggle
2C1D: 38 FE    ADD   SP,254
2C1F: 80 1C    JMP   0x2C3C
(1015) 									}
(1016) 								}
(1017) 							}
(1018) 						}
(1019) 					}	
2C21: 7C 23 22 LCALL _commandReady
2C24: 62 D0 00 MOV   REG[208],0
2C27: 3C CD 00 CMP   [__r0],0
2C2A: B0 06    JNZ   0x2C31
2C2C: 3C CC 00 CMP   [__r1],0
2C2F: A0 0C    JZ    0x2C3C
(1020) 				}
(1021) 				
2C31: 62 D0 00 MOV   REG[208],0
2C34: 55 CC 01 MOV   [__r1],1
2C37: 55 CD 00 MOV   [__r0],0
2C3A: 80 30    JMP   0x2C6B
2C3C: 62 D0 00 MOV   REG[208],0
2C3F: 3C D2 00 CMP   [TIMEOUT],0
2C42: B0 06    JNZ   0x2C49
2C44: 3C D3 00 CMP   [TIMEOUT+1],0
2C47: AF D9    JZ    0x2C21
(1022) 				if(ID != SERVO_ID)
(1023) 				{
(1024) 					// Toggle back to normal wait mode.
(1025) 					configToggle(WAIT);
2C49: 10       PUSH  X
2C4A: 7C 13 C8 LCALL 0x13C8
2C4D: 20       POP   X
(1026) 				}
2C4E: 62 D0 00 MOV   REG[208],0
2C51: 55 D3 00 MOV   [TIMEOUT+1],0
2C54: 55 D2 00 MOV   [TIMEOUT],0
(1027) 				else
(1028) 				{
2C57: 50 00    MOV   A,0
2C59: 08       PUSH  A
2C5A: 50 01    MOV   A,1
2C5C: 08       PUSH  A
2C5D: 7C 21 18 LCALL _configToggle
2C60: 38 FE    ADD   SP,254
(1029) 					// Let the master node know that you got the ID assignment.
(1030) 					assignedID();
2C62: 62 D0 00 MOV   REG[208],0
2C65: 55 CC 00 MOV   [__r1],0
2C68: 55 CD 00 MOV   [__r0],0
2C6B: 7F       RET   
(1031) 				}
(1032) 			}
(1033) 		}
(1034) 		else if(COMMAND_DESTINATION > ID)
(1035) 		{
_childResponse:
  child_responded      --> X+0
2C6C: 10       PUSH  X
2C6D: 4F       MOV   X,SP
2C6E: 38 02    ADD   SP,2
(1036) 			// Switch to listen to your child.
2C70: 56 01 00 MOV   [X+1],0
2C73: 56 00 00 MOV   [X+0],0
(1037) 			childResponse();
(1038) 		}
(1039) 	}
2C76: 62 D0 00 MOV   REG[208],0
2C79: 3C D4 31 CMP   [CHILD],49
2C7C: B0 0E    JNZ   0x2C8B
(1040) 	else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
(1041) 	{
2C7E: 50 00    MOV   A,0
2C80: 08       PUSH  A
2C81: 50 03    MOV   A,3
2C83: 08       PUSH  A
2C84: 7C 21 18 LCALL _configToggle
2C87: 38 FE    ADD   SP,254
(1042) 		if(COMMAND_DESTINATION > ID)
2C89: 80 56    JMP   0x2CE0
(1043) 		{
2C8B: 62 D0 00 MOV   REG[208],0
2C8E: 3C D4 32 CMP   [CHILD],50
2C91: B0 0E    JNZ   0x2CA0
(1044) 			// Allow the child response through.
(1045) 			childResponse();
2C93: 50 00    MOV   A,0
2C95: 08       PUSH  A
2C96: 50 04    MOV   A,4
2C98: 08       PUSH  A
2C99: 7C 21 18 LCALL _configToggle
2C9C: 38 FE    ADD   SP,254
(1046) 		}
2C9E: 80 41    JMP   0x2CE0
(1047) 	}
2CA0: 62 D0 00 MOV   REG[208],0
2CA3: 3C D4 33 CMP   [CHILD],51
2CA6: B0 0E    JNZ   0x2CB5
(1048) }
(1049) 
2CA8: 50 00    MOV   A,0
2CAA: 08       PUSH  A
2CAB: 50 05    MOV   A,5
2CAD: 08       PUSH  A
2CAE: 7C 21 18 LCALL _configToggle
2CB1: 38 FE    ADD   SP,254
(1050) // This function sends out a ping response for everyone to hear.
2CB3: 80 2C    JMP   0x2CE0
(1051) void pingResponse(void)
2CB5: 62 D0 00 MOV   REG[208],0
2CB8: 3C D4 34 CMP   [CHILD],52
2CBB: B0 24    JNZ   0x2CE0
(1052) {
(1053) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2CBD: 50 00    MOV   A,0
2CBF: 08       PUSH  A
2CC0: 50 06    MOV   A,6
2CC2: 08       PUSH  A
2CC3: 7C 21 18 LCALL _configToggle
2CC6: 38 FE    ADD   SP,254
(1054) 	
2CC8: 80 17    JMP   0x2CE0
(1055) 	// Transmit a ping to everyone.
(1056) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1057) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1058) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1059) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
2CCA: 7C 23 22 LCALL _commandReady
2CCD: 62 D0 00 MOV   REG[208],0
2CD0: 3C CD 00 CMP   [__r0],0
2CD3: B0 06    JNZ   0x2CDA
2CD5: 3C CC 00 CMP   [__r1],0
2CD8: A0 07    JZ    0x2CE0
(1060) 	TX_014_PutChar(ID);				// My ID
(1061) 	TX_23_PutChar(ID);				// My ID
2CDA: 56 01 01 MOV   [X+1],1
2CDD: 56 00 00 MOV   [X+0],0
2CE0: 3D 00 00 CMP   [X+0],0
2CE3: B0 13    JNZ   0x2CF7
2CE5: 3D 01 00 CMP   [X+1],0
2CE8: B0 0E    JNZ   0x2CF7
2CEA: 62 D0 00 MOV   REG[208],0
2CED: 3C D2 00 CMP   [TIMEOUT],0
2CF0: B0 06    JNZ   0x2CF7
2CF2: 3C D3 00 CMP   [TIMEOUT+1],0
2CF5: AF D4    JZ    0x2CCA
(1062) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
(1063) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1064) 	TX_014_PutChar(PING);			// This is a ping response
(1065) 	TX_23_PutChar(PING);			// This is a ping response
(1066) 	TX_014_PutChar(TYPE);			// This is the module type
2CF7: 62 D0 00 MOV   REG[208],0
2CFA: 3C D4 31 CMP   [CHILD],49
2CFD: B0 08    JNZ   0x2D06
(1067) 	TX_23_PutChar(TYPE);			// This is the module type
(1068) 	TX_014_PutChar(CHILD);			// This is the child-connected port
2CFF: 10       PUSH  X
2D00: 7C 1F 2B LCALL 0x1F2B
2D03: 20       POP   X
(1069) 	TX_23_PutChar(CHILD);			// This is the child-connected port
2D04: 80 2C    JMP   0x2D31
(1070) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2D06: 62 D0 00 MOV   REG[208],0
2D09: 3C D4 32 CMP   [CHILD],50
2D0C: B0 08    JNZ   0x2D15
(1071) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1072) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2D0E: 10       PUSH  X
2D0F: 7C 1D 72 LCALL 0x1D72
2D12: 20       POP   X
(1073) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2D13: 80 1D    JMP   0x2D31
(1074) 	
2D15: 62 D0 00 MOV   REG[208],0
2D18: 3C D4 33 CMP   [CHILD],51
2D1B: B0 08    JNZ   0x2D24
(1075) 	// Wait for the transmission to finish.
(1076) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
2D1D: 10       PUSH  X
2D1E: 7C 1B B9 LCALL 0x1BB9
2D21: 20       POP   X
(1077) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2D22: 80 0E    JMP   0x2D31
(1078) 	
2D24: 62 D0 00 MOV   REG[208],0
2D27: 3C D4 34 CMP   [CHILD],52
2D2A: B0 06    JNZ   0x2D31
(1079) 	// Make completely sure we're done.
(1080) 	xmitWait();
2D2C: 10       PUSH  X
2D2D: 7C 1A 00 LCALL 0x1A00
2D30: 20       POP   X
(1081) 	
(1082) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1083) }
2D31: 62 D0 00 MOV   REG[208],0
2D34: 55 D3 00 MOV   [TIMEOUT+1],0
2D37: 55 D2 00 MOV   [TIMEOUT],0
(1084) 
(1085) // This function blindly unloads all user configurations. This will be called once,
2D3A: 50 00    MOV   A,0
2D3C: 08       PUSH  A
2D3D: 50 01    MOV   A,1
2D3F: 08       PUSH  A
2D40: 7C 21 18 LCALL _configToggle
2D43: 38 FE    ADD   SP,254
(1086) // when the system initially has no known state.
(1087) void unloadAllConfigs(void)
2D45: 62 D0 00 MOV   REG[208],0
2D48: 52 01    MOV   A,[X+1]
2D4A: 53 CC    MOV   [__r1],A
2D4C: 52 00    MOV   A,[X+0]
2D4E: 53 CD    MOV   [__r0],A
2D50: 38 FE    ADD   SP,254
2D52: 20       POP   X
2D53: 7F       RET   
(1088) {
(1089) 	UnloadConfig_waiting();
(1090) 	UnloadConfig_hello();
(1091) 	UnloadConfig_my_response();
(1092) 	UnloadConfig_response1();
(1093) 	UnloadConfig_response2();
(1094) 	UnloadConfig_response3();
_servoFinder:
  flashWrite           --> X+7
  status_return_level  --> X+6
  total_attempts       --> X+4
  j                    --> X+2
  i                    --> X+0
2D54: 10       PUSH  X
2D55: 4F       MOV   X,SP
2D56: 38 09    ADD   SP,9
(1095) 	UnloadConfig_response4();
(1096) 	UnloadConfig_initial();
2D58: 56 01 00 MOV   [X+1],0
2D5B: 56 00 00 MOV   [X+0],0
(1097) 	UnloadConfig_servo_transmit();
2D5E: 56 03 00 MOV   [X+3],0
2D61: 56 02 00 MOV   [X+2],0
(1098) }
(1099) 
2D64: 56 05 00 MOV   [X+5],0
2D67: 56 04 00 MOV   [X+4],0
(1100) // This function unloads the configuration corresponding to the config number passed to it.
(1101) // We do this instead of unloadAllConfigs to cut down on set up time.
(1102) void unloadConfig(int config_num)
2D6A: 56 08 00 MOV   [X+8],0
2D6D: 56 07 00 MOV   [X+7],0
(1103) {
(1104) 	if(config_num == WAIT)
(1105) 	{
2D70: 56 06 03 MOV   [X+6],3
(1106) 		UnloadConfig_waiting();
(1107) 	}
(1108) 	else if(config_num == HELLO_MODE)
2D73: 62 D0 00 MOV   REG[208],0
2D76: 55 E7 FF MOV   [SERVO_ID],255
(1109) 	{
(1110) 		UnloadConfig_hello();
(1111) 	}
(1112) 	else if(config_num == MY_RESPONSE)
(1113) 	{
(1114) 		UnloadConfig_my_response();
(1115) 	}
(1116) 	else if(config_num == RESPONSE_1)
(1117) 	{
2D79: 56 03 00 MOV   [X+3],0
2D7C: 56 02 00 MOV   [X+2],0
(1118) 		UnloadConfig_response1();
(1119) 	}
(1120) 	else if(config_num == RESPONSE_2)
2D7F: 56 01 00 MOV   [X+1],0
2D82: 56 00 00 MOV   [X+0],0
(1121) 	{
(1122) 		UnloadConfig_response2();
(1123) 	}
2D85: 50 00    MOV   A,0
2D87: 08       PUSH  A
2D88: 08       PUSH  A
2D89: 50 01    MOV   A,1
2D8B: 08       PUSH  A
2D8C: 50 02    MOV   A,2
2D8E: 08       PUSH  A
2D8F: 50 FE    MOV   A,254
2D91: 08       PUSH  A
2D92: 91 85    CALL  _servoInstruction
2D94: 38 FB    ADD   SP,251
(1124) 	else if(config_num == RESPONSE_3)
(1125) 	{
2D96: 77 05    INC   [X+5]
2D98: 0F 04 00 ADC   [X+4],0
2D9B: 80 4C    JMP   0x2DE8
(1126) 		UnloadConfig_response3();
(1127) 	}
(1128) 	else if(config_num == RESPONSE_4)
(1129) 	{
(1130) 		UnloadConfig_response4();
2D9D: 7C 23 22 LCALL _commandReady
2DA0: 62 D0 00 MOV   REG[208],0
2DA3: 3C CD 00 CMP   [__r0],0
2DA6: B0 06    JNZ   0x2DAD
2DA8: 3C CC 00 CMP   [__r1],0
2DAB: A0 3C    JZ    0x2DE8
(1131) 	}
(1132) 	else if(config_num == INITIALIZE)
(1133) 	{
2DAD: 62 D0 00 MOV   REG[208],0
2DB0: 3C E4 00 CMP   [COMMAND_SOURCE],0
2DB3: C0 2B    JC    0x2DDF
2DB5: 62 D0 00 MOV   REG[208],0
2DB8: 50 FD    MOV   A,253
2DBA: 3A E4    CMP   A,[COMMAND_SOURCE]
2DBC: C0 22    JC    0x2DDF
(1134) 		UnloadConfig_initial();
(1135) 	}
(1136) 	else if(config_num == SERVO_COMM)
2DBE: 62 D0 00 MOV   REG[208],0
2DC1: 55 D3 01 MOV   [TIMEOUT+1],1
2DC4: 55 D2 00 MOV   [TIMEOUT],0
(1137) 	{
(1138) 		UnloadConfig_servo_transmit();
2DC7: 62 D0 00 MOV   REG[208],0
2DCA: 51 E4    MOV   A,[COMMAND_SOURCE]
2DCC: 62 D0 00 MOV   REG[208],0
2DCF: 53 E7    MOV   [SERVO_ID],A
(1139) 	}
(1140) }
2DD1: 56 01 0A MOV   [X+1],10
2DD4: 56 00 00 MOV   [X+0],0
(1141) 
(1142) // This function responds that an ID has been assigned to it.
2DD7: 56 03 02 MOV   [X+3],2
2DDA: 56 02 00 MOV   [X+2],0
(1143) void assignedID(void)
2DDD: 80 0A    JMP   0x2DE8
(1144) {
(1145) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(1146) 	
(1147) 	// Transmit a ping to everyone.
2DDF: 62 D0 00 MOV   REG[208],0
2DE2: 55 D3 01 MOV   [TIMEOUT+1],1
2DE5: 55 D2 00 MOV   [TIMEOUT],0
2DE8: 62 D0 00 MOV   REG[208],0
2DEB: 3C D2 00 CMP   [TIMEOUT],0
2DEE: B0 06    JNZ   0x2DF5
2DF0: 3C D3 00 CMP   [TIMEOUT+1],0
2DF3: AF A9    JZ    0x2D9D
2DF5: 77 01    INC   [X+1]
2DF7: 0F 00 00 ADC   [X+0],0
2DFA: 52 01    MOV   A,[X+1]
2DFC: 11 0A    SUB   A,10
2DFE: 52 00    MOV   A,[X+0]
2E00: 31 80    XOR   A,128
2E02: 19 80    SBB   A,128
2E04: CF 80    JC    0x2D85
(1148) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1149) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1150) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1151) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1152) 	TX_014_PutChar(ID);				// My ID
(1153) 	TX_23_PutChar(ID);				// My ID
(1154) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
(1155) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
2E06: 62 D0 00 MOV   REG[208],0
2E09: 3C E7 FF CMP   [SERVO_ID],255
2E0C: B0 22    JNZ   0x2E2F
2E0E: 3D 07 00 CMP   [X+7],0
2E11: B0 1D    JNZ   0x2E2F
2E13: 3D 08 00 CMP   [X+8],0
2E16: B0 18    JNZ   0x2E2F
(1156) 	TX_014_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1157) 	TX_23_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1158) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2E18: 56 08 01 MOV   [X+8],1
2E1B: 56 07 00 MOV   [X+7],0
(1159) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1160) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1161) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1162) 	
2E1E: 50 00    MOV   A,0
2E20: 08       PUSH  A
2E21: 08       PUSH  A
2E22: 50 06    MOV   A,6
2E24: 08       PUSH  A
2E25: 50 02    MOV   A,2
2E27: 08       PUSH  A
2E28: 50 FE    MOV   A,254
2E2A: 08       PUSH  A
2E2B: 90 EC    CALL  _servoInstruction
2E2D: 38 FB    ADD   SP,251
2E2F: 77 03    INC   [X+3]
2E31: 0F 02 00 ADC   [X+2],0
2E34: 52 03    MOV   A,[X+3]
2E36: 11 02    SUB   A,2
2E38: 52 02    MOV   A,[X+2]
2E3A: 31 80    XOR   A,128
2E3C: 19 80    SBB   A,128
2E3E: CF 40    JC    0x2D7F
(1163) 	// Wait for the transmission to finish.
(1164) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1165) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
(1166) 	
(1167) 	// Make completely sure we're done.
2E40: 56 08 00 MOV   [X+8],0
2E43: 56 07 00 MOV   [X+7],0
(1168) 	xmitWait();
(1169) 	
(1170) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1171) }
2E46: 62 D0 00 MOV   REG[208],0
2E49: 3C E7 FE CMP   [SERVO_ID],254
2E4C: D0 C6    JNC   0x2F13
(1172) 
(1173) // This function listens for children and registers the port that they talk to.
(1174) int childListen(void)
(1175) {
(1176) 	configToggle(HELLO_MODE);	// Switch to listen for hellos on every port.
(1177) 	
2E4E: 56 03 00 MOV   [X+3],0
2E51: 56 02 00 MOV   [X+2],0
(1178) 	// Wait to either hear a child or time out.
(1179) 	while(!TIMEOUT)
(1180) 	{		
2E54: 56 01 00 MOV   [X+1],0
2E57: 56 00 00 MOV   [X+0],0
(1181) 		if(commandReady())
(1182) 		{
(1183) 			return 1;
2E5A: 50 01    MOV   A,1
2E5C: 08       PUSH  A
2E5D: 50 10    MOV   A,16
2E5F: 08       PUSH  A
2E60: 50 02    MOV   A,2
2E62: 08       PUSH  A
2E63: 50 04    MOV   A,4
2E65: 08       PUSH  A
2E66: 62 D0 00 MOV   REG[208],0
2E69: 51 E7    MOV   A,[SERVO_ID]
2E6B: 08       PUSH  A
2E6C: 90 AB    CALL  _servoInstruction
2E6E: 38 FB    ADD   SP,251
2E70: 80 48    JMP   0x2EB9
(1184) 		}
(1185) 	}
(1186) 	
(1187) 	HELLO_TIMEOUT_Stop();		// Stop the timer.
(1188) 	TIMEOUT = 0;				// Clear the timeout flag.
(1189) 	
2E72: 7C 23 22 LCALL _commandReady
2E75: 62 D0 00 MOV   REG[208],0
2E78: 3C CD 00 CMP   [__r0],0
2E7B: B0 06    JNZ   0x2E82
2E7D: 3C CC 00 CMP   [__r1],0
2E80: A0 38    JZ    0x2EB9
(1190) 	configToggle(WAIT);			// Switch back to wait for a master response.
(1191) 	
2E82: 62 D0 00 MOV   REG[208],0
2E85: 3C DF 00 CMP   [COMMAND_ERROR],0
2E88: B0 30    JNZ   0x2EB9
(1192) 	return 0;					// Return the result of our listening session.
(1193) }
(1194) 
2E8A: 62 D0 00 MOV   REG[208],0
2E8D: 3C E1 01 CMP   [COMMAND_PARAM],1
2E90: B0 1F    JNZ   0x2EB0
(1195) // This function waits for a known child's response.
(1196) int childResponse(void)
(1197) {
2E92: 62 D0 00 MOV   REG[208],0
2E95: 55 D3 01 MOV   [TIMEOUT+1],1
2E98: 55 D2 00 MOV   [TIMEOUT],0
(1198) 	int child_responded = 0;
(1199) 	
2E9B: 62 D0 00 MOV   REG[208],0
2E9E: 51 E1    MOV   A,[COMMAND_PARAM]
2EA0: 54 06    MOV   [X+6],A
(1200) 	// Switch to the right port.
(1201) 	if(CHILD == PORT_1)
2EA2: 56 01 0A MOV   [X+1],10
2EA5: 56 00 00 MOV   [X+0],0
(1202) 	{
(1203) 		configToggle(RESPONSE_1);
2EA8: 56 03 02 MOV   [X+3],2
2EAB: 56 02 00 MOV   [X+2],0
(1204) 	}
2EAE: 80 0A    JMP   0x2EB9
(1205) 	else if(CHILD == PORT_2)
(1206) 	{
(1207) 		configToggle(RESPONSE_2);
(1208) 	}
2EB0: 62 D0 00 MOV   REG[208],0
2EB3: 55 D3 01 MOV   [TIMEOUT+1],1
2EB6: 55 D2 00 MOV   [TIMEOUT],0
2EB9: 62 D0 00 MOV   REG[208],0
2EBC: 3C D2 00 CMP   [TIMEOUT],0
2EBF: B0 06    JNZ   0x2EC6
2EC1: 3C D3 00 CMP   [TIMEOUT+1],0
2EC4: AF AD    JZ    0x2E72
2EC6: 77 01    INC   [X+1]
2EC8: 0F 00 00 ADC   [X+0],0
2ECB: 52 01    MOV   A,[X+1]
2ECD: 11 0A    SUB   A,10
2ECF: 52 00    MOV   A,[X+0]
2ED1: 31 80    XOR   A,128
2ED3: 19 80    SBB   A,128
2ED5: CF 84    JC    0x2E5A
(1209) 	else if(CHILD == PORT_3)
(1210) 	{
(1211) 		configToggle(RESPONSE_3);
(1212) 	}
(1213) 	else if(CHILD == PORT_4)
(1214) 	{
(1215) 		configToggle(RESPONSE_4);
(1216) 	}
(1217) 	
2ED7: 3D 06 01 CMP   [X+6],1
2EDA: A0 27    JZ    0x2F02
2EDC: 3D 07 00 CMP   [X+7],0
2EDF: B0 22    JNZ   0x2F02
2EE1: 3D 08 00 CMP   [X+8],0
2EE4: B0 1D    JNZ   0x2F02
(1218) 	// Wait for a response or a timeout.
(1219) 	while((!child_responded) && (!TIMEOUT))
2EE6: 56 08 01 MOV   [X+8],1
2EE9: 56 07 00 MOV   [X+7],0
(1220) 	{
(1221) 		if(commandReady())
(1222) 		{
2EEC: 50 01    MOV   A,1
2EEE: 08       PUSH  A
2EEF: 50 10    MOV   A,16
2EF1: 08       PUSH  A
2EF2: 50 03    MOV   A,3
2EF4: 08       PUSH  A
2EF5: 50 04    MOV   A,4
2EF7: 08       PUSH  A
2EF8: 62 D0 00 MOV   REG[208],0
2EFB: 51 E7    MOV   A,[SERVO_ID]
2EFD: 08       PUSH  A
2EFE: 90 19    CALL  _servoInstruction
2F00: 38 FB    ADD   SP,251
2F02: 77 03    INC   [X+3]
2F04: 0F 02 00 ADC   [X+2],0
2F07: 52 03    MOV   A,[X+3]
2F09: 11 02    SUB   A,2
2F0B: 52 02    MOV   A,[X+2]
2F0D: 31 80    XOR   A,128
2F0F: 19 80    SBB   A,128
2F11: CF 42    JC    0x2E54
(1223) 			child_responded = 1;
(1224) 		}
(1225) 	}
(1226) 	
(1227) 	// Stop the right timer.
(1228) 	if(CHILD == PORT_1)
2F13: 91 55    CALL  _servoConfigWait
2F15: 38 F7    ADD   SP,247
2F17: 20       POP   X
2F18: 7F       RET   
(1229) 	{
(1230) 		CHILD_1_TIMEOUT_Stop();
(1231) 	}
(1232) 	else if(CHILD == PORT_2)
(1233) 	{
(1234) 		CHILD_2_TIMEOUT_Stop();
_servoInstruction:
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
2F19: 10       PUSH  X
2F1A: 4F       MOV   X,SP
2F1B: 38 01    ADD   SP,1
(1235) 	}
(1236) 	else if(CHILD == PORT_3)
(1237) 	{
(1238) 		CHILD_3_TIMEOUT_Stop();
2F1D: 50 00    MOV   A,0
2F1F: 08       PUSH  A
2F20: 50 09    MOV   A,9
2F22: 08       PUSH  A
2F23: 7C 21 18 LCALL _configToggle
2F26: 38 FE    ADD   SP,254
(1239) 	}
(1240) 	else if(CHILD == PORT_4)
(1241) 	{
2F28: 62 D0 00 MOV   REG[208],0
2F2B: 52 FB    MOV   A,[X-5]
2F2D: 53 CC    MOV   [__r1],A
2F2F: 55 CD 00 MOV   [__r0],0
2F32: 52 FC    MOV   A,[X-4]
2F34: 02 CC    ADD   A,[__r1]
2F36: 53 CC    MOV   [__r1],A
2F38: 50 00    MOV   A,0
2F3A: 0A CD    ADC   A,[__r0]
2F3C: 53 CD    MOV   [__r0],A
2F3E: 52 FA    MOV   A,[X-6]
2F40: 04 CC    ADD   [__r1],A
2F42: 0E CD 00 ADC   [__r0],0
2F45: 52 F9    MOV   A,[X-7]
2F47: 04 CC    ADD   [__r1],A
2F49: 0E CD 00 ADC   [__r0],0
2F4C: 52 F8    MOV   A,[X-8]
2F4E: 04 CC    ADD   [__r1],A
2F50: 0E CD 00 ADC   [__r0],0
2F53: 50 01    MOV   A,1
2F55: 08       PUSH  A
2F56: 50 00    MOV   A,0
2F58: 08       PUSH  A
2F59: 51 CD    MOV   A,[__r0]
2F5B: 08       PUSH  A
2F5C: 51 CC    MOV   A,[__r1]
2F5E: 08       PUSH  A
2F5F: 7C 32 56 LCALL __divmod_16X16_16
2F62: 38 FE    ADD   SP,254
2F64: 18       POP   A
2F65: 53 CC    MOV   [__r1],A
2F67: 18       POP   A
2F68: 50 FF    MOV   A,255
2F6A: 12 CC    SUB   A,[__r1]
2F6C: 54 00    MOV   [X+0],A
(1242) 		CHILD_4_TIMEOUT_Stop();
(1243) 	}
(1244) 	
2F6E: 3D FA 01 CMP   [X-6],1
2F71: B0 2D    JNZ   0x2F9F
(1245) 	TIMEOUT = 0;					// Reset the timeout flag.
(1246) 	
2F73: 10       PUSH  X
2F74: 50 FF    MOV   A,255
2F76: 7C 10 25 LCALL 0x1025
2F79: 20       POP   X
(1247) 	configToggle(WAIT);				// Switch back to wait for a master response.
2F7A: 10       PUSH  X
2F7B: 50 FF    MOV   A,255
2F7D: 7C 10 25 LCALL 0x1025
2F80: 20       POP   X
(1248) 	
2F81: 10       PUSH  X
2F82: 52 FC    MOV   A,[X-4]
2F84: 7C 10 25 LCALL 0x1025
2F87: 20       POP   X
(1249) 	return child_responded;
2F88: 10       PUSH  X
2F89: 52 FB    MOV   A,[X-5]
2F8B: 7C 10 25 LCALL 0x1025
2F8E: 20       POP   X
(1250) }
2F8F: 10       PUSH  X
2F90: 52 FA    MOV   A,[X-6]
2F92: 7C 10 25 LCALL 0x1025
2F95: 20       POP   X
(1251) 
2F96: 10       PUSH  X
2F97: 52 00    MOV   A,[X+0]
2F99: 7C 10 25 LCALL 0x1025
2F9C: 20       POP   X
(1252) // This function is used to find the servo that is directly connected to this module's controller.
2F9D: 80 39    JMP   0x2FD7
(1253) // After the servo ID is found, the status return level is changed so that packets are only
(1254) // returned for the desired status return level defined at the top of this file.
(1255) void servoFinder(void)
2F9F: 10       PUSH  X
2FA0: 50 FF    MOV   A,255
2FA2: 7C 10 25 LCALL 0x1025
2FA5: 20       POP   X
(1256) {				
2FA6: 10       PUSH  X
2FA7: 50 FF    MOV   A,255
2FA9: 7C 10 25 LCALL 0x1025
2FAC: 20       POP   X
(1257) 	// Index variables for incrementing and checking against the maximum servo comm attempts.
2FAD: 10       PUSH  X
2FAE: 52 FC    MOV   A,[X-4]
2FB0: 7C 10 25 LCALL 0x1025
2FB3: 20       POP   X
(1258) 	int i = 0;
2FB4: 10       PUSH  X
2FB5: 52 FB    MOV   A,[X-5]
2FB7: 7C 10 25 LCALL 0x1025
2FBA: 20       POP   X
(1259) 	int j = 0;
2FBB: 10       PUSH  X
2FBC: 52 FA    MOV   A,[X-6]
2FBE: 7C 10 25 LCALL 0x1025
2FC1: 20       POP   X
(1260) 	
2FC2: 10       PUSH  X
2FC3: 52 F9    MOV   A,[X-7]
2FC5: 7C 10 25 LCALL 0x1025
2FC8: 20       POP   X
(1261) 	int total_attempts = 0;
2FC9: 10       PUSH  X
2FCA: 52 F8    MOV   A,[X-8]
2FCC: 7C 10 25 LCALL 0x1025
2FCF: 20       POP   X
(1262) 	
2FD0: 10       PUSH  X
2FD1: 52 00    MOV   A,[X+0]
2FD3: 7C 10 25 LCALL 0x1025
2FD6: 20       POP   X
(1263) 	// Integer used as a flag so that EEPROM writes aren't done more than once.
(1264) 	int flashWrite = 0;
(1265) 	
(1266) 	// Create a status return level variable and set it to an out of range value initially.
2FD7: 10       PUSH  X
2FD8: 7C 0F F8 LCALL 0x0FF8
2FDB: 62 D0 00 MOV   REG[208],0
2FDE: 20       POP   X
2FDF: 53 CD    MOV   [__r0],A
2FE1: 47 CD 20 TST   [__r0],32
2FE4: AF F2    JZ    0x2FD7
(1267) 	char status_return_level = 3;
(1268) 	
(1269) 	// Start with a servo ID of 255 (out of valid range).
2FE6: 90 0F    CALL  _xmitWait
(1270) 	SERVO_ID = SERVO_START;
(1271) 
(1272) 	// This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
2FE8: 50 00    MOV   A,0
2FEA: 08       PUSH  A
2FEB: 50 08    MOV   A,8
2FED: 08       PUSH  A
2FEE: 7C 21 18 LCALL _configToggle
2FF1: 38 FE    ADD   SP,254
2FF3: 38 FF    ADD   SP,255
2FF5: 20       POP   X
2FF6: 7F       RET   
(1273) 	// number of times in each loop (unless stopped short due to early success). If this fails for the
(1274) 	// first round of pings, a broadcast reset will be performed to reset the servo. This is done
(1275) 	// because we assume that the baud rate is matching up, but the servo's return delay time is too
(1276) 	// fast for the controller to switch into receive mode to read the response. The default return
(1277) 	// delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
(1278) 	// see anything, we assume that there is something is too wrong for us to fix.
_xmitWait:
  i                    --> X+0
2FF7: 10       PUSH  X
2FF8: 4F       MOV   X,SP
2FF9: 38 02    ADD   SP,2
(1279) 	for(j = 0; j < SERVO_COMM_LOOPS; j++)
(1280) 	{	
(1281) 		// Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
2FFB: 56 01 00 MOV   [X+1],0
2FFE: 56 00 00 MOV   [X+0],0
3001: 77 01    INC   [X+1]
3003: 0F 00 00 ADC   [X+0],0
3006: 52 01    MOV   A,[X+1]
3008: 11 19    SUB   A,25
300A: 52 00    MOV   A,[X+0]
300C: 31 80    XOR   A,128
300E: 19 80    SBB   A,128
3010: CF F0    JC    0x3001
3012: 38 FE    ADD   SP,254
3014: 20       POP   X
3015: 7F       RET   
(1282) 		for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1283) 		{
(1284) 			// Send a ping out for any servo connected to me (will only be one).
(1285) 			servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
(1286) 			
(1287) 			total_attempts++;
(1288) 			
(1289) 			// Wait for either a timeout or a valid servo ID (which will trigger a timeout).
(1290) 			while(!TIMEOUT)
(1291) 			{	
(1292) 				if(commandReady())
_servoBootWait:
  i                    --> X+0
3016: 10       PUSH  X
3017: 4F       MOV   X,SP
3018: 38 02    ADD   SP,2
(1293) 				{
301A: 56 01 00 MOV   [X+1],0
301D: 56 00 00 MOV   [X+0],0
(1294) 					// If we read a source ID within the range, exit the loop.
(1295) 					if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
3020: 50 00    MOV   A,0
3022: 08       PUSH  A
3023: 50 08    MOV   A,8
3025: 08       PUSH  A
3026: 7C 21 18 LCALL _configToggle
3029: 38 FE    ADD   SP,254
(1296) 					{	
(1297) 						// Exit this while loop by setting the timeout flag.
(1298) 						TIMEOUT = 1;
302B: 56 01 00 MOV   [X+1],0
302E: 56 00 00 MOV   [X+0],0
(1299) 						// Set the servo ID variable to where the ping came from.
(1300) 						SERVO_ID = COMMAND_SOURCE;
3031: 62 D0 00 MOV   REG[208],0
3034: 3C D2 00 CMP   [TIMEOUT],0
3037: B0 06    JNZ   0x303E
3039: 3C D3 00 CMP   [TIMEOUT+1],0
303C: AF F4    JZ    0x3031
(1301) 						// Set the index variable such that the for loop exits.
303E: 62 D0 00 MOV   REG[208],0
3041: 55 D3 00 MOV   [TIMEOUT+1],0
3044: 55 D2 00 MOV   [TIMEOUT],0
3047: 77 01    INC   [X+1]
3049: 0F 00 00 ADC   [X+0],0
304C: 52 01    MOV   A,[X+1]
304E: 11 4B    SUB   A,75
3050: 52 00    MOV   A,[X+0]
3052: 31 80    XOR   A,128
3054: 19 80    SBB   A,128
3056: CF DA    JC    0x3031
(1302) 						i = SERVO_COMM_ATTEMPTS;
(1303) 						// Set the outer index variable to 2 to not attempt again for no reason.
(1304) 						j = SERVO_COMM_LOOPS;
3058: 10       PUSH  X
3059: 7C 12 0F LCALL 0x120F
305C: 20       POP   X
(1305) 					}
305D: 62 D0 00 MOV   REG[208],0
3060: 55 D3 00 MOV   [TIMEOUT+1],0
3063: 55 D2 00 MOV   [TIMEOUT],0
3066: 38 FE    ADD   SP,254
3068: 20       POP   X
3069: 7F       RET   
(1306) 					else
(1307) 					{
(1308) 						// Exit this while loop and try to ping again.
(1309) 						TIMEOUT = 1;
(1310) 					}
(1311) 				}
_servoConfigWait:
  i                    --> X+0
306A: 10       PUSH  X
306B: 4F       MOV   X,SP
306C: 38 02    ADD   SP,2
(1312) 			}
306E: 56 01 00 MOV   [X+1],0
3071: 56 00 00 MOV   [X+0],0
(1313) 		}
(1314) 		
3074: 50 00    MOV   A,0
3076: 08       PUSH  A
3077: 50 08    MOV   A,8
3079: 08       PUSH  A
307A: 7C 21 18 LCALL _configToggle
307D: 38 FE    ADD   SP,254
(1315) 		// If we didn't get a response and haven't written to the flash of the
(1316) 		// servo (first time through), send out a broadcast reset.
(1317) 		if((SERVO_ID == SERVO_START) && (!flashWrite))
(1318) 		{
(1319) 			// Set the flash write flag so that we only do this once per power cycle.
307F: 56 01 00 MOV   [X+1],0
3082: 56 00 00 MOV   [X+0],0
(1320) 			flashWrite = 1;
(1321) 			
3085: 62 D0 00 MOV   REG[208],0
3088: 3C D2 00 CMP   [TIMEOUT],0
308B: B0 06    JNZ   0x3092
308D: 3C D3 00 CMP   [TIMEOUT+1],0
3090: AF F4    JZ    0x3085
(1322) 			// Send out a broadcast reset so that we know that the response time interval
3092: 62 D0 00 MOV   REG[208],0
3095: 55 D3 00 MOV   [TIMEOUT+1],0
3098: 55 D2 00 MOV   [TIMEOUT],0
309B: 77 01    INC   [X+1]
309D: 0F 00 00 ADC   [X+0],0
30A0: 52 01    MOV   A,[X+1]
30A2: 11 14    SUB   A,20
30A4: 52 00    MOV   A,[X+0]
30A6: 31 80    XOR   A,128
30A8: 19 80    SBB   A,128
30AA: CF DA    JC    0x3085
(1323) 			// is large enough (default delay time for a servo is 500 microseconds).
(1324) 			servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
(1325) 		}
30AC: 10       PUSH  X
30AD: 7C 12 0F LCALL 0x120F
30B0: 20       POP   X
(1326) 	}
30B1: 62 D0 00 MOV   REG[208],0
30B4: 55 D3 00 MOV   [TIMEOUT+1],0
30B7: 55 D2 00 MOV   [TIMEOUT],0
(1327) 
(1328) 	// Reset flash write flag.
30BA: 50 00    MOV   A,0
30BC: 08       PUSH  A
30BD: 50 01    MOV   A,1
30BF: 08       PUSH  A
30C0: 7C 21 18 LCALL _configToggle
30C3: 38 FE    ADD   SP,254
30C5: 38 FE    ADD   SP,254
30C7: 20       POP   X
30C8: 7F       RET   
(1329) 	flashWrite = 0;
(1330) 	
(1331) 	// If we have a valid servo ID, set the status return level. If we don't, just skip this
(1332) 	// because all hope is lost.
(1333) 	if(SERVO_ID < BROADCAST)
(1334) 	{
(1335) 		// This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
(1336) 		// return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
_TX_01234_TIMEOUT_ISR:
30C9: 71 C0    OR    F,192
30CB: 08       PUSH  A
30CC: 5D D0    MOV   A,REG[208]
30CE: 08       PUSH  A
(1337) 		// to early success). If this fails for the first iteration, or we read a status return level
30CF: 62 D0 00 MOV   REG[208],0
30D2: 55 D3 01 MOV   [TIMEOUT+1],1
30D5: 55 D2 00 MOV   [TIMEOUT],0
(1338) 		// other than what we want, we will attempt to write the desired status return level onto the servo.
30D8: 62 DA FD MOV   REG[218],253
30DB: 18       POP   A
30DC: 60 D0    MOV   REG[208],A
30DE: 18       POP   A
30DF: 7E       RETI  
(1339) 		for(j = 0; j < SERVO_COMM_LOOPS; j++)
(1340) 		{
(1341) 			// Attempt to read the status return level for the defined number of attempts.
(1342) 			for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1343) 			{
_HELLO_TIMEOUT_ISR:
30E0: 71 C0    OR    F,192
30E2: 08       PUSH  A
30E3: 5D D0    MOV   A,REG[208]
30E5: 08       PUSH  A
(1344) 				// Send a request for the servo's status return level.
30E6: 62 D0 00 MOV   REG[208],0
30E9: 55 D3 01 MOV   [TIMEOUT+1],1
30EC: 55 D2 00 MOV   [TIMEOUT],0
(1345) 				servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
30EF: 62 DA FD MOV   REG[218],253
30F2: 18       POP   A
30F3: 60 D0    MOV   REG[208],A
30F5: 18       POP   A
30F6: 7E       RETI  
(1346) 				
(1347) 				// Wait for either a timeout or an indication that we want to exit the loop.
(1348) 				while(!TIMEOUT)
(1349) 				{
(1350) 					// If a valid command is ready, interpret it.
_CHILD_1_TIMEOUT_ISR:
30F7: 71 C0    OR    F,192
30F9: 08       PUSH  A
30FA: 5D D0    MOV   A,REG[208]
30FC: 08       PUSH  A
(1351) 					if(commandReady())
30FD: 62 D0 00 MOV   REG[208],0
3100: 55 D3 01 MOV   [TIMEOUT+1],1
3103: 55 D2 00 MOV   [TIMEOUT],0
(1352) 					{
3106: 62 DA FD MOV   REG[218],253
3109: 18       POP   A
310A: 60 D0    MOV   REG[208],A
310C: 18       POP   A
310D: 7E       RETI  
(1353) 						if(!COMMAND_ERROR)
(1354) 						{
(1355) 							// If the return level is equal to what is desired, store it.
(1356) 							if(COMMAND_PARAM == STATUS_RET_LEVEL)
_CHILD_2_TIMEOUT_ISR:
310E: 71 C0    OR    F,192
3110: 08       PUSH  A
3111: 5D D0    MOV   A,REG[208]
3113: 08       PUSH  A
(1357) 							{
3114: 62 D0 00 MOV   REG[208],0
3117: 55 D3 01 MOV   [TIMEOUT+1],1
311A: 55 D2 00 MOV   [TIMEOUT],0
(1358) 								// Set the timeout flag to exit the loop.
311D: 62 DA FD MOV   REG[218],253
3120: 18       POP   A
3121: 60 D0    MOV   REG[208],A
3123: 18       POP   A
3124: 7E       RETI  
(1359) 								TIMEOUT = 1;
(1360) 								// Store the status return level.
(1361) 								status_return_level = COMMAND_PARAM;
(1362) 								// Set i so that we exit the for loop.
_CHILD_3_TIMEOUT_ISR:
3125: 71 C0    OR    F,192
3127: 08       PUSH  A
3128: 5D D0    MOV   A,REG[208]
312A: 08       PUSH  A
(1363) 								i = SERVO_COMM_ATTEMPTS;
312B: 62 D0 00 MOV   REG[208],0
312E: 55 D3 01 MOV   [TIMEOUT+1],1
3131: 55 D2 00 MOV   [TIMEOUT],0
(1364) 								// Set the outer loop's variable so that we don't loop again.
3134: 62 DA FD MOV   REG[218],253
3137: 18       POP   A
3138: 60 D0    MOV   REG[208],A
313A: 18       POP   A
313B: 7E       RETI  
(1365) 								j = SERVO_COMM_LOOPS;
(1366) 							}
(1367) 							else
(1368) 							{	
_CHILD_4_TIMEOUT_ISR:
313C: 71 C0    OR    F,192
313E: 08       PUSH  A
313F: 5D D0    MOV   A,REG[208]
3141: 08       PUSH  A
(1369) 								// Set the timeout flag to exit the loop.
3142: 62 D0 00 MOV   REG[208],0
3145: 55 D3 01 MOV   [TIMEOUT+1],1
3148: 55 D2 00 MOV   [TIMEOUT],0
(1370) 								TIMEOUT = 1;
314B: 62 DA FD MOV   REG[218],253
314E: 18       POP   A
314F: 60 D0    MOV   REG[208],A
3151: 18       POP   A
3152: 7E       RETI  
(1371) 							}
(1372) 						}
(1373) 					}
(1374) 				}
_INIT_TIMEOUT_ISR:
3153: 71 C0    OR    F,192
3155: 08       PUSH  A
3156: 5D D0    MOV   A,REG[208]
3158: 08       PUSH  A
(1375) 			}
3159: 62 D0 00 MOV   REG[208],0
315C: 55 D3 01 MOV   [TIMEOUT+1],1
315F: 55 D2 00 MOV   [TIMEOUT],0
(1376) 		
3162: 62 DA FD MOV   REG[218],253
3165: 18       POP   A
3166: 60 D0    MOV   REG[208],A
3168: 18       POP   A
3169: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_revolute_evalINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_9
                                   (0022) 
                                   (0023) 
                                   (0024) Dispatch_INTERRUPT_10:
316A: 08       PUSH  A             (0025) 	push	a
316B: 50 00    MOV   A,0           (0026) 	mov		a,0
316D: 47 04 02 TST   [4],2         (0027) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3170: B0 3D    JNZ   0x31AE        (0028) 	jnz		Dispatch_INTERRUPT_10_END
3172: 50 04    MOV   A,4           (0029) 	mov		a,4
3174: 47 04 04 TST   [4],4         (0030) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
3177: B0 36    JNZ   0x31AE        (0031) 	jnz		Dispatch_INTERRUPT_10_END
3179: 50 08    MOV   A,8           (0032) 	mov		a,8
317B: 47 04 08 TST   [4],8         (0033) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
317E: B0 2F    JNZ   0x31AE        (0034) 	jnz		Dispatch_INTERRUPT_10_END
3180: 50 0C    MOV   A,12          (0035) 	mov		a,12
3182: 47 04 10 TST   [4],16        (0036) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
3185: B0 28    JNZ   0x31AE        (0037) 	jnz		Dispatch_INTERRUPT_10_END
3187: 50 10    MOV   A,16          (0038) 	mov		a,16
3189: 47 04 20 TST   [4],32        (0039) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
318C: B0 21    JNZ   0x31AE        (0040) 	jnz		Dispatch_INTERRUPT_10_END
318E: 50 14    MOV   A,20          (0041) 	mov		a,20
3190: 47 04 40 TST   [4],64        (0042) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
3193: B0 1A    JNZ   0x31AE        (0043) 	jnz		Dispatch_INTERRUPT_10_END
3195: 50 18    MOV   A,24          (0044) 	mov		a,24
3197: 47 04 80 TST   [4],128       (0045) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
319A: B0 13    JNZ   0x31AE        (0046) 	jnz		Dispatch_INTERRUPT_10_END
319C: 50 1C    MOV   A,28          (0047) 	mov		a,28
319E: 47 05 01 TST   [5],1         (0048) 	tst		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
31A1: B0 0C    JNZ   0x31AE        (0049) 	jnz		Dispatch_INTERRUPT_10_END
31A3: 50 20    MOV   A,32          (0050) 	mov		a,32
31A5: 47 04 01 TST   [4],1         (0051) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
31A8: B0 05    JNZ   0x31AE        (0052) 	jnz		Dispatch_INTERRUPT_10_END
31AA: 18       POP   A             (0053) 	pop		a
31AB: 7E       RETI                (0054) 	reti
                                   (0055) ; Stop Code Compressor from breaking table alignment
                                   (0056) ; The next instruction does not get executed.
31AC: 71 00    OR    F,0           (0057) 	Suspend_CodeCompressor
                                   (0058) Dispatch_INTERRUPT_10_END:
31AE: E0 01    JACC  0x31B0        (0059) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0060) Dispatch_INTERRUPT_10_TBL:
31B0: 18       POP   A             (0061) 	pop		a
31B1: 7D 18 27 LJMP  0x1827        (0062) 	ljmp	_HELLO_1_ISR
31B4: 18       POP   A             (0063) 	pop		a
31B5: 7D 12 63 LJMP  0x1263        (0064) 	ljmp	_INIT_RX_ISR
31B8: 18       POP   A             (0065) 	pop		a
31B9: 7D 0D BF LJMP  0x0DBF        (0066) 	ljmp	_TX_23_ISR
31BC: 18       POP   A             (0067) 	pop		a
31BD: 7D 1E AB LJMP  0x1EAB        (0068) 	ljmp	_CHILD_1_ISR
31C0: 18       POP   A             (0069) 	pop		a
31C1: 7D 1C F2 LJMP  0x1CF2        (0070) 	ljmp	_CHILD_2_ISR
31C4: 18       POP   A             (0071) 	pop		a
31C5: 7D 1B 39 LJMP  0x1B39        (0072) 	ljmp	_CHILD_3_ISR
31C8: 18       POP   A             (0073) 	pop		a
31C9: 7D 19 80 LJMP  0x1980        (0074) 	ljmp	_CHILD_4_ISR
31CC: 18       POP   A             (0075) 	pop		a
31CD: 7D 0F D1 LJMP  0x0FD1        (0076) 	ljmp	_SERVO_TX_ISR
31D0: 18       POP   A             (0077) 	pop		a
31D1: 7D 0C 66 LJMP  0x0C66        (0078) 	ljmp	_WAIT_RECV_ISR
                                   (0079) ; Resume Code Compressor.
                                   (0080) ; The next instruction does not get executed.
31D4: 38 00    ADD   SP,0          (0081) 	Resume_CodeCompressor
                                   (0082) 
                                   (0083) Dispatch_INTERRUPT_11:
31D6: 08       PUSH  A             (0084) 	push	a
31D7: 50 00    MOV   A,0           (0085) 	mov		a,0
31D9: 47 04 02 TST   [4],2         (0086) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
31DC: B0 13    JNZ   0x31F0        (0087) 	jnz		Dispatch_INTERRUPT_11_END
31DE: 50 04    MOV   A,4           (0088) 	mov		a,4
31E0: 47 04 08 TST   [4],8         (0089) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
31E3: B0 0C    JNZ   0x31F0        (0090) 	jnz		Dispatch_INTERRUPT_11_END
31E5: 50 08    MOV   A,8           (0091) 	mov		a,8
31E7: 47 04 01 TST   [4],1         (0092) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
31EA: B0 05    JNZ   0x31F0        (0093) 	jnz		Dispatch_INTERRUPT_11_END
31EC: 18       POP   A             (0094) 	pop		a
31ED: 7E       RETI                (0095) 	reti
                                   (0096) ; Stop Code Compressor from breaking table alignment
                                   (0097) ; The next instruction does not get executed.
31EE: 71 00    OR    F,0           (0098) 	Suspend_CodeCompressor
                                   (0099) Dispatch_INTERRUPT_11_END:
31F0: E0 01    JACC  0x31F2        (0100) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0101) Dispatch_INTERRUPT_11_TBL:
31F2: 18       POP   A             (0102) 	pop		a
31F3: 7D 16 CE LJMP  0x16CE        (0103) 	ljmp	_HELLO_2_ISR
31F6: 18       POP   A             (0104) 	pop		a
31F7: 7D 0E 98 LJMP  0x0E98        (0105) 	ljmp	_TX_014_ISR
31FA: 18       POP   A             (0106) 	pop		a
31FB: 7D 10 AA LJMP  0x10AA        (0107) 	ljmp	_RX8_2_ISR
                                   (0108) ; Resume Code Compressor.
                                   (0109) ; The next instruction does not get executed.
31FE: 38 00    ADD   SP,0          (0110) 	Resume_CodeCompressor
                                   (0111) 
                                   (0112) Dispatch_INTERRUPT_9:
3200: 08       PUSH  A             (0113) 	push	a
3201: 50 00    MOV   A,0           (0114) 	mov		a,0
3203: 47 04 02 TST   [4],2         (0115) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3206: B0 2F    JNZ   0x3236        (0116) 	jnz		Dispatch_INTERRUPT_9_END
3208: 50 04    MOV   A,4           (0117) 	mov		a,4
320A: 47 04 04 TST   [4],4         (0118) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
320D: B0 28    JNZ   0x3236        (0119) 	jnz		Dispatch_INTERRUPT_9_END
320F: 50 08    MOV   A,8           (0120) 	mov		a,8
3211: 47 04 08 TST   [4],8         (0121) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3214: B0 21    JNZ   0x3236        (0122) 	jnz		Dispatch_INTERRUPT_9_END
3216: 50 0C    MOV   A,12          (0123) 	mov		a,12
3218: 47 04 10 TST   [4],16        (0124) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
321B: B0 1A    JNZ   0x3236        (0125) 	jnz		Dispatch_INTERRUPT_9_END
321D: 50 10    MOV   A,16          (0126) 	mov		a,16
321F: 47 04 20 TST   [4],32        (0127) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
3222: B0 13    JNZ   0x3236        (0128) 	jnz		Dispatch_INTERRUPT_9_END
3224: 50 14    MOV   A,20          (0129) 	mov		a,20
3226: 47 04 40 TST   [4],64        (0130) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
3229: B0 0C    JNZ   0x3236        (0131) 	jnz		Dispatch_INTERRUPT_9_END
322B: 50 18    MOV   A,24          (0132) 	mov		a,24
322D: 47 04 80 TST   [4],128       (0133) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
3230: B0 05    JNZ   0x3236        (0134) 	jnz		Dispatch_INTERRUPT_9_END
3232: 18       POP   A             (0135) 	pop		a
3233: 7E       RETI                (0136) 	reti
                                   (0137) ; Stop Code Compressor from breaking table alignment
                                   (0138) ; The next instruction does not get executed.
3234: 71 00    OR    F,0           (0139) 	Suspend_CodeCompressor
                                   (0140) Dispatch_INTERRUPT_9_END:
3236: E0 01    JACC  0x3238        (0141) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0142) Dispatch_INTERRUPT_9_TBL:
3238: 18       POP   A             (0143) 	pop		a
3239: 7D 30 E0 LJMP  _HELLO_TIMEOUT_ISR(0144) 	ljmp	_HELLO_TIMEOUT_ISR
323C: 18       POP   A             (0145) 	pop		a
323D: 7D 31 53 LJMP  _INIT_TIMEOUT_ISR(0146) 	ljmp	_INIT_TIMEOUT_ISR
3240: 18       POP   A             (0147) 	pop		a
3241: 7D 30 C9 LJMP  _TX_01234_TIMEOUT_ISR(0148) 	ljmp	_TX_01234_TIMEOUT_ISR
3244: 18       POP   A             (0149) 	pop		a
3245: 7D 30 F7 LJMP  _CHILD_1_TIMEOUT_ISR(0150) 	ljmp	_CHILD_1_TIMEOUT_ISR
3248: 18       POP   A             (0151) 	pop		a
3249: 7D 31 0E LJMP  _CHILD_2_TIMEOUT_ISR(0152) 	ljmp	_CHILD_2_TIMEOUT_ISR
324C: 18       POP   A             (0153) 	pop		a
324D: 7D 31 25 LJMP  _CHILD_3_TIMEOUT_ISR(0154) 	ljmp	_CHILD_3_TIMEOUT_ISR
3250: 18       POP   A             (0155) 	pop		a
3251: 7D 31 3C LJMP  _CHILD_4_TIMEOUT_ISR(0156) 	ljmp	_CHILD_4_TIMEOUT_ISR
                                   (0157) ; Resume Code Compressor.
                                   (0158) ; The next instruction does not get executed.
                                   (0159) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01

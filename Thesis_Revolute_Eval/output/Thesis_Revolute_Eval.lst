0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0116) ; Generated by PSoC Designer 5.0.985.0
                                   (0117) ;
                                   (0118) ;@Id: boot.tpl#895 @
0004: 30       HALT                (0119) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0120) ;  FILENAME:   boot.asm
                                   (0121) ;  VERSION:    4.18
                                   (0122) ;  DATE:       28 June 2007
0008: 7E       RETI                (0123) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0124) ;  DESCRIPTION:
                                   (0125) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0126) ;
000C: 7E       RETI                (0127) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0128) ;
                                   (0129) ; NOTES:
                                   (0130) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0131) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0132) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0133) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0134) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0135) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0136) ;
                                   (0137) ;=============================================================================
                                   (0138) 
0018: 7E       RETI                (0139) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0140) include "m8c.inc"			;Part specific file
                                   (0141) include "m8ssc.inc"			;Part specific file
                                   (0142) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0143) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0144) ;--------------------------------------
                                   (0145) ; Export Declarations
                                   (0146) ;--------------------------------------
0020: 7E       RETI                (0147) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0148) export __Start
                                   (0149) IF	(TOOLCHAIN & HITECH)
0024: 7D 33 50 LJMP  Dispatch_INTERRUPT_9(0150) ELSE
0027: 7E       RETI                (0151) export __bss_start
                                   (0152) export __data_start
                                   (0153) export __idata_start
0028: 7D 32 BA LJMP  Dispatch_INTERRUPT_10(0154) export __func_lit_start
002B: 7E       RETI                (0155) export __text_start
                                   (0156) ENDIF
                                   (0157) export  _bGetPowerSetting
002C: 7D 33 26 LJMP  Dispatch_INTERRUPT_11(0158) export   bGetPowerSetting
002F: 7E       RETI                (0159) 
                                   (0160) 
                                   (0161) ;--------------------------------------
                                   (0162) ; Optimization flags
0030: 7E       RETI                (0163) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0164) ;
                                   (0165) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0166) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0167) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0168) 
                                   (0169) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 16 15 LJMP  0x1615        (0170) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0171) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0172) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0173) ;
003C: 7D 14 BC LJMP  0x14BC        (0174) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0175) ; The C compiler will customize the startup code - it's not required here
                                   (0176) 
                                   (0177) C_LANGUAGE_SUPPORT:              equ 0
                                   (0178) ELSE
0040: 7E       RETI                (0179) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0180) ENDIF
                                   (0181) 
                                   (0182) 
0044: 7E       RETI                (0183) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0184) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0185) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0186) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0187) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0188) ;
                                   (0189) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0190) ;                invoking main
004C: 7E       RETI                (0191) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0192) ;               the time code in main starts executing.
                                   (0193) ;
                                   (0194) WAIT_FOR_32K:                    equ 1
0050: 7E       RETI                (0195) 
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0196) 
                                   (0197) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0198) ; to invoke the user's _main code. If _main executes a return instruction,
0054: 7E       RETI                (0199) ; boot provides an infinite loop. By changing the following equate from zero
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0200) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0201) ; bytes on the stack which are otherwise required for the return address. If
                                   (0202) ; this option is enabled, _main must not return. (Beginning with the 4.2
0058: 7E       RETI                (0203) ; release, the C compiler automatically places an infinite loop at the end
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0204) ; of main, rather than a return instruction.)
                                   (0205) ;
                                   (0206) ENABLE_LJMP_TO_MAIN:             equ 0
005C: 7E       RETI                (0207) 
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0208) 
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ; Interrupt Vector Table
0060: 7E       RETI                (0211) ;-----------------------------------------------------------------------------
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0212) ;
                                   (0213) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0214) ; a jump instruction to an ISR (Interrupt Service Routine), although
0064: 7E       RETI                (0215) ; very short ISRs could be encoded within the table itself. Normally,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0216) ; vector jump targets are modified automatically according to the user
                                   (0217) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0218) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0219) ; configuration files. If you need to hard code a vector, update the
                                   (0220) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0221) ; of this file.
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) 
                                   (0224)     AREA TOP (ROM, ABS, CON)
                                   (0225) 
                                   (0226)     org   0                        ;Reset Interrupt Vector
                                   (0227) IF	(TOOLCHAIN & HITECH)
                                   (0228) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0229) ELSE
                                   (0230)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0231) ENDIF
                                   (0232) 
                                   (0233)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0234)     halt                           ;Stop execution if power falls too low
0068: 71 10    OR    F,16          (0235) 
006A: 62 FA 00 MOV   REG[250],0    (0236)     org   08h                      ;Analog Column 0 Interrupt Vector
006D: 62 E3 87 MOV   REG[227],135  (0237)     // call	void_handler
0070: 70 EF    AND   F,239         (0238)     reti
                                   (0239) 
                                   (0240)     org   0Ch                      ;Analog Column 1 Interrupt Vector
0072: 50 20    MOV   A,32          (0241)     // call	void_handler
0074: 28       ROMX                (0242)     reti
0075: 50 40    MOV   A,64          (0243) 
0077: 28       ROMX                (0244)     org   10h                      ;Analog Column 2 Interrupt Vector
0078: 50 60    MOV   A,96          (0245)     // call	void_handler
007A: 28       ROMX                (0246)     reti
                                   (0247) 
                                   (0248)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0249)     // call	void_handler
                                   (0250)     reti
                                   (0251) 
                                   (0252)     org   18h                      ;VC3 Interrupt Vector
                                   (0253)     // call	void_handler
                                   (0254)     reti
                                   (0255) 
007B: 41 FE FB AND   REG[254],251  (0256)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0257)     // call	void_handler
                                   (0258)     reti
                                   (0259) 
                                   (0260)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0261)     // call	void_handler
                                   (0262)     reti
                                   (0263) 
                                   (0264)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0265)     ljmp	Dispatch_INTERRUPT_9
007E: 50 80    MOV   A,128         (0266)     reti
0080: 4E       SWAP  SP,A          (0267) 
                                   (0268)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0269)     ljmp	Dispatch_INTERRUPT_10
                                   (0270)     reti
                                   (0271) 
                                   (0272)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0273)     ljmp	Dispatch_INTERRUPT_11
                                   (0274)     reti
                                   (0275) 
                                   (0276)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0277)     // call	void_handler
                                   (0278)     reti
                                   (0279) 
                                   (0280)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0281)     // call	void_handler
                                   (0282)     reti
                                   (0283) 
                                   (0284)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0285)     ljmp	_HELLO_3_ISR
                                   (0286)     reti
                                   (0287) 
                                   (0288)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0289)     ljmp	_HELLO_4_ISR
                                   (0290)     reti
                                   (0291) 
                                   (0292)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                   (0293)     // call	void_handler
                                   (0294)     reti
                                   (0295) 
                                   (0296)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0297)     // call	void_handler
0081: 55 F8 00 MOV   [248],0       (0298)     reti
0084: 55 F9 00 MOV   [249],0       (0299) 
                                   (0300)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                   (0301)     // call	void_handler
                                   (0302)     reti
                                   (0303) 
                                   (0304)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                   (0305)     // call	void_handler
                                   (0306)     reti
                                   (0307) 
                                   (0308)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                   (0309)     // call	void_handler
                                   (0310)     reti
                                   (0311) 
                                   (0312)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0313)     // call	void_handler
                                   (0314)     reti
                                   (0315) 
                                   (0316)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0317)     // call	void_handler
                                   (0318)     reti
                                   (0319) 
                                   (0320)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0321)     // call	void_handler
                                   (0322)     reti
0087: 71 10    OR    F,16          (0323) 
0089: 62 E0 02 MOV   REG[224],2    (0324)     org   60h                      ;PSoC I2C Interrupt Vector
008C: 70 EF    AND   F,239         (0325)     // call	void_handler
008E: 62 E3 38 MOV   REG[227],56   (0326)     reti
                                   (0327) 
                                   (0328)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0329)     // call	void_handler
                                   (0330)     reti
                                   (0331) 
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;  Start of Execution.
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0336) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0337) ;
                                   (0338) 
                                   (0339) IF	(TOOLCHAIN & HITECH)
                                   (0340)  	AREA PD_startup(CODE, REL, CON)
                                   (0341) ELSE
                                   (0342)     org 68h
                                   (0343) ENDIF
                                   (0344) __Start:
                                   (0345) 
                                   (0346)     ; initialize SMP values for voltage stabilization, if required,
                                   (0347)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0348)     ; least for now. 
                                   (0349)     ;
                                   (0350)     M8C_SetBank1
                                   (0351)     mov reg[0FAh], 0				;Reset flash location
                                   (0352)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0353)     M8C_SetBank0
                                   (0354) 
                                   (0355)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
                                   (0356)     mov   A, 20h
0091: 62 71 05 MOV   REG[113],5    (0357)     romx
0094: 62 75 05 MOV   REG[117],5    (0358)     mov   A, 40h
0097: 62 79 05 MOV   REG[121],5    (0359)     romx
009A: 62 7D 05 MOV   REG[125],5    (0360)     mov   A, 60h
                                   (0361)     romx
                                   (0362)     ; %45%20%46%46% End workaround
                                   (0363) 
                                   (0364) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0365)     M8C_EnableWatchDog
                                   (0366) ENDIF
                                   (0367) 
                                   (0368) IF ( SELECT_32K )
                                   (0369)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0370) ELSE
                                   (0371)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0372) ENDIF
                                   (0373) 
                                   (0374)     ;---------------------------
                                   (0375)     ; Set up the Temporary stack
                                   (0376)     ;---------------------------
                                   (0377)     ; A temporary stack is set up for the SSC instructions.
                                   (0378)     ; The real stack start will be assigned later.
                                   (0379)     ;
                                   (0380) _stack_start:          equ 80h
                                   (0381)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0382)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0383) 
                                   (0384)     ;-----------------------------------------------
                                   (0385)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0386)     ;-----------------------------------------------
                                   (0387) 
009D: 62 D1 07 MOV   REG[209],7    (0388) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00A0: 50 00    MOV   A,0           (0389)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00A2: 4E       SWAP  SP,A          (0390)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00A3: 62 D3 07 MOV   REG[211],7    (0391)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00A6: 62 D0 00 MOV   REG[208],0    (0392)  ELSE                                          ; *** 12MHZ Main Oscillator ***
00A9: 62 D5 00 MOV   REG[213],0    (0393)   IF ( AGND_BYPASS )
00AC: 62 D4 00 MOV   REG[212],0    (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0396)     ; bit in the write-only BDG_TR register. Recalculate the register
00AF: 71 C0    OR    F,192         (0397)     ; value using the proper trim values.
                                   (0398)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0399)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0400)   ENDIF
                                   (0401)  ENDIF
                                   (0402) ENDIF ; 5.0 V Operation
                                   (0403) 
                                   (0404) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0405)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0406)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0407)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0408)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0409)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0410)  ENDIF
                                   (0411) ENDIF ; 3.3 Volt Operation
                                   (0412) 
                                   (0413)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
                                   (0414)     mov  [bSSC_KEYSP], 0
00B1: 7C 06 96 LCALL 0x0696        (0415) 
                                   (0416)     ;---------------------------------------
                                   (0417)     ; Initialize Crystal Oscillator and PLL
                                   (0418)     ;---------------------------------------
                                   (0419) 
                                   (0420) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0421)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0422)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0423)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0424)     ; the ECO to stabilize.
                                   (0425)     ;
                                   (0426)     M8C_SetBank1
                                   (0427)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0428)     M8C_SetBank0
                                   (0429)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0430)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0431)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0432) .WaitFor1s:
                                   (0433)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0434)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0435)                                           ;   since interrupts are not globally enabled
                                   (0436) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0437)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0438)     M8C_SetBank1
                                   (0439)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0440)     M8C_SetBank0
                                   (0441)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0442) 
                                   (0443) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0444) 
                                   (0445) IF ( PLL_MODE )
                                   (0446)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
00B4: 62 D0 00 MOV   REG[208],0    (0447)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0448)     ;
                                   (0449)     M8C_SetBank1
                                   (0450)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0451)     M8C_SetBank0
                                   (0452)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0453)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
00B7: 50 06    MOV   A,6           (0454) 
00B9: 57 94    MOV   X,148         (0455) .WaitFor16ms:
00BB: 08       PUSH  A             (0456)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00BC: 28       ROMX                (0457)     jz   .WaitFor16ms
00BD: 53 CC    MOV   [__r0],A      (0458)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00BF: 18       POP   A             (0459)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00C0: 75       INC   X             (0460)     M8C_SetBank0
00C1: 09 00    ADC   A,0           (0461) 
00C3: 28       ROMX                (0462) IF      ( WAIT_FOR_32K )
00C4: 4B       SWAP  A,X           (0463) ELSE ; !( WAIT_FOR_32K )
00C5: 51 CC    MOV   A,[204]       (0464)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                   (0465)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
00C7: 80 04    JMP   0x00CC        (0466) ENDIF ;(WAIT_FOR_32K)
                                   (0467) ENDIF ;(PLL_MODE)
                                   (0468) 
                                   (0469)     ;------------------------
                                   (0470)     ; Close CT leakage path.
                                   (0471)     ;------------------------
                                   (0472)     mov   reg[ACB00CR0], 05h
                                   (0473)     mov   reg[ACB01CR0], 05h
                                   (0474)     mov   reg[ACB02CR0], 05h
                                   (0475)     mov   reg[ACB03CR0], 05h
                                   (0476) 
                                   (0477) 
                                   (0478) IF	(TOOLCHAIN & HITECH)
                                   (0479)     ;---------------------------------------------
                                   (0480)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0481)     ;---------------------------------------------
                                   (0482) 	global		__Lstackps
                                   (0483) 	mov     a,low __Lstackps
00C9: 75       INC   X             (0484) 	swap    a,sp
00CA: 09 00    ADC   A,0           (0485) 
                                   (0486) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0487)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0488)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0489)     RAM_SETPAGE_CUR 0
00CC: 62 E3 00 MOV   REG[227],0    (0490)     RAM_SETPAGE_MVW 0
00CF: 08       PUSH  A             (0491)     RAM_SETPAGE_MVR 0
00D0: 28       ROMX                (0492)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00D1: 60 D5    MOV   REG[213],A    (0493)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00D3: 74       INC   A             (0494)     ELSE
00D4: A0 4B    JZ    0x0120        (0495)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00D6: 18       POP   A             (0496)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00D7: 75       INC   X             (0497) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00D8: 09 00    ADC   A,0           (0498) ELSE
00DA: 08       PUSH  A             (0499)     ;---------------------------------------------
00DB: 28       ROMX                (0500)     ; ImageCraft Enter the Large Memory Model, if applicable
00DC: 53 CC    MOV   [__r0],A      (0501)     ;---------------------------------------------
00DE: 18       POP   A             (0502) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00DF: 75       INC   X             (0503)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00E0: 09 00    ADC   A,0           (0504)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00E2: 08       PUSH  A             (0505)     swap  A, SP
00E3: 28       ROMX                (0506)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00E4: A0 1C    JZ    0x0101        (0507)     RAM_SETPAGE_CUR 0
00E6: 53 CB    MOV   [__r1],A      (0508)     RAM_SETPAGE_MVW 0
00E8: 18       POP   A             (0509)     RAM_SETPAGE_MVR 0
                                   (0510) 
                                   (0511)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0512)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0513)   ELSE
                                   (0514)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0515)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0516) ELSE
00E9: 75       INC   X             (0517)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00EA: 09 00    ADC   A,0           (0518)     swap  SP, A
00EC: 08       PUSH  A             (0519) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00ED: 28       ROMX                (0520) ENDIF ;	TOOLCHAIN
00EE: 3F CC    MVI   [__r0],A      (0521) 
00F0: 47 CC FF TST   [204],255     (0522)     ;-------------------------
00F3: B0 06    JNZ   0x00FA        (0523)     ; Load Base Configuration
00F5: 5D D5    MOV   A,REG[213]    (0524)     ;-------------------------
00F7: 74       INC   A             (0525)     ; Load global parameter settings and load the user modules in the
00F8: 60 D5    MOV   REG[213],A    (0526)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0527)     ; to minimize start up time; (2) We may still need to play with the
00FA: 18       POP   A             (0528)     ; Sleep Timer.
00FB: 7A CB    DEC   [__r1]        (0529)     ;
00FD: BF EB    JNZ   0x00E9        (0530)     lcall LoadConfigInit
00FF: 8F C9    JMP   0x00C9        (0531) 
                                   (0532)     ;-----------------------------------
                                   (0533)     ; Initialize C Run-Time Environment
0101: 18       POP   A             (0534)     ;-----------------------------------
0102: 75       INC   X             (0535) IF ( C_LANGUAGE_SUPPORT )
0103: 09 00    ADC   A,0           (0536) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0105: 08       PUSH  A             (0537)     mov  A,0                           ; clear the 'bss' segment to zero
0106: 28       ROMX                (0538)     mov  [__r0],<__bss_start
0107: 53 CB    MOV   [__r1],A      (0539) BssLoop:
0109: 50 00    MOV   A,0           (0540)     cmp  [__r0],<__bss_end
                                   (0541)     jz   BssDone
                                   (0542)     mvi  [__r0],A
                                   (0543)     jmp  BssLoop
                                   (0544) BssDone:
                                   (0545)     mov  A,>__idata_start              ; copy idata to data segment
010B: 3F CC    MVI   [__r0],A      (0546)     mov  X,<__idata_start
010D: 47 CC FF TST   [204],255     (0547)     mov  [__r0],<__data_start
0110: B0 08    JNZ   0x0119        (0548) IDataLoop:
0112: 5D D5    MOV   A,REG[213]    (0549)     cmp  [__r0],<__data_end
0114: 74       INC   A             (0550)     jz   C_RTE_Done
0115: 60 D5    MOV   REG[213],A    (0551)     push A
0117: 50 00    MOV   A,0           (0552)     romx
                                   (0553)     mvi  [__r0],A
0119: 7A CB    DEC   [__r1]        (0554)     pop  A
011B: BF EF    JNZ   0x010B        (0555)     inc  X
011D: 18       POP   A             (0556)     adc  A,0
011E: 8F AA    JMP   0x00C9        (0557)     jmp  IDataLoop
                                   (0558) 
                                   (0559) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0120: 18       POP   A             (0560) 
                                   (0561) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0562)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0563)                                        ; to use the Virtual Register page.
                                   (0564) 
                                   (0565)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0566)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0567)     ; text segment and may have been relocated by the Code Compressor.
                                   (0568)     ;
                                   (0569)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0570)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0571)     push  A
                                   (0572)     romx                               ; get the MSB of xidata's address
                                   (0573)     mov   [__r0], A
                                   (0574)     pop   A
                                   (0575)     inc   X
                                   (0576)     adc   A, 0
                                   (0577)     romx                               ; get the LSB of xidata's address
                                   (0578)     swap  A, X
                                   (0579)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0580)                                        ;   XIData structure list in flash
                                   (0581)     jmp   .AccessStruct
                                   (0582) 
                                   (0583)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0584)     ; values of C variables. Each structure contains 3 member elements.
                                   (0585)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0586)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0587)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0588)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0589)     ; value in the second member element, an unsigned byte:
                                   (0590)     ; (1) If the value of the second element is non-zero, it represents
                                   (0591)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0592)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0593)     ; the bytes are copied to the block of RAM.
                                   (0594)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0595)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0596)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0597) 
                                   (0598) .AccessNextStructLoop:
                                   (0599)     inc   X                            ; pXIData++
                                   (0600)     adc   A, 0
0121: 71 10    OR    F,16          (0601) .AccessStruct:                         ; Entry point for first block
                                   (0602)     ;
                                   (0603)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0604)     ;
                                   (0605)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0606)     push  A
                                   (0607)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0608)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
0123: 43 E3 20 OR    REG[227],32   (0609)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0610)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0611)     pop   A                            ; restore pXIData to [A,X]
                                   (0612)     inc   X                            ; pXIData++
                                   (0613)     adc   A, 0
0126: 70 EF    AND   F,239         (0614)     push  A
                                   (0615)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0616)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0617)     pop   A                            ; restore pXIData to [A,X]
                                   (0618)     inc   X                            ; pXIData++ (point to size)
                                   (0619)     adc   A, 0
                                   (0620)     push  A
                                   (0621)     romx                               ; Get the size (CPU.A <- *pXIData)
                                   (0622)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
0128: 62 E0 00 MOV   REG[224],0    (0623)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0624)     pop   A                            ; restore pXIData to [A,X]
                                   (0625) 
                                   (0626) .CopyNextByteLoop:
                                   (0627)     ; For each byte in the structure's array member, copy from flash to RAM.
012B: 71 10    OR    F,16          (0628)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
012D: 62 E0 03 MOV   REG[224],3    (0629)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
0130: 43 E7 80 OR    REG[231],128  (0630)     ;         __r1 holds a non-zero count of the number of bytes remaining.
0133: 70 EF    AND   F,239         (0631)     ;
                                   (0632)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0633)     adc   A, 0
                                   (0634)     push  A
                                   (0635)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                   (0636)     mvi   [__r0], A                    ; Transfer the data to RAM
0135: 62 E2 00 MOV   REG[226],0    (0637)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0638)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0639)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0640)     inc   A
                                   (0641)     mov   reg[ MVW_PP], A
                                   (0642) .CopyLoopTail:
                                   (0643)     pop   A                            ; restore pXIData to [A,X]
                                   (0644)     dec   [__r1]                       ; End of this array in flash?
0138: 7C 21 04 LCALL _main         (0645)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0646)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
013B: 8F FF    JMP   0x013B        (0647) 
                                   (0648) .ClearRAMBlockToZero:
                                   (0649)     pop   A                            ; restore pXIData to [A,X]
                                   (0650)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0651)     adc   A, 0
                                   (0652)     push  A
                                   (0653)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0654)     mov   [__r1], A                    ; Initialize downcounter
                                   (0655)     mov   A, 0                         ; Initialize source data
                                   (0656) 
                                   (0657) .ClearRAMBlockLoop:
                                   (0658)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0659)     ;         __r1 holds a non-zero count of the number of bytes remaining.
013D: 50 10    MOV   A,16          (0660)     ;
0474: 71 10    OR    F,16          (0661)     mvi   [__r0], A                    ; Clear a byte

FILE: lib\psocconfigtbl.asm
0476: 62 00 1E MOV   REG[0],30     (0716) ; Generated by PSoC Designer 5.0.985.0
0479: 62 01 E1 MOV   REG[1],225    (0717) ;
047C: 70 EF    AND   F,239         (0718) include "m8c.inc"
047E: 62 03 E0 MOV   REG[3],224    (0719) ;  Personalization tables 
0481: 62 02 1F MOV   REG[2],31     (0720) export LoadConfigTBL_waiting_Bank1
0484: 71 10    OR    F,16          (0721) export LoadConfigTBL_waiting_Bank0
0486: 62 02 00 MOV   REG[2],0      (0722) export LoadConfigTBL_waiting_Ordered
0489: 62 03 00 MOV   REG[3],0      (0723) export UnloadConfigTBL_waiting_Bank1
048C: 70 EF    AND   F,239         (0724) export UnloadConfigTBL_waiting_Bank0
048E: 62 01 00 MOV   REG[1],0      (0725) export ReloadConfigTBL_waiting_Bank1
0491: 71 10    OR    F,16          (0726) export ReloadConfigTBL_waiting_Bank0
0493: 62 04 A8 MOV   REG[4],168    (0727) export LoadConfigTBL_hello_Bank1
0496: 62 05 57 MOV   REG[5],87     (0728) export LoadConfigTBL_hello_Bank0
0499: 70 EF    AND   F,239         (0729) export UnloadConfigTBL_hello_Bank1
049B: 62 07 57 MOV   REG[7],87     (0730) export UnloadConfigTBL_hello_Bank0
049E: 62 06 00 MOV   REG[6],0      (0731) export LoadConfigTBL_initial_Bank1
04A1: 71 10    OR    F,16          (0732) export LoadConfigTBL_initial_Bank0
04A3: 62 06 00 MOV   REG[6],0      (0733) export UnloadConfigTBL_initial_Bank1
04A6: 62 07 00 MOV   REG[7],0      (0734) export UnloadConfigTBL_initial_Bank0
04A9: 70 EF    AND   F,239         (0735) export LoadConfigTBL_my_response_Bank1
04AB: 62 05 00 MOV   REG[5],0      (0736) export LoadConfigTBL_my_response_Bank0
04AE: 71 10    OR    F,16          (0737) export UnloadConfigTBL_my_response_Bank1
04B0: 62 08 01 MOV   REG[8],1      (0738) export UnloadConfigTBL_my_response_Bank0
04B3: 62 09 FE MOV   REG[9],254    (0739) export LoadConfigTBL_response1_Bank1
04B6: 70 EF    AND   F,239         (0740) export LoadConfigTBL_response1_Bank0
04B8: 62 0B FE MOV   REG[11],254   (0741) export UnloadConfigTBL_response1_Bank1
04BB: 62 0A 00 MOV   REG[10],0     (0742) export UnloadConfigTBL_response1_Bank0
04BE: 71 10    OR    F,16          (0743) export LoadConfigTBL_response2_Bank1
04C0: 62 0A 00 MOV   REG[10],0     (0744) export LoadConfigTBL_response2_Bank0
04C3: 62 0B 00 MOV   REG[11],0     (0745) export UnloadConfigTBL_response2_Bank1
04C6: 70 EF    AND   F,239         (0746) export UnloadConfigTBL_response2_Bank0
04C8: 62 09 00 MOV   REG[9],0      (0747) export LoadConfigTBL_response3_Bank1
04CB: 71 10    OR    F,16          (0748) export LoadConfigTBL_response3_Bank0
04CD: 62 0C 00 MOV   REG[12],0     (0749) export UnloadConfigTBL_response3_Bank1
04D0: 62 0D 00 MOV   REG[13],0     (0750) export UnloadConfigTBL_response3_Bank0
04D3: 70 EF    AND   F,239         (0751) export LoadConfigTBL_response4_Bank1
04D5: 62 0F 00 MOV   REG[15],0     (0752) export LoadConfigTBL_response4_Bank0
04D8: 62 0E 00 MOV   REG[14],0     (0753) export UnloadConfigTBL_response4_Bank1
04DB: 71 10    OR    F,16          (0754) export UnloadConfigTBL_response4_Bank0
04DD: 62 0E 00 MOV   REG[14],0     (0755) export LoadConfigTBL_servo_transmit_Bank1
04E0: 62 0F 00 MOV   REG[15],0     (0756) export LoadConfigTBL_servo_transmit_Bank0
04E3: 70 EF    AND   F,239         (0757) export UnloadConfigTBL_servo_transmit_Bank1
04E5: 62 0D 00 MOV   REG[13],0     (0758) export UnloadConfigTBL_servo_transmit_Bank0
04E8: 71 10    OR    F,16          (0759) export UnloadConfigTBL_Total_Bank1
04EA: 62 10 00 MOV   REG[16],0     (0760) export UnloadConfigTBL_Total_Bank0
04ED: 62 11 00 MOV   REG[17],0     (0761) AREA lit(rom, rel)
04F0: 70 EF    AND   F,239         (0762) LoadConfigTBL_hello_Bank0:
04F2: 62 13 00 MOV   REG[19],0     (0763) ;  Instance name HELLO_1, User Module RX8
04F5: 62 12 00 MOV   REG[18],0     (0764) ;       Instance name HELLO_1, Block Name RX8(DCB02)
04F8: 71 10    OR    F,16          (0765) 	db		2bh, 00h		;HELLO_1_CONTROL_REG  (DCB02CR0)
04FA: 62 12 00 MOV   REG[18],0     (0766) 	db		29h, 00h		;HELLO_1_(DCB02DR1)
04FD: 62 13 00 MOV   REG[19],0     (0767) 	db		2ah, 00h		;HELLO_1_RX_BUFFER_REG(DCB02DR2)
0500: 70 EF    AND   F,239         (0768) ;  Instance name HELLO_2, User Module RX8
0502: 62 11 00 MOV   REG[17],0     (0769) ;       Instance name HELLO_2, Block Name RX8(DCB03)
0505: 71 10    OR    F,16          (0770) 	db		2fh, 00h		;HELLO_2_CONTROL_REG  (DCB03CR0)
0507: 62 14 00 MOV   REG[20],0     (0771) 	db		2dh, 00h		;HELLO_2_(DCB03DR1)
050A: 62 15 00 MOV   REG[21],0     (0772) 	db		2eh, 00h		;HELLO_2_RX_BUFFER_REG(DCB03DR2)
050D: 70 EF    AND   F,239         (0773) ;  Instance name HELLO_3, User Module RX8
050F: 62 17 00 MOV   REG[23],0     (0774) ;       Instance name HELLO_3, Block Name RX8(DCB12)
0512: 62 16 00 MOV   REG[22],0     (0775) 	db		3bh, 00h		;HELLO_3_CONTROL_REG  (DCB12CR0)
0515: 71 10    OR    F,16          (0776) 	db		39h, 00h		;HELLO_3_(DCB12DR1)
0517: 62 16 00 MOV   REG[22],0     (0777) 	db		3ah, 00h		;HELLO_3_RX_BUFFER_REG(DCB12DR2)
051A: 62 17 00 MOV   REG[23],0     (0778) ;  Instance name HELLO_4, User Module RX8
051D: 70 EF    AND   F,239         (0779) ;       Instance name HELLO_4, Block Name RX8(DCB13)
051F: 62 15 00 MOV   REG[21],0     (0780) 	db		3fh, 00h		;HELLO_4_CONTROL_REG  (DCB13CR0)
0522: 71 10    OR    F,16          (0781) 	db		3dh, 00h		;HELLO_4_(DCB13DR1)
0524: 62 18 00 MOV   REG[24],0     (0782) 	db		3eh, 00h		;HELLO_4_RX_BUFFER_REG(DCB13DR2)
0527: 62 19 00 MOV   REG[25],0     (0783) ;  Instance name HELLO_TIMEOUT, User Module Timer16
052A: 70 EF    AND   F,239         (0784) ;       Instance name HELLO_TIMEOUT, Block Name TIMER16_LSB(DBB00)
052C: 62 1B 00 MOV   REG[27],0     (0785) 	db		23h, 00h		;HELLO_TIMEOUT_CONTROL_LSB_REG(DBB00CR0)
052F: 62 1A 00 MOV   REG[26],0     (0786) 	db		21h, e0h		;HELLO_TIMEOUT_PERIOD_LSB_REG(DBB00DR1)
0532: 71 10    OR    F,16          (0787) 	db		22h, 00h		;HELLO_TIMEOUT_COMPARE_LSB_REG(DBB00DR2)
0534: 62 1A 00 MOV   REG[26],0     (0788) ;       Instance name HELLO_TIMEOUT, Block Name TIMER16_MSB(DBB01)
0537: 62 1B 00 MOV   REG[27],0     (0789) 	db		27h, 04h		;HELLO_TIMEOUT_CONTROL_MSB_REG(DBB01CR0)
053A: 70 EF    AND   F,239         (0790) 	db		25h, 01h		;HELLO_TIMEOUT_PERIOD_MSB_REG(DBB01DR1)
053C: 62 19 00 MOV   REG[25],0     (0791) 	db		26h, 00h		;HELLO_TIMEOUT_COMPARE_MSB_REG(DBB01DR2)
053F: 71 10    OR    F,16          (0792) 	db		ffh
0541: 62 1C 00 MOV   REG[28],0     (0793) LoadConfigTBL_hello_Bank1:
0544: 62 1D 00 MOV   REG[29],0     (0794) ;  Instance name HELLO_1, User Module RX8
0547: 70 EF    AND   F,239         (0795) ;       Instance name HELLO_1, Block Name RX8(DCB02)
0549: 62 1F 00 MOV   REG[31],0     (0796) 	db		28h, 05h		;HELLO_1_FUNC_REG     (DCB02FN)
054C: 62 1E 00 MOV   REG[30],0     (0797) 	db		29h, d1h		;HELLO_1_INPUT_REG    (DCB02IN)
054F: 71 10    OR    F,16          (0798) 	db		2ah, 80h		;HELLO_1_OUTPUT_REG   (DCB02OU)
0551: 62 1E 00 MOV   REG[30],0     (0799) ;  Instance name HELLO_2, User Module RX8
0554: 62 1F 00 MOV   REG[31],0     (0800) ;       Instance name HELLO_2, Block Name RX8(DCB03)
0557: 70 EF    AND   F,239         (0801) 	db		2ch, 05h		;HELLO_2_FUNC_REG     (DCB03FN)
0559: 62 1D 00 MOV   REG[29],0     (0802) 	db		2dh, e1h		;HELLO_2_INPUT_REG    (DCB03IN)
0696: 62 D0 00 MOV   REG[208],0    (0803) 	db		2eh, 80h		;HELLO_2_OUTPUT_REG   (DCB03OU)

FILE: lib\psocconfig.asm
0699: 55 04 00 MOV   [4],0         (0098) ; Generated by PSoC Designer 5.0.985.0
069C: 55 05 00 MOV   [5],0         (0099) ;
                                   (0100) INCLUDE "PSoCDynamic.inc"
069F: 7C 06 A6 LCALL 0x06A6        (0101) ;==========================================================================
06A2: 7C 04 74 LCALL 0x0474        (0102) ;  PSoCConfig.asm
                                   (0103) ;  @PSOC_VERSION
                                   (0104) ;
                                   (0105) ;  Version: 0.85
06A5: 7F       RET                 (0106) ;  Revised: June 22, 2004
                                   (0107) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0108) ;
                                   (0109) ;  This file is generated by the Device Editor on Application Generation.
                                   (0110) ;  It contains code which loads the configuration data table generated in
                                   (0111) ;  the file PSoCConfigTBL.asm
                                   (0112) ;
                                   (0113) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0114) ;  Edits to this file will not be preserved.
                                   (0115) ;==========================================================================
                                   (0116) ;
                                   (0117) include "m8c.inc"
                                   (0118) include "memory.inc"
                                   (0119) include "GlobalParams.inc"
                                   (0120) 
                                   (0121) export LoadConfigInit
                                   (0122) export _LoadConfigInit
                                   (0123) export LoadConfig_waiting
                                   (0124) export _LoadConfig_waiting
                                   (0125) export UnloadConfig_waiting
                                   (0126) export _UnloadConfig_waiting
                                   (0127) export ReloadConfig_waiting
                                   (0128) export _ReloadConfig_waiting
                                   (0129) export LoadConfig_hello
06A6: 71 10    OR    F,16          (0130) export _LoadConfig_hello
                                   (0131) export UnloadConfig_hello
06A8: 10       PUSH  X             (0132) export _UnloadConfig_hello
06A9: 70 EF    AND   F,239         (0133) export LoadConfig_initial
06AB: 50 00    MOV   A,0           (0134) export _LoadConfig_initial
06AD: 67       ASR   A             (0135) export UnloadConfig_initial
                                   (0136) export _UnloadConfig_initial
06AE: 50 03    MOV   A,3           (0137) export LoadConfig_my_response
06B0: 57 D0    MOV   X,208         (0138) export _LoadConfig_my_response
06B2: 7C 0C 66 LCALL 0x0C66        (0139) export UnloadConfig_my_response
                                   (0140) export _UnloadConfig_my_response
06B5: 50 01    MOV   A,1           (0141) export LoadConfig_response1
06B7: 67       ASR   A             (0142) export _LoadConfig_response1
                                   (0143) export UnloadConfig_response1
06B8: 50 04    MOV   A,4           (0144) export _UnloadConfig_response1
06BA: 57 37    MOV   X,55          (0145) export LoadConfig_response2
06BC: 7C 0C 66 LCALL 0x0C66        (0146) export _LoadConfig_response2
                                   (0147) export UnloadConfig_response2
06BF: 62 D0 00 MOV   REG[208],0    (0148) export _UnloadConfig_response2
                                   (0149) export LoadConfig_response3
06C2: 2E 04 01 OR    [4],1         (0150) export _LoadConfig_response3
06C5: 70 EF    AND   F,239         (0151) export UnloadConfig_response3
06C7: 20       POP   X             (0152) export _UnloadConfig_response3
                                   (0153) export LoadConfig_response4
                                   (0154) export _LoadConfig_response4
06C8: 7F       RET                 (0155) export UnloadConfig_response4
                                   (0156) export _UnloadConfig_response4
                                   (0157) export LoadConfig_servo_transmit
                                   (0158) export _LoadConfig_servo_transmit
                                   (0159) export UnloadConfig_servo_transmit
                                   (0160) export _UnloadConfig_servo_transmit
                                   (0161) export UnloadConfig_Total
                                   (0162) export _UnloadConfig_Total
                                   (0163) export ACTIVE_CONFIG_STATUS
                                   (0164) 
                                   (0165) export NO_SHADOW
                                   (0166) export _NO_SHADOW
                                   (0167) 
                                   (0168) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0169) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0170) 
                                   (0171) AREA psoc_config(rom, rel)
                                   (0172) 
                                   (0173) ;---------------------------------------------------------------------------
                                   (0174) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0175) ;                  parameters handled by boot code, like CPU speed). This
                                   (0176) ;                  function can be called from user code, but typically it
                                   (0177) ;                  is only called from boot.
                                   (0178) ;
                                   (0179) ;       INPUTS: None.
06C9: 10       PUSH  X             (0180) ;      RETURNS: Nothing.
06CA: 70 EF    AND   F,239         (0181) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
06CC: 50 00    MOV   A,0           (0182) ;               In the large memory model currently only the page
06CE: 67       ASR   A             (0183) ;               pointer registers listed below are modified.  This does
                                   (0184) ;               not guarantee that in future implementations of this
06CF: 50 05    MOV   A,5           (0185) ;               function other page pointer registers will not be
06D1: 57 5D    MOV   X,93          (0186) ;               modified.
06D3: 7C 0C 66 LCALL 0x0C66        (0187) ;          
                                   (0188) ;               Page Pointer Registers Modified: 
06D6: 50 01    MOV   A,1           (0189) ;               CUR_PP
06D8: 67       ASR   A             (0190) ;
                                   (0191) _LoadConfigInit:
06D9: 50 05    MOV   A,5           (0192)  LoadConfigInit:
06DB: 57 76    MOV   X,118         (0193)     RAM_PROLOGUE RAM_USE_CLASS_4
06DD: 7C 0C 66 LCALL 0x0C66        (0194)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0195) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0196) 	mov		[ACTIVE_CONFIG_STATUS+1], 0
06E0: 62 D0 00 MOV   REG[208],0    (0197) 
06E3: 2E 04 01 OR    [4],1         (0198) 	lcall	LoadConfig_waiting
06E6: 70 EF    AND   F,239         (0199) 	lcall	LoadConfigTBL_waiting_Ordered
06E8: 20       POP   X             (0200) 
                                   (0201) 
                                   (0202)     RAM_EPILOGUE RAM_USE_CLASS_4
06E9: 7F       RET                 (0203)     ret
                                   (0204) 
                                   (0205) ;---------------------------------------------------------------------------
                                   (0206) ; Load Configuration waiting
                                   (0207) ;
                                   (0208) ;    Load configuration registers for waiting.
                                   (0209) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0210) ;
                                   (0211) ;       INPUTS: None.
                                   (0212) ;      RETURNS: Nothing.
                                   (0213) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0214) ;               modified as may the Page Pointer registers!
                                   (0215) ;               In the large memory model currently only the page
                                   (0216) ;               pointer registers listed below are modified.  This does
                                   (0217) ;               not guarantee that in future implementations of this
                                   (0218) ;               function other page pointer registers will not be
                                   (0219) ;               modified.
                                   (0220) ;          
                                   (0221) ;               Page Pointer Registers Modified: 
                                   (0222) ;               CUR_PP
                                   (0223) ;
                                   (0224) _LoadConfig_waiting:
                                   (0225)  LoadConfig_waiting:
                                   (0226)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0227) 	M8C_SetBank1
                                   (0228) 
06EA: 10       PUSH  X             (0229) 	push	x
06EB: 70 EF    AND   F,239         (0230)     M8C_SetBank0                    ; Force bank 0
06ED: 50 00    MOV   A,0           (0231)     mov     a, 0                    ; Specify bank 0
06EF: 67       ASR   A             (0232)     asr     a                       ; Store in carry flag
                                   (0233)                                     ; Load bank 0 table:
06F0: 50 05    MOV   A,5           (0234)     mov     A, >LoadConfigTBL_waiting_Bank0
06F2: 57 8F    MOV   X,143         (0235)     mov     X, <LoadConfigTBL_waiting_Bank0
06F4: 7C 0C 66 LCALL 0x0C66        (0236)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0237) 
06F7: 50 01    MOV   A,1           (0238)     mov     a, 1                    ; Specify bank 1
06F9: 67       ASR   A             (0239)     asr     a                       ; Store in carry flag
                                   (0240)                                     ; Load bank 1 table:
06FA: 50 05    MOV   A,5           (0241)     mov     A, >LoadConfigTBL_waiting_Bank1
06FC: 57 98    MOV   X,152         (0242)     mov     X, <LoadConfigTBL_waiting_Bank1
06FE: 7C 0C 66 LCALL 0x0C66        (0243)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0244) 
0701: 70 EF    AND   F,239         (0245) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0246) ; set config active bit
0703: 62 D0 00 MOV   REG[208],0    (0247) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
0706: 26 04 FE AND   [4],254       (0248)     M8C_SetBank0                    ; Force return to bank 0
0709: 70 EF    AND   F,239         (0249) 	pop		x
070B: 20       POP   X             (0250) 
                                   (0251)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0252)     ret
070C: 7F       RET                 (0253) 
                                   (0254) ;---------------------------------------------------------------------------
                                   (0255) ; Reload Configuration waiting
                                   (0256) ;
                                   (0257) ;    Reload configuration registers for waiting.
                                   (0258) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0259) ;
                                   (0260) ;       INPUTS: None.
                                   (0261) ;      RETURNS: Nothing.
                                   (0262) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0263) ;               modified as may the Page Pointer registers!
                                   (0264) ;               In the large memory model currently only the page
                                   (0265) ;               pointer registers listed below are modified.  This does
                                   (0266) ;               not guarantee that in future implementations of this
                                   (0267) ;               function other page pointer registers will not be
                                   (0268) ;               modified.
                                   (0269) ;          
                                   (0270) ;               Page Pointer Registers Modified: 
                                   (0271) ;               CUR_PP
                                   (0272) ;
                                   (0273) _ReloadConfig_waiting:
                                   (0274)  ReloadConfig_waiting:
                                   (0275)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0276) 
070D: 71 10    OR    F,16          (0277) 	push	x
                                   (0278)     M8C_SetBank0                    ; Force bank 0
070F: 41 00 E1 AND   REG[0],225    (0279)     mov     a, 0                    ; Specify bank 0
                                   (0280)     asr     a                       ; Store in carry flag
0712: 41 01 E1 AND   REG[1],225    (0281)                                     ; Bank 0 table address:
0715: 43 01 1E OR    REG[1],30     (0282)     mov     A, >ReloadConfigTBL_waiting_Bank0
                                   (0283)     mov     X, <ReloadConfigTBL_waiting_Bank0
0718: 70 EF    AND   F,239         (0284)     lcall   LoadConfig              ; Reload the bank 0 values
071A: 41 03 FE AND   REG[3],254    (0285) 
071D: 43 03 01 OR    REG[3],1      (0286)     mov     a, 1                    ; Specify bank 1
                                   (0287)     asr     a                       ; Store in carry flag
0720: 41 02 FE AND   REG[2],254    (0288)                                     ; Bank 1 table address:
                                   (0289)     mov     A, >ReloadConfigTBL_waiting_Bank1
0723: 41 B3 F0 AND   REG[179],240  (0290)     mov     X, <ReloadConfigTBL_waiting_Bank1
0726: 43 B3 03 OR    REG[179],3    (0291)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0292) 
0729: 41 B4 F0 AND   REG[180],240  (0293) ; set config active bit
072C: 43 B4 03 OR    REG[180],3    (0294) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0295) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
072F: 41 B5 ED AND   REG[181],237  (0296)     M8C_SetBank0                    ; Force return to bank 0
                                   (0297) 	pop		x
0732: 41 B6 EE AND   REG[182],238  (0298) 
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_4
0735: 41 B8 3C AND   REG[184],60   (0300)     ret
0738: 43 B8 01 OR    REG[184],1    (0301) 
                                   (0302) ;---------------------------------------------------------------------------
073B: 10       PUSH  X             (0303) ; Unload Configuration waiting
073C: 70 EF    AND   F,239         (0304) ;
073E: 50 00    MOV   A,0           (0305) ;    Reset configuration registers for waiting
0740: 67       ASR   A             (0306) ;    to their values as initially configured.
                                   (0307) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0741: 50 01    MOV   A,1           (0308) ;
0743: 57 A0    MOV   X,160         (0309) ;       INPUTS: None.
0745: 7C 0C 66 LCALL 0x0C66        (0310) ;      RETURNS: Nothing.
                                   (0311) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0748: 50 01    MOV   A,1           (0312) ;               modified as may the Page Pointer registers!
074A: 67       ASR   A             (0313) ;               In the large memory model currently only the page
                                   (0314) ;               pointer registers listed below are modified.  This does
074B: 50 01    MOV   A,1           (0315) ;               not guarantee that in future implementations of this
074D: 57 C5    MOV   X,197         (0316) ;               function other page pointer registers will not be
074F: 7C 0C 66 LCALL 0x0C66        (0317) ;               modified.
                                   (0318) ;          
0752: 62 D0 00 MOV   REG[208],0    (0319) ;               Page Pointer Registers Modified: 
                                   (0320) ;               CUR_PP
0755: 2E 04 02 OR    [4],2         (0321) ;
0758: 70 EF    AND   F,239         (0322) _UnloadConfig_waiting:
075A: 20       POP   X             (0323)  UnloadConfig_waiting:
                                   (0324)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0325) 
075B: 7F       RET                 (0326) 	push	x
                                   (0327)     M8C_SetBank0                    ; Force bank 0
                                   (0328)     mov     a, 0                    ; Specify bank 0
                                   (0329)     asr     a                       ; Store in carry flag
                                   (0330)                                     ; Bank 0 table address:
                                   (0331)     mov     A, >UnloadConfigTBL_waiting_Bank0
                                   (0332)     mov     X, <UnloadConfigTBL_waiting_Bank0
                                   (0333)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0334) 
                                   (0335)     mov     a, 1                    ; Specify bank 1
                                   (0336)     asr     a                       ; Store in carry flag
                                   (0337)                                     ; Bank 1 table address:
                                   (0338)     mov     A, >UnloadConfigTBL_waiting_Bank1
                                   (0339)     mov     X, <UnloadConfigTBL_waiting_Bank1
                                   (0340)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0341) 
                                   (0342) 	M8C_SetBank0
                                   (0343) ; clear config active bit
                                   (0344) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0345) 	and		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], ~waiting_BIT
                                   (0346)     M8C_SetBank0                    ; Force return to bank 0
                                   (0347) 	pop		x
                                   (0348) 
                                   (0349)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0350)     ret
                                   (0351) 
075C: 10       PUSH  X             (0352) ;---------------------------------------------------------------------------
075D: 70 EF    AND   F,239         (0353) ; Load Configuration hello
075F: 50 00    MOV   A,0           (0354) ;
0761: 67       ASR   A             (0355) ;    Load configuration registers for hello.
                                   (0356) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0762: 50 01    MOV   A,1           (0357) ;
0764: 57 EA    MOV   X,234         (0358) ;       INPUTS: None.
0766: 7C 0C 66 LCALL 0x0C66        (0359) ;      RETURNS: Nothing.
                                   (0360) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0769: 50 01    MOV   A,1           (0361) ;               modified as may the Page Pointer registers!
076B: 67       ASR   A             (0362) ;               In the large memory model currently only the page
                                   (0363) ;               pointer registers listed below are modified.  This does
076C: 50 01    MOV   A,1           (0364) ;               not guarantee that in future implementations of this
076E: 57 F7    MOV   X,247         (0365) ;               function other page pointer registers will not be
0770: 7C 0C 66 LCALL 0x0C66        (0366) ;               modified.
                                   (0367) ;          
0773: 70 EF    AND   F,239         (0368) ;               Page Pointer Registers Modified: 
                                   (0369) ;               CUR_PP
0775: 41 B3 F0 AND   REG[179],240  (0370) ;
0778: 43 B3 05 OR    REG[179],5    (0371) _LoadConfig_hello:
                                   (0372)  LoadConfig_hello:
077B: 41 B4 F0 AND   REG[180],240  (0373)     RAM_PROLOGUE RAM_USE_CLASS_4
077E: 43 B4 05 OR    REG[180],5    (0374) 	M8C_SetBank1
                                   (0375) ; writing Port_0_DriveMode_0 register
0781: 41 B5 ED AND   REG[181],237  (0376) 	and		reg[ 0h], ~1eh
0784: 43 B5 12 OR    REG[181],18   (0377) ; writing Port_0_DriveMode_1 register
                                   (0378) 	and		reg[ 1h], ~1eh
0787: 41 B6 EE AND   REG[182],238  (0379) 	or		reg[ 1h], 1eh
078A: 43 B6 11 OR    REG[182],17   (0380) ; writing Port_0_DriveMode_2 register
                                   (0381) 	M8C_SetBank0
078D: 41 B8 3C AND   REG[184],60   (0382) 	and		reg[ 3h], ~ 1h
0790: 43 B8 40 OR    REG[184],64   (0383) 	or		reg[ 3h],  1h
                                   (0384) ; writing Port_0_GlobalSelect register
0793: 41 02 FE AND   REG[2],254    (0385) 	and		reg[ 2h], ~ 1h
0796: 43 02 01 OR    REG[2],1      (0386) ; writing Row_0_LogicSelect_0 register
                                   (0387) 	and		reg[b3h], ~ fh
0799: 41 03 FE AND   REG[3],254    (0388) 	or		reg[b3h],  3h
                                   (0389) ; writing Row_0_LogicSelect_1 register
079C: 71 10    OR    F,16          (0390) 	and		reg[b4h], ~ fh
079E: 41 01 E1 AND   REG[1],225    (0391) 	or		reg[b4h],  3h
                                   (0392) ; writing Row_0_OutputDrive_0 register
07A1: 41 00 E1 AND   REG[0],225    (0393) 	and		reg[b5h], ~12h
07A4: 43 00 1E OR    REG[0],30     (0394) ; writing Row_0_OutputDrive_1 register
07A7: 70 EF    AND   F,239         (0395) 	and		reg[b6h], ~11h
                                   (0396) ; writing Row_1_InputMux register
07A9: 62 D0 00 MOV   REG[208],0    (0397) 	and		reg[b8h], ~c3h
07AC: 26 04 FD AND   [4],253       (0398) 	or		reg[b8h],  1h
07AF: 70 EF    AND   F,239         (0399) 
07B1: 20       POP   X             (0400) 	push	x
                                   (0401)     M8C_SetBank0                    ; Force bank 0
                                   (0402)     mov     a, 0                    ; Specify bank 0
07B2: 7F       RET                 (0403)     asr     a                       ; Store in carry flag
                                   (0404)                                     ; Load bank 0 table:
                                   (0405)     mov     A, >LoadConfigTBL_hello_Bank0
                                   (0406)     mov     X, <LoadConfigTBL_hello_Bank0
                                   (0407)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0408) 
                                   (0409)     mov     a, 1                    ; Specify bank 1
                                   (0410)     asr     a                       ; Store in carry flag
                                   (0411)                                     ; Load bank 1 table:
                                   (0412)     mov     A, >LoadConfigTBL_hello_Bank1
                                   (0413)     mov     X, <LoadConfigTBL_hello_Bank1
                                   (0414)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0415) 
                                   (0416) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0417) ; set config active bit
                                   (0418) 	or		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
                                   (0419)     M8C_SetBank0                    ; Force return to bank 0
                                   (0420) 	pop		x
                                   (0421) 
                                   (0422)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0423)     ret
                                   (0424) 
                                   (0425) ;---------------------------------------------------------------------------
                                   (0426) ; Unload Configuration hello
07B3: 71 10    OR    F,16          (0427) ;
                                   (0428) ;    Reset configuration registers for hello
07B5: 41 00 E1 AND   REG[0],225    (0429) ;    to their values as initially configured.
                                   (0430) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07B8: 41 01 E1 AND   REG[1],225    (0431) ;
07BB: 43 01 1E OR    REG[1],30     (0432) ;       INPUTS: None.
                                   (0433) ;      RETURNS: Nothing.
07BE: 70 EF    AND   F,239         (0434) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
07C0: 41 03 E1 AND   REG[3],225    (0435) ;               modified as may the Page Pointer registers!
07C3: 43 03 1E OR    REG[3],30     (0436) ;               In the large memory model currently only the page
                                   (0437) ;               pointer registers listed below are modified.  This does
07C6: 41 02 E1 AND   REG[2],225    (0438) ;               not guarantee that in future implementations of this
                                   (0439) ;               function other page pointer registers will not be
07C9: 41 B3 F0 AND   REG[179],240  (0440) ;               modified.
07CC: 43 B3 03 OR    REG[179],3    (0441) ;          
                                   (0442) ;               Page Pointer Registers Modified: 
07CF: 41 B4 F0 AND   REG[180],240  (0443) ;               CUR_PP
07D2: 43 B4 03 OR    REG[180],3    (0444) ;
                                   (0445) _UnloadConfig_hello:
07D5: 41 B5 ED AND   REG[181],237  (0446)  UnloadConfig_hello:
                                   (0447)     RAM_PROLOGUE RAM_USE_CLASS_4
07D8: 41 B6 EE AND   REG[182],238  (0448) 
                                   (0449) 	push	x
07DB: 41 B8 FC AND   REG[184],252  (0450)     M8C_SetBank0                    ; Force bank 0
07DE: 43 B8 01 OR    REG[184],1    (0451)     mov     a, 0                    ; Specify bank 0
                                   (0452)     asr     a                       ; Store in carry flag
07E1: 71 10    OR    F,16          (0453)                                     ; Bank 0 table address:
07E3: 41 E3 F8 AND   REG[227],248  (0454)     mov     A, >UnloadConfigTBL_hello_Bank0
07E6: 43 E3 03 OR    REG[227],3    (0455)     mov     X, <UnloadConfigTBL_hello_Bank0
                                   (0456)     lcall   LoadConfig              ; Unload the bank 0 values
07E9: 10       PUSH  X             (0457) 
07EA: 70 EF    AND   F,239         (0458)     mov     a, 1                    ; Specify bank 1
07EC: 50 00    MOV   A,0           (0459)     asr     a                       ; Store in carry flag
07EE: 67       ASR   A             (0460)                                     ; Bank 1 table address:
                                   (0461)     mov     A, >UnloadConfigTBL_hello_Bank1
07EF: 50 02    MOV   A,2           (0462)     mov     X, <UnloadConfigTBL_hello_Bank1
07F1: 57 1D    MOV   X,29          (0463)     lcall   LoadConfig              ; Unload the bank 1 values
07F3: 7C 0C 66 LCALL 0x0C66        (0464) 
                                   (0465) 	M8C_SetBank0
07F6: 50 01    MOV   A,1           (0466) ; writing Row_0_LogicSelect_0 register
07F8: 67       ASR   A             (0467) 	and		reg[b3h], ~ fh
                                   (0468) 	or		reg[b3h],  5h
07F9: 50 02    MOV   A,2           (0469) ; writing Row_0_LogicSelect_1 register
07FB: 57 30    MOV   X,48          (0470) 	and		reg[b4h], ~ fh
07FD: 7C 0C 66 LCALL 0x0C66        (0471) 	or		reg[b4h],  5h
                                   (0472) ; writing Row_0_OutputDrive_0 register
0800: 62 D0 00 MOV   REG[208],0    (0473) 	and		reg[b5h], ~12h
                                   (0474) 	or		reg[b5h], 12h
0803: 2E 04 04 OR    [4],4         (0475) ; writing Row_0_OutputDrive_1 register
0806: 70 EF    AND   F,239         (0476) 	and		reg[b6h], ~11h
0808: 20       POP   X             (0477) 	or		reg[b6h], 11h
                                   (0478) ; writing Row_1_InputMux register
                                   (0479) 	and		reg[b8h], ~c3h
0809: 7F       RET                 (0480) 	or		reg[b8h], 40h
                                   (0481) ; writing Port_0_GlobalSelect register
                                   (0482) 	and		reg[ 2h], ~ 1h
                                   (0483) 	or		reg[ 2h],  1h
                                   (0484) ; writing Port_0_DriveMode_2 register
                                   (0485) 	and		reg[ 3h], ~ 1h
                                   (0486) ; writing Port_0_DriveMode_1 register
                                   (0487) 	M8C_SetBank1
                                   (0488) 	and		reg[ 1h], ~1eh
                                   (0489) ; writing Port_0_DriveMode_0 register
                                   (0490) 	and		reg[ 0h], ~1eh
                                   (0491) 	or		reg[ 0h], 1eh
                                   (0492) 	M8C_SetBank0
                                   (0493) ; clear config active bit
                                   (0494) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0495) 	and		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], ~hello_BIT
                                   (0496)     M8C_SetBank0                    ; Force return to bank 0
                                   (0497) 	pop		x
                                   (0498) 
                                   (0499)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0500)     ret
                                   (0501) 
                                   (0502) ;---------------------------------------------------------------------------
                                   (0503) ; Load Configuration initial
                                   (0504) ;
                                   (0505) ;    Load configuration registers for initial.
080A: 10       PUSH  X             (0506) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
080B: 70 EF    AND   F,239         (0507) ;
080D: 50 00    MOV   A,0           (0508) ;       INPUTS: None.
080F: 67       ASR   A             (0509) ;      RETURNS: Nothing.
                                   (0510) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0810: 50 02    MOV   A,2           (0511) ;               modified as may the Page Pointer registers!
0812: 57 43    MOV   X,67          (0512) ;               In the large memory model currently only the page
0814: 7C 0C 66 LCALL 0x0C66        (0513) ;               pointer registers listed below are modified.  This does
                                   (0514) ;               not guarantee that in future implementations of this
0817: 50 01    MOV   A,1           (0515) ;               function other page pointer registers will not be
0819: 67       ASR   A             (0516) ;               modified.
                                   (0517) ;          
081A: 50 02    MOV   A,2           (0518) ;               Page Pointer Registers Modified: 
081C: 57 4A    MOV   X,74          (0519) ;               CUR_PP
081E: 7C 0C 66 LCALL 0x0C66        (0520) ;
                                   (0521) _LoadConfig_initial:
0821: 70 EF    AND   F,239         (0522)  LoadConfig_initial:
                                   (0523)     RAM_PROLOGUE RAM_USE_CLASS_4
0823: 41 B3 F0 AND   REG[179],240  (0524) 	M8C_SetBank1
0826: 43 B3 05 OR    REG[179],5    (0525) ; writing Port_0_DriveMode_0 register
                                   (0526) 	and		reg[ 0h], ~1eh
0829: 41 B4 F0 AND   REG[180],240  (0527) ; writing Port_0_DriveMode_1 register
082C: 43 B4 05 OR    REG[180],5    (0528) 	and		reg[ 1h], ~1eh
                                   (0529) 	or		reg[ 1h], 1eh
082F: 41 B5 ED AND   REG[181],237  (0530) ; writing Port_0_DriveMode_2 register
0832: 43 B5 12 OR    REG[181],18   (0531) 	M8C_SetBank0
                                   (0532) 	and		reg[ 3h], ~1eh
0835: 41 B6 EE AND   REG[182],238  (0533) 	or		reg[ 3h], 1eh
0838: 43 B6 11 OR    REG[182],17   (0534) ; writing Port_0_GlobalSelect register
                                   (0535) 	and		reg[ 2h], ~1eh
083B: 41 B8 FC AND   REG[184],252  (0536) ; writing Row_0_LogicSelect_0 register
                                   (0537) 	and		reg[b3h], ~ fh
083E: 71 10    OR    F,16          (0538) 	or		reg[b3h],  3h
0840: 41 E3 F8 AND   REG[227],248  (0539) ; writing Row_0_LogicSelect_1 register
0843: 43 E3 07 OR    REG[227],7    (0540) 	and		reg[b4h], ~ fh
                                   (0541) 	or		reg[b4h],  3h
0846: 70 EF    AND   F,239         (0542) ; writing Row_0_OutputDrive_0 register
0848: 41 02 E1 AND   REG[2],225    (0543) 	and		reg[b5h], ~12h
084B: 43 02 1E OR    REG[2],30     (0544) ; writing Row_0_OutputDrive_1 register
                                   (0545) 	and		reg[b6h], ~11h
084E: 41 03 E1 AND   REG[3],225    (0546) ; writing Row_1_InputMux register
                                   (0547) 	and		reg[b8h], ~ 3h
0851: 71 10    OR    F,16          (0548) 	or		reg[b8h],  1h
0853: 41 01 E1 AND   REG[1],225    (0549) ; writing VoltageMonitorControl register
                                   (0550) 	M8C_SetBank1
0856: 41 00 E1 AND   REG[0],225    (0551) 	and		reg[e3h], ~ 7h
0859: 43 00 1E OR    REG[0],30     (0552) 	or		reg[e3h],  3h
085C: 70 EF    AND   F,239         (0553) 
                                   (0554) 	push	x
085E: 62 D0 00 MOV   REG[208],0    (0555)     M8C_SetBank0                    ; Force bank 0
0861: 26 04 FB AND   [4],251       (0556)     mov     a, 0                    ; Specify bank 0
0864: 70 EF    AND   F,239         (0557)     asr     a                       ; Store in carry flag
0866: 20       POP   X             (0558)                                     ; Load bank 0 table:
                                   (0559)     mov     A, >LoadConfigTBL_initial_Bank0
                                   (0560)     mov     X, <LoadConfigTBL_initial_Bank0
0867: 7F       RET                 (0561)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0562) 
                                   (0563)     mov     a, 1                    ; Specify bank 1
                                   (0564)     asr     a                       ; Store in carry flag
                                   (0565)                                     ; Load bank 1 table:
                                   (0566)     mov     A, >LoadConfigTBL_initial_Bank1
                                   (0567)     mov     X, <LoadConfigTBL_initial_Bank1
                                   (0568)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0569) 
                                   (0570) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0571) ; set config active bit
                                   (0572) 	or		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
                                   (0573)     M8C_SetBank0                    ; Force return to bank 0
                                   (0574) 	pop		x
                                   (0575) 
                                   (0576)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0577)     ret
                                   (0578) 
                                   (0579) ;---------------------------------------------------------------------------
                                   (0580) ; Unload Configuration initial
                                   (0581) ;
                                   (0582) ;    Reset configuration registers for initial
                                   (0583) ;    to their values as initially configured.
                                   (0584) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0868: 71 10    OR    F,16          (0585) ;
                                   (0586) ;       INPUTS: None.
086A: 41 00 FE AND   REG[0],254    (0587) ;      RETURNS: Nothing.
086D: 43 00 01 OR    REG[0],1      (0588) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0589) ;               modified as may the Page Pointer registers!
0870: 41 01 FE AND   REG[1],254    (0590) ;               In the large memory model currently only the page
                                   (0591) ;               pointer registers listed below are modified.  This does
0873: 70 EF    AND   F,239         (0592) ;               not guarantee that in future implementations of this
0875: 41 B5 FE AND   REG[181],254  (0593) ;               function other page pointer registers will not be
0878: 43 B5 01 OR    REG[181],1    (0594) ;               modified.
                                   (0595) ;          
087B: 41 B8 FC AND   REG[184],252  (0596) ;               Page Pointer Registers Modified: 
087E: 43 B8 01 OR    REG[184],1    (0597) ;               CUR_PP
                                   (0598) ;
0881: 10       PUSH  X             (0599) _UnloadConfig_initial:
0882: 70 EF    AND   F,239         (0600)  UnloadConfig_initial:
0884: 50 00    MOV   A,0           (0601)     RAM_PROLOGUE RAM_USE_CLASS_4
0886: 67       ASR   A             (0602) 
                                   (0603) 	push	x
0887: 50 02    MOV   A,2           (0604)     M8C_SetBank0                    ; Force bank 0
0889: 57 5E    MOV   X,94          (0605)     mov     a, 0                    ; Specify bank 0
088B: 7C 0C 66 LCALL 0x0C66        (0606)     asr     a                       ; Store in carry flag
                                   (0607)                                     ; Bank 0 table address:
088E: 50 01    MOV   A,1           (0608)     mov     A, >UnloadConfigTBL_initial_Bank0
0890: 67       ASR   A             (0609)     mov     X, <UnloadConfigTBL_initial_Bank0
                                   (0610)     lcall   LoadConfig              ; Unload the bank 0 values
0891: 50 02    MOV   A,2           (0611) 
0893: 57 77    MOV   X,119         (0612)     mov     a, 1                    ; Specify bank 1
0895: 7C 0C 66 LCALL 0x0C66        (0613)     asr     a                       ; Store in carry flag
                                   (0614)                                     ; Bank 1 table address:
0898: 62 D0 00 MOV   REG[208],0    (0615)     mov     A, >UnloadConfigTBL_initial_Bank1
                                   (0616)     mov     X, <UnloadConfigTBL_initial_Bank1
089B: 2E 04 08 OR    [4],8         (0617)     lcall   LoadConfig              ; Unload the bank 1 values
089E: 70 EF    AND   F,239         (0618) 
08A0: 20       POP   X             (0619) 	M8C_SetBank0
                                   (0620) ; writing Row_0_LogicSelect_0 register
                                   (0621) 	and		reg[b3h], ~ fh
08A1: 7F       RET                 (0622) 	or		reg[b3h],  5h
                                   (0623) ; writing Row_0_LogicSelect_1 register
                                   (0624) 	and		reg[b4h], ~ fh
                                   (0625) 	or		reg[b4h],  5h
                                   (0626) ; writing Row_0_OutputDrive_0 register
                                   (0627) 	and		reg[b5h], ~12h
                                   (0628) 	or		reg[b5h], 12h
                                   (0629) ; writing Row_0_OutputDrive_1 register
                                   (0630) 	and		reg[b6h], ~11h
                                   (0631) 	or		reg[b6h], 11h
                                   (0632) ; writing Row_1_InputMux register
                                   (0633) 	and		reg[b8h], ~ 3h
                                   (0634) ; writing VoltageMonitorControl register
                                   (0635) 	M8C_SetBank1
                                   (0636) 	and		reg[e3h], ~ 7h
                                   (0637) 	or		reg[e3h],  7h
                                   (0638) ; writing Port_0_GlobalSelect register
                                   (0639) 	M8C_SetBank0
                                   (0640) 	and		reg[ 2h], ~1eh
                                   (0641) 	or		reg[ 2h], 1eh
                                   (0642) ; writing Port_0_DriveMode_2 register
                                   (0643) 	and		reg[ 3h], ~1eh
                                   (0644) ; writing Port_0_DriveMode_1 register
                                   (0645) 	M8C_SetBank1
                                   (0646) 	and		reg[ 1h], ~1eh
                                   (0647) ; writing Port_0_DriveMode_0 register
08A2: 10       PUSH  X             (0648) 	and		reg[ 0h], ~1eh
08A3: 70 EF    AND   F,239         (0649) 	or		reg[ 0h], 1eh
08A5: 50 00    MOV   A,0           (0650) 	M8C_SetBank0
08A7: 67       ASR   A             (0651) ; clear config active bit
                                   (0652) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
08A8: 50 02    MOV   A,2           (0653) 	and		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], ~initial_BIT
08AA: 57 90    MOV   X,144         (0654)     M8C_SetBank0                    ; Force return to bank 0
08AC: 7C 0C 66 LCALL 0x0C66        (0655) 	pop		x
                                   (0656) 
08AF: 50 01    MOV   A,1           (0657)     RAM_EPILOGUE RAM_USE_CLASS_4
08B1: 67       ASR   A             (0658)     ret
                                   (0659) 
08B2: 50 02    MOV   A,2           (0660) ;---------------------------------------------------------------------------
08B4: 57 99    MOV   X,153         (0661) ; Load Configuration my_response
08B6: 7C 0C 66 LCALL 0x0C66        (0662) ;
                                   (0663) ;    Load configuration registers for my_response.
08B9: 70 EF    AND   F,239         (0664) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0665) ;
08BB: 41 B5 FE AND   REG[181],254  (0666) ;       INPUTS: None.
                                   (0667) ;      RETURNS: Nothing.
08BE: 41 B8 FC AND   REG[184],252  (0668) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0669) ;               modified as may the Page Pointer registers!
08C1: 71 10    OR    F,16          (0670) ;               In the large memory model currently only the page
08C3: 41 01 FE AND   REG[1],254    (0671) ;               pointer registers listed below are modified.  This does
08C6: 43 01 01 OR    REG[1],1      (0672) ;               not guarantee that in future implementations of this
                                   (0673) ;               function other page pointer registers will not be
08C9: 41 00 FE AND   REG[0],254    (0674) ;               modified.
08CC: 70 EF    AND   F,239         (0675) ;          
                                   (0676) ;               Page Pointer Registers Modified: 
08CE: 62 D0 00 MOV   REG[208],0    (0677) ;               CUR_PP
08D1: 26 04 F7 AND   [4],247       (0678) ;
08D4: 70 EF    AND   F,239         (0679) _LoadConfig_my_response:
08D6: 20       POP   X             (0680)  LoadConfig_my_response:
                                   (0681)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0682) 	M8C_SetBank1
08D7: 7F       RET                 (0683) ; writing Port_0_DriveMode_0 register
                                   (0684) 	and		reg[ 0h], ~ 1h
                                   (0685) 	or		reg[ 0h],  1h
                                   (0686) ; writing Port_0_DriveMode_1 register
                                   (0687) 	and		reg[ 1h], ~ 1h
                                   (0688) ; writing Row_0_OutputDrive_0 register
                                   (0689) 	M8C_SetBank0
                                   (0690) 	and		reg[b5h], ~ 1h
                                   (0691) 	or		reg[b5h],  1h
                                   (0692) ; writing Row_1_InputMux register
                                   (0693) 	and		reg[b8h], ~ 3h
                                   (0694) 	or		reg[b8h],  1h
                                   (0695) 
                                   (0696) 	push	x
                                   (0697)     M8C_SetBank0                    ; Force bank 0
                                   (0698)     mov     a, 0                    ; Specify bank 0
                                   (0699)     asr     a                       ; Store in carry flag
                                   (0700)                                     ; Load bank 0 table:
                                   (0701)     mov     A, >LoadConfigTBL_my_response_Bank0
                                   (0702)     mov     X, <LoadConfigTBL_my_response_Bank0
                                   (0703)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0704) 
                                   (0705)     mov     a, 1                    ; Specify bank 1
                                   (0706)     asr     a                       ; Store in carry flag
08D8: 71 10    OR    F,16          (0707)                                     ; Load bank 1 table:
                                   (0708)     mov     A, >LoadConfigTBL_my_response_Bank1
08DA: 41 00 E0 AND   REG[0],224    (0709)     mov     X, <LoadConfigTBL_my_response_Bank1
08DD: 43 00 01 OR    REG[0],1      (0710)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0711) 
08E0: 41 01 E0 AND   REG[1],224    (0712) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
08E3: 43 01 1E OR    REG[1],30     (0713) ; set config active bit
                                   (0714) 	or		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
08E6: 70 EF    AND   F,239         (0715)     M8C_SetBank0                    ; Force return to bank 0
08E8: 41 03 E3 AND   REG[3],227    (0716) 	pop		x
08EB: 43 03 1C OR    REG[3],28     (0717) 
                                   (0718)     RAM_EPILOGUE RAM_USE_CLASS_4
08EE: 41 02 E3 AND   REG[2],227    (0719)     ret
                                   (0720) 
08F1: 41 B3 F0 AND   REG[179],240  (0721) ;---------------------------------------------------------------------------
08F4: 43 B3 03 OR    REG[179],3    (0722) ; Unload Configuration my_response
                                   (0723) ;
08F7: 41 B4 F0 AND   REG[180],240  (0724) ;    Reset configuration registers for my_response
08FA: 43 B4 03 OR    REG[180],3    (0725) ;    to their values as initially configured.
                                   (0726) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
08FD: 41 B5 EC AND   REG[181],236  (0727) ;
0900: 43 B5 01 OR    REG[181],1    (0728) ;       INPUTS: None.
                                   (0729) ;      RETURNS: Nothing.
0903: 41 B6 EE AND   REG[182],238  (0730) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0731) ;               modified as may the Page Pointer registers!
0906: 41 B8 FC AND   REG[184],252  (0732) ;               In the large memory model currently only the page
0909: 43 B8 01 OR    REG[184],1    (0733) ;               pointer registers listed below are modified.  This does
                                   (0734) ;               not guarantee that in future implementations of this
090C: 10       PUSH  X             (0735) ;               function other page pointer registers will not be
090D: 70 EF    AND   F,239         (0736) ;               modified.
090F: 50 00    MOV   A,0           (0737) ;          
0911: 67       ASR   A             (0738) ;               Page Pointer Registers Modified: 
                                   (0739) ;               CUR_PP
0912: 50 02    MOV   A,2           (0740) ;
0914: 57 B3    MOV   X,179         (0741) _UnloadConfig_my_response:
0916: 7C 0C 66 LCALL 0x0C66        (0742)  UnloadConfig_my_response:
                                   (0743)     RAM_PROLOGUE RAM_USE_CLASS_4
0919: 50 01    MOV   A,1           (0744) 
091B: 67       ASR   A             (0745) 	push	x
                                   (0746)     M8C_SetBank0                    ; Force bank 0
091C: 50 02    MOV   A,2           (0747)     mov     a, 0                    ; Specify bank 0
091E: 57 C6    MOV   X,198         (0748)     asr     a                       ; Store in carry flag
0920: 7C 0C 66 LCALL 0x0C66        (0749)                                     ; Bank 0 table address:
                                   (0750)     mov     A, >UnloadConfigTBL_my_response_Bank0
0923: 62 D0 00 MOV   REG[208],0    (0751)     mov     X, <UnloadConfigTBL_my_response_Bank0
                                   (0752)     lcall   LoadConfig              ; Unload the bank 0 values
0926: 2E 04 10 OR    [4],16        (0753) 
0929: 70 EF    AND   F,239         (0754)     mov     a, 1                    ; Specify bank 1
092B: 20       POP   X             (0755)     asr     a                       ; Store in carry flag
                                   (0756)                                     ; Bank 1 table address:
                                   (0757)     mov     A, >UnloadConfigTBL_my_response_Bank1
092C: 7F       RET                 (0758)     mov     X, <UnloadConfigTBL_my_response_Bank1
                                   (0759)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0760) 
                                   (0761) 	M8C_SetBank0
                                   (0762) ; writing Row_0_OutputDrive_0 register
                                   (0763) 	and		reg[b5h], ~ 1h
                                   (0764) ; writing Row_1_InputMux register
                                   (0765) 	and		reg[b8h], ~ 3h
                                   (0766) ; writing Port_0_DriveMode_1 register
                                   (0767) 	M8C_SetBank1
                                   (0768) 	and		reg[ 1h], ~ 1h
                                   (0769) 	or		reg[ 1h],  1h
                                   (0770) ; writing Port_0_DriveMode_0 register
                                   (0771) 	and		reg[ 0h], ~ 1h
                                   (0772) 	M8C_SetBank0
                                   (0773) ; clear config active bit
                                   (0774) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0775) 	and		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], ~my_response_BIT
                                   (0776)     M8C_SetBank0                    ; Force return to bank 0
                                   (0777) 	pop		x
                                   (0778) 
                                   (0779)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0780)     ret
                                   (0781) 
                                   (0782) ;---------------------------------------------------------------------------
                                   (0783) ; Load Configuration response1
092D: 10       PUSH  X             (0784) ;
092E: 70 EF    AND   F,239         (0785) ;    Load configuration registers for response1.
0930: 50 00    MOV   A,0           (0786) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0932: 67       ASR   A             (0787) ;
                                   (0788) ;       INPUTS: None.
0933: 50 02    MOV   A,2           (0789) ;      RETURNS: Nothing.
0935: 57 D9    MOV   X,217         (0790) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0937: 7C 0C 66 LCALL 0x0C66        (0791) ;               modified as may the Page Pointer registers!
                                   (0792) ;               In the large memory model currently only the page
093A: 50 01    MOV   A,1           (0793) ;               pointer registers listed below are modified.  This does
093C: 67       ASR   A             (0794) ;               not guarantee that in future implementations of this
                                   (0795) ;               function other page pointer registers will not be
093D: 50 02    MOV   A,2           (0796) ;               modified.
093F: 57 E0    MOV   X,224         (0797) ;          
0941: 7C 0C 66 LCALL 0x0C66        (0798) ;               Page Pointer Registers Modified: 
                                   (0799) ;               CUR_PP
0944: 70 EF    AND   F,239         (0800) ;
                                   (0801) _LoadConfig_response1:
0946: 41 B3 F0 AND   REG[179],240  (0802)  LoadConfig_response1:
0949: 43 B3 05 OR    REG[179],5    (0803)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0804) 	M8C_SetBank1
094C: 41 B4 F0 AND   REG[180],240  (0805) ; writing Port_0_DriveMode_0 register
094F: 43 B4 05 OR    REG[180],5    (0806) 	and		reg[ 0h], ~1fh
                                   (0807) 	or		reg[ 0h],  1h
0952: 41 B5 EC AND   REG[181],236  (0808) ; writing Port_0_DriveMode_1 register
0955: 43 B5 12 OR    REG[181],18   (0809) 	and		reg[ 1h], ~1fh
                                   (0810) 	or		reg[ 1h], 1eh
0958: 41 B6 EE AND   REG[182],238  (0811) ; writing Port_0_DriveMode_2 register
095B: 43 B6 11 OR    REG[182],17   (0812) 	M8C_SetBank0
                                   (0813) 	and		reg[ 3h], ~1ch
095E: 41 B8 FC AND   REG[184],252  (0814) 	or		reg[ 3h], 1ch
                                   (0815) ; writing Port_0_GlobalSelect register
0961: 41 02 E3 AND   REG[2],227    (0816) 	and		reg[ 2h], ~1ch
0964: 43 02 1C OR    REG[2],28     (0817) ; writing Row_0_LogicSelect_0 register
                                   (0818) 	and		reg[b3h], ~ fh
0967: 41 03 E3 AND   REG[3],227    (0819) 	or		reg[b3h],  3h
                                   (0820) ; writing Row_0_LogicSelect_1 register
096A: 71 10    OR    F,16          (0821) 	and		reg[b4h], ~ fh
096C: 41 01 E0 AND   REG[1],224    (0822) 	or		reg[b4h],  3h
096F: 43 01 01 OR    REG[1],1      (0823) ; writing Row_0_OutputDrive_0 register
                                   (0824) 	and		reg[b5h], ~13h
0972: 41 00 E0 AND   REG[0],224    (0825) 	or		reg[b5h],  1h
0975: 43 00 1E OR    REG[0],30     (0826) ; writing Row_0_OutputDrive_1 register
0978: 70 EF    AND   F,239         (0827) 	and		reg[b6h], ~11h
                                   (0828) ; writing Row_1_InputMux register
097A: 62 D0 00 MOV   REG[208],0    (0829) 	and		reg[b8h], ~ 3h
097D: 26 04 EF AND   [4],239       (0830) 	or		reg[b8h],  1h
0980: 70 EF    AND   F,239         (0831) 
0982: 20       POP   X             (0832) 	push	x
                                   (0833)     M8C_SetBank0                    ; Force bank 0
                                   (0834)     mov     a, 0                    ; Specify bank 0
0983: 7F       RET                 (0835)     asr     a                       ; Store in carry flag
                                   (0836)                                     ; Load bank 0 table:
                                   (0837)     mov     A, >LoadConfigTBL_response1_Bank0
                                   (0838)     mov     X, <LoadConfigTBL_response1_Bank0
                                   (0839)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0840) 
                                   (0841)     mov     a, 1                    ; Specify bank 1
                                   (0842)     asr     a                       ; Store in carry flag
                                   (0843)                                     ; Load bank 1 table:
                                   (0844)     mov     A, >LoadConfigTBL_response1_Bank1
                                   (0845)     mov     X, <LoadConfigTBL_response1_Bank1
                                   (0846)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0847) 
                                   (0848) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0849) ; set config active bit
                                   (0850) 	or		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
                                   (0851)     M8C_SetBank0                    ; Force return to bank 0
                                   (0852) 	pop		x
                                   (0853) 
                                   (0854)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0855)     ret
                                   (0856) 
                                   (0857) ;---------------------------------------------------------------------------
                                   (0858) ; Unload Configuration response1
0984: 71 10    OR    F,16          (0859) ;
                                   (0860) ;    Reset configuration registers for response1
0986: 41 00 E0 AND   REG[0],224    (0861) ;    to their values as initially configured.
0989: 43 00 01 OR    REG[0],1      (0862) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0863) ;
098C: 41 01 E0 AND   REG[1],224    (0864) ;       INPUTS: None.
098F: 43 01 1E OR    REG[1],30     (0865) ;      RETURNS: Nothing.
                                   (0866) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0992: 70 EF    AND   F,239         (0867) ;               modified as may the Page Pointer registers!
0994: 41 03 E5 AND   REG[3],229    (0868) ;               In the large memory model currently only the page
0997: 43 03 1A OR    REG[3],26     (0869) ;               pointer registers listed below are modified.  This does
                                   (0870) ;               not guarantee that in future implementations of this
099A: 41 02 E5 AND   REG[2],229    (0871) ;               function other page pointer registers will not be
                                   (0872) ;               modified.
099D: 41 B3 F0 AND   REG[179],240  (0873) ;          
09A0: 43 B3 03 OR    REG[179],3    (0874) ;               Page Pointer Registers Modified: 
                                   (0875) ;               CUR_PP
09A3: 41 B4 F0 AND   REG[180],240  (0876) ;
09A6: 43 B4 03 OR    REG[180],3    (0877) _UnloadConfig_response1:
                                   (0878)  UnloadConfig_response1:
09A9: 41 B5 EC AND   REG[181],236  (0879)     RAM_PROLOGUE RAM_USE_CLASS_4
09AC: 43 B5 01 OR    REG[181],1    (0880) 
                                   (0881) 	push	x
09AF: 41 B6 EE AND   REG[182],238  (0882)     M8C_SetBank0                    ; Force bank 0
                                   (0883)     mov     a, 0                    ; Specify bank 0
09B2: 41 B8 FC AND   REG[184],252  (0884)     asr     a                       ; Store in carry flag
09B5: 43 B8 01 OR    REG[184],1    (0885)                                     ; Bank 0 table address:
                                   (0886)     mov     A, >UnloadConfigTBL_response1_Bank0
09B8: 10       PUSH  X             (0887)     mov     X, <UnloadConfigTBL_response1_Bank0
09B9: 70 EF    AND   F,239         (0888)     lcall   LoadConfig              ; Unload the bank 0 values
09BB: 50 00    MOV   A,0           (0889) 
09BD: 67       ASR   A             (0890)     mov     a, 1                    ; Specify bank 1
                                   (0891)     asr     a                       ; Store in carry flag
09BE: 50 02    MOV   A,2           (0892)                                     ; Bank 1 table address:
09C0: 57 F4    MOV   X,244         (0893)     mov     A, >UnloadConfigTBL_response1_Bank1
09C2: 7C 0C 66 LCALL 0x0C66        (0894)     mov     X, <UnloadConfigTBL_response1_Bank1
                                   (0895)     lcall   LoadConfig              ; Unload the bank 1 values
09C5: 50 01    MOV   A,1           (0896) 
09C7: 67       ASR   A             (0897) 	M8C_SetBank0
                                   (0898) ; writing Row_0_LogicSelect_0 register
09C8: 50 03    MOV   A,3           (0899) 	and		reg[b3h], ~ fh
09CA: 57 07    MOV   X,7           (0900) 	or		reg[b3h],  5h
09CC: 7C 0C 66 LCALL 0x0C66        (0901) ; writing Row_0_LogicSelect_1 register
                                   (0902) 	and		reg[b4h], ~ fh
09CF: 62 D0 00 MOV   REG[208],0    (0903) 	or		reg[b4h],  5h
                                   (0904) ; writing Row_0_OutputDrive_0 register
09D2: 2E 04 20 OR    [4],32        (0905) 	and		reg[b5h], ~13h
09D5: 70 EF    AND   F,239         (0906) 	or		reg[b5h], 12h
09D7: 20       POP   X             (0907) ; writing Row_0_OutputDrive_1 register
                                   (0908) 	and		reg[b6h], ~11h
                                   (0909) 	or		reg[b6h], 11h
09D8: 7F       RET                 (0910) ; writing Row_1_InputMux register
                                   (0911) 	and		reg[b8h], ~ 3h
                                   (0912) ; writing Port_0_GlobalSelect register
                                   (0913) 	and		reg[ 2h], ~1ch
                                   (0914) 	or		reg[ 2h], 1ch
                                   (0915) ; writing Port_0_DriveMode_2 register
                                   (0916) 	and		reg[ 3h], ~1ch
                                   (0917) ; writing Port_0_DriveMode_1 register
                                   (0918) 	M8C_SetBank1
                                   (0919) 	and		reg[ 1h], ~1fh
                                   (0920) 	or		reg[ 1h],  1h
                                   (0921) ; writing Port_0_DriveMode_0 register
                                   (0922) 	and		reg[ 0h], ~1fh
                                   (0923) 	or		reg[ 0h], 1eh
                                   (0924) 	M8C_SetBank0
                                   (0925) ; clear config active bit
                                   (0926) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0927) 	and		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], ~response1_BIT
                                   (0928)     M8C_SetBank0                    ; Force return to bank 0
                                   (0929) 	pop		x
                                   (0930) 
                                   (0931)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0932)     ret
                                   (0933) 
                                   (0934) ;---------------------------------------------------------------------------
                                   (0935) ; Load Configuration response2
09D9: 10       PUSH  X             (0936) ;
09DA: 70 EF    AND   F,239         (0937) ;    Load configuration registers for response2.
09DC: 50 00    MOV   A,0           (0938) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
09DE: 67       ASR   A             (0939) ;
                                   (0940) ;       INPUTS: None.
09DF: 50 03    MOV   A,3           (0941) ;      RETURNS: Nothing.
09E1: 57 1A    MOV   X,26          (0942) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
09E3: 7C 0C 66 LCALL 0x0C66        (0943) ;               modified as may the Page Pointer registers!
                                   (0944) ;               In the large memory model currently only the page
09E6: 50 01    MOV   A,1           (0945) ;               pointer registers listed below are modified.  This does
09E8: 67       ASR   A             (0946) ;               not guarantee that in future implementations of this
                                   (0947) ;               function other page pointer registers will not be
09E9: 50 03    MOV   A,3           (0948) ;               modified.
09EB: 57 21    MOV   X,33          (0949) ;          
09ED: 7C 0C 66 LCALL 0x0C66        (0950) ;               Page Pointer Registers Modified: 
                                   (0951) ;               CUR_PP
09F0: 70 EF    AND   F,239         (0952) ;
                                   (0953) _LoadConfig_response2:
09F2: 41 B3 F0 AND   REG[179],240  (0954)  LoadConfig_response2:
09F5: 43 B3 05 OR    REG[179],5    (0955)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0956) 	M8C_SetBank1
09F8: 41 B4 F0 AND   REG[180],240  (0957) ; writing Port_0_DriveMode_0 register
09FB: 43 B4 05 OR    REG[180],5    (0958) 	and		reg[ 0h], ~1fh
                                   (0959) 	or		reg[ 0h],  1h
09FE: 41 B5 EC AND   REG[181],236  (0960) ; writing Port_0_DriveMode_1 register
0A01: 43 B5 12 OR    REG[181],18   (0961) 	and		reg[ 1h], ~1fh
                                   (0962) 	or		reg[ 1h], 1eh
0A04: 41 B6 EE AND   REG[182],238  (0963) ; writing Port_0_DriveMode_2 register
0A07: 43 B6 11 OR    REG[182],17   (0964) 	M8C_SetBank0
                                   (0965) 	and		reg[ 3h], ~1ah
0A0A: 41 B8 FC AND   REG[184],252  (0966) 	or		reg[ 3h], 1ah
                                   (0967) ; writing Port_0_GlobalSelect register
0A0D: 41 02 E5 AND   REG[2],229    (0968) 	and		reg[ 2h], ~1ah
0A10: 43 02 1A OR    REG[2],26     (0969) ; writing Row_0_LogicSelect_0 register
                                   (0970) 	and		reg[b3h], ~ fh
0A13: 41 03 E5 AND   REG[3],229    (0971) 	or		reg[b3h],  3h
                                   (0972) ; writing Row_0_LogicSelect_1 register
0A16: 71 10    OR    F,16          (0973) 	and		reg[b4h], ~ fh
0A18: 41 01 E0 AND   REG[1],224    (0974) 	or		reg[b4h],  3h
0A1B: 43 01 01 OR    REG[1],1      (0975) ; writing Row_0_OutputDrive_0 register
                                   (0976) 	and		reg[b5h], ~13h
0A1E: 41 00 E0 AND   REG[0],224    (0977) 	or		reg[b5h],  1h
0A21: 43 00 1E OR    REG[0],30     (0978) ; writing Row_0_OutputDrive_1 register
0A24: 70 EF    AND   F,239         (0979) 	and		reg[b6h], ~11h
                                   (0980) ; writing Row_1_InputMux register
0A26: 62 D0 00 MOV   REG[208],0    (0981) 	and		reg[b8h], ~ 3h
0A29: 26 04 DF AND   [4],223       (0982) 	or		reg[b8h],  1h
0A2C: 70 EF    AND   F,239         (0983) 
0A2E: 20       POP   X             (0984) 	push	x
                                   (0985)     M8C_SetBank0                    ; Force bank 0
                                   (0986)     mov     a, 0                    ; Specify bank 0
0A2F: 7F       RET                 (0987)     asr     a                       ; Store in carry flag
                                   (0988)                                     ; Load bank 0 table:
                                   (0989)     mov     A, >LoadConfigTBL_response2_Bank0
                                   (0990)     mov     X, <LoadConfigTBL_response2_Bank0
                                   (0991)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0992) 
                                   (0993)     mov     a, 1                    ; Specify bank 1
                                   (0994)     asr     a                       ; Store in carry flag
                                   (0995)                                     ; Load bank 1 table:
                                   (0996)     mov     A, >LoadConfigTBL_response2_Bank1
                                   (0997)     mov     X, <LoadConfigTBL_response2_Bank1
                                   (0998)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0999) 
                                   (1000) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1001) ; set config active bit
                                   (1002) 	or		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
                                   (1003)     M8C_SetBank0                    ; Force return to bank 0
                                   (1004) 	pop		x
                                   (1005) 
                                   (1006)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1007)     ret
                                   (1008) 
                                   (1009) ;---------------------------------------------------------------------------
                                   (1010) ; Unload Configuration response2
0A30: 71 10    OR    F,16          (1011) ;
                                   (1012) ;    Reset configuration registers for response2
0A32: 41 00 E0 AND   REG[0],224    (1013) ;    to their values as initially configured.
0A35: 43 00 01 OR    REG[0],1      (1014) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1015) ;
0A38: 41 01 E0 AND   REG[1],224    (1016) ;       INPUTS: None.
0A3B: 43 01 1E OR    REG[1],30     (1017) ;      RETURNS: Nothing.
                                   (1018) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A3E: 70 EF    AND   F,239         (1019) ;               modified as may the Page Pointer registers!
0A40: 41 03 E9 AND   REG[3],233    (1020) ;               In the large memory model currently only the page
0A43: 43 03 16 OR    REG[3],22     (1021) ;               pointer registers listed below are modified.  This does
                                   (1022) ;               not guarantee that in future implementations of this
0A46: 41 02 E9 AND   REG[2],233    (1023) ;               function other page pointer registers will not be
                                   (1024) ;               modified.
0A49: 41 B3 F0 AND   REG[179],240  (1025) ;          
0A4C: 43 B3 03 OR    REG[179],3    (1026) ;               Page Pointer Registers Modified: 
                                   (1027) ;               CUR_PP
0A4F: 41 B4 F0 AND   REG[180],240  (1028) ;
0A52: 43 B4 03 OR    REG[180],3    (1029) _UnloadConfig_response2:
                                   (1030)  UnloadConfig_response2:
0A55: 41 B5 EC AND   REG[181],236  (1031)     RAM_PROLOGUE RAM_USE_CLASS_4
0A58: 43 B5 01 OR    REG[181],1    (1032) 
                                   (1033) 	push	x
0A5B: 41 B6 EE AND   REG[182],238  (1034)     M8C_SetBank0                    ; Force bank 0
                                   (1035)     mov     a, 0                    ; Specify bank 0
0A5E: 41 B8 FC AND   REG[184],252  (1036)     asr     a                       ; Store in carry flag
0A61: 43 B8 01 OR    REG[184],1    (1037)                                     ; Bank 0 table address:
                                   (1038)     mov     A, >UnloadConfigTBL_response2_Bank0
0A64: 10       PUSH  X             (1039)     mov     X, <UnloadConfigTBL_response2_Bank0
0A65: 70 EF    AND   F,239         (1040)     lcall   LoadConfig              ; Unload the bank 0 values
0A67: 50 00    MOV   A,0           (1041) 
0A69: 67       ASR   A             (1042)     mov     a, 1                    ; Specify bank 1
                                   (1043)     asr     a                       ; Store in carry flag
0A6A: 50 03    MOV   A,3           (1044)                                     ; Bank 1 table address:
0A6C: 57 35    MOV   X,53          (1045)     mov     A, >UnloadConfigTBL_response2_Bank1
0A6E: 7C 0C 66 LCALL 0x0C66        (1046)     mov     X, <UnloadConfigTBL_response2_Bank1
                                   (1047)     lcall   LoadConfig              ; Unload the bank 1 values
0A71: 50 01    MOV   A,1           (1048) 
0A73: 67       ASR   A             (1049) 	M8C_SetBank0
                                   (1050) ; writing Row_0_LogicSelect_0 register
0A74: 50 03    MOV   A,3           (1051) 	and		reg[b3h], ~ fh
0A76: 57 48    MOV   X,72          (1052) 	or		reg[b3h],  5h
0A78: 7C 0C 66 LCALL 0x0C66        (1053) ; writing Row_0_LogicSelect_1 register
                                   (1054) 	and		reg[b4h], ~ fh
0A7B: 62 D0 00 MOV   REG[208],0    (1055) 	or		reg[b4h],  5h
                                   (1056) ; writing Row_0_OutputDrive_0 register
0A7E: 2E 04 40 OR    [4],64        (1057) 	and		reg[b5h], ~13h
0A81: 70 EF    AND   F,239         (1058) 	or		reg[b5h], 12h
0A83: 20       POP   X             (1059) ; writing Row_0_OutputDrive_1 register
                                   (1060) 	and		reg[b6h], ~11h
                                   (1061) 	or		reg[b6h], 11h
0A84: 7F       RET                 (1062) ; writing Row_1_InputMux register
                                   (1063) 	and		reg[b8h], ~ 3h
                                   (1064) ; writing Port_0_GlobalSelect register
                                   (1065) 	and		reg[ 2h], ~1ah
                                   (1066) 	or		reg[ 2h], 1ah
                                   (1067) ; writing Port_0_DriveMode_2 register
                                   (1068) 	and		reg[ 3h], ~1ah
                                   (1069) ; writing Port_0_DriveMode_1 register
                                   (1070) 	M8C_SetBank1
                                   (1071) 	and		reg[ 1h], ~1fh
                                   (1072) 	or		reg[ 1h],  1h
                                   (1073) ; writing Port_0_DriveMode_0 register
                                   (1074) 	and		reg[ 0h], ~1fh
                                   (1075) 	or		reg[ 0h], 1eh
                                   (1076) 	M8C_SetBank0
                                   (1077) ; clear config active bit
                                   (1078) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1079) 	and		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], ~response2_BIT
                                   (1080)     M8C_SetBank0                    ; Force return to bank 0
                                   (1081) 	pop		x
                                   (1082) 
                                   (1083)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1084)     ret
                                   (1085) 
                                   (1086) ;---------------------------------------------------------------------------
                                   (1087) ; Load Configuration response3
0A85: 10       PUSH  X             (1088) ;
0A86: 70 EF    AND   F,239         (1089) ;    Load configuration registers for response3.
0A88: 50 00    MOV   A,0           (1090) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0A8A: 67       ASR   A             (1091) ;
                                   (1092) ;       INPUTS: None.
0A8B: 50 03    MOV   A,3           (1093) ;      RETURNS: Nothing.
0A8D: 57 5B    MOV   X,91          (1094) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A8F: 7C 0C 66 LCALL 0x0C66        (1095) ;               modified as may the Page Pointer registers!
                                   (1096) ;               In the large memory model currently only the page
0A92: 50 01    MOV   A,1           (1097) ;               pointer registers listed below are modified.  This does
0A94: 67       ASR   A             (1098) ;               not guarantee that in future implementations of this
                                   (1099) ;               function other page pointer registers will not be
0A95: 50 03    MOV   A,3           (1100) ;               modified.
0A97: 57 62    MOV   X,98          (1101) ;          
0A99: 7C 0C 66 LCALL 0x0C66        (1102) ;               Page Pointer Registers Modified: 
                                   (1103) ;               CUR_PP
0A9C: 70 EF    AND   F,239         (1104) ;
                                   (1105) _LoadConfig_response3:
0A9E: 41 B3 F0 AND   REG[179],240  (1106)  LoadConfig_response3:
0AA1: 43 B3 05 OR    REG[179],5    (1107)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1108) 	M8C_SetBank1
0AA4: 41 B4 F0 AND   REG[180],240  (1109) ; writing Port_0_DriveMode_0 register
0AA7: 43 B4 05 OR    REG[180],5    (1110) 	and		reg[ 0h], ~1fh
                                   (1111) 	or		reg[ 0h],  1h
0AAA: 41 B5 EC AND   REG[181],236  (1112) ; writing Port_0_DriveMode_1 register
0AAD: 43 B5 12 OR    REG[181],18   (1113) 	and		reg[ 1h], ~1fh
                                   (1114) 	or		reg[ 1h], 1eh
0AB0: 41 B6 EE AND   REG[182],238  (1115) ; writing Port_0_DriveMode_2 register
0AB3: 43 B6 11 OR    REG[182],17   (1116) 	M8C_SetBank0
                                   (1117) 	and		reg[ 3h], ~16h
0AB6: 41 B8 FC AND   REG[184],252  (1118) 	or		reg[ 3h], 16h
                                   (1119) ; writing Port_0_GlobalSelect register
0AB9: 41 02 E9 AND   REG[2],233    (1120) 	and		reg[ 2h], ~16h
0ABC: 43 02 16 OR    REG[2],22     (1121) ; writing Row_0_LogicSelect_0 register
                                   (1122) 	and		reg[b3h], ~ fh
0ABF: 41 03 E9 AND   REG[3],233    (1123) 	or		reg[b3h],  3h
                                   (1124) ; writing Row_0_LogicSelect_1 register
0AC2: 71 10    OR    F,16          (1125) 	and		reg[b4h], ~ fh
0AC4: 41 01 E0 AND   REG[1],224    (1126) 	or		reg[b4h],  3h
0AC7: 43 01 01 OR    REG[1],1      (1127) ; writing Row_0_OutputDrive_0 register
                                   (1128) 	and		reg[b5h], ~13h
0ACA: 41 00 E0 AND   REG[0],224    (1129) 	or		reg[b5h],  1h
0ACD: 43 00 1E OR    REG[0],30     (1130) ; writing Row_0_OutputDrive_1 register
0AD0: 70 EF    AND   F,239         (1131) 	and		reg[b6h], ~11h
                                   (1132) ; writing Row_1_InputMux register
0AD2: 62 D0 00 MOV   REG[208],0    (1133) 	and		reg[b8h], ~ 3h
0AD5: 26 04 BF AND   [4],191       (1134) 	or		reg[b8h],  1h
0AD8: 70 EF    AND   F,239         (1135) 
0ADA: 20       POP   X             (1136) 	push	x
                                   (1137)     M8C_SetBank0                    ; Force bank 0
                                   (1138)     mov     a, 0                    ; Specify bank 0
0ADB: 7F       RET                 (1139)     asr     a                       ; Store in carry flag
                                   (1140)                                     ; Load bank 0 table:
                                   (1141)     mov     A, >LoadConfigTBL_response3_Bank0
                                   (1142)     mov     X, <LoadConfigTBL_response3_Bank0
                                   (1143)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1144) 
                                   (1145)     mov     a, 1                    ; Specify bank 1
                                   (1146)     asr     a                       ; Store in carry flag
                                   (1147)                                     ; Load bank 1 table:
                                   (1148)     mov     A, >LoadConfigTBL_response3_Bank1
                                   (1149)     mov     X, <LoadConfigTBL_response3_Bank1
                                   (1150)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1151) 
                                   (1152) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1153) ; set config active bit
                                   (1154) 	or		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
                                   (1155)     M8C_SetBank0                    ; Force return to bank 0
                                   (1156) 	pop		x
                                   (1157) 
                                   (1158)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1159)     ret
                                   (1160) 
                                   (1161) ;---------------------------------------------------------------------------
                                   (1162) ; Unload Configuration response3
0ADC: 71 10    OR    F,16          (1163) ;
                                   (1164) ;    Reset configuration registers for response3
0ADE: 41 00 E0 AND   REG[0],224    (1165) ;    to their values as initially configured.
0AE1: 43 00 01 OR    REG[0],1      (1166) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1167) ;
0AE4: 41 01 E0 AND   REG[1],224    (1168) ;       INPUTS: None.
0AE7: 43 01 1E OR    REG[1],30     (1169) ;      RETURNS: Nothing.
                                   (1170) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AEA: 70 EF    AND   F,239         (1171) ;               modified as may the Page Pointer registers!
0AEC: 41 03 F1 AND   REG[3],241    (1172) ;               In the large memory model currently only the page
0AEF: 43 03 0E OR    REG[3],14     (1173) ;               pointer registers listed below are modified.  This does
                                   (1174) ;               not guarantee that in future implementations of this
0AF2: 41 02 F1 AND   REG[2],241    (1175) ;               function other page pointer registers will not be
                                   (1176) ;               modified.
0AF5: 41 B0 FC AND   REG[176],252  (1177) ;          
0AF8: 43 B0 01 OR    REG[176],1    (1178) ;               Page Pointer Registers Modified: 
                                   (1179) ;               CUR_PP
0AFB: 41 B3 F0 AND   REG[179],240  (1180) ;
0AFE: 43 B3 03 OR    REG[179],3    (1181) _UnloadConfig_response3:
                                   (1182)  UnloadConfig_response3:
0B01: 41 B4 F0 AND   REG[180],240  (1183)     RAM_PROLOGUE RAM_USE_CLASS_4
0B04: 43 B4 03 OR    REG[180],3    (1184) 
                                   (1185) 	push	x
0B07: 41 B5 EC AND   REG[181],236  (1186)     M8C_SetBank0                    ; Force bank 0
0B0A: 43 B5 01 OR    REG[181],1    (1187)     mov     a, 0                    ; Specify bank 0
                                   (1188)     asr     a                       ; Store in carry flag
0B0D: 41 B6 EE AND   REG[182],238  (1189)                                     ; Bank 0 table address:
                                   (1190)     mov     A, >UnloadConfigTBL_response3_Bank0
0B10: 41 B8 FC AND   REG[184],252  (1191)     mov     X, <UnloadConfigTBL_response3_Bank0
0B13: 43 B8 01 OR    REG[184],1    (1192)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1193) 
0B16: 10       PUSH  X             (1194)     mov     a, 1                    ; Specify bank 1
0B17: 70 EF    AND   F,239         (1195)     asr     a                       ; Store in carry flag
0B19: 50 00    MOV   A,0           (1196)                                     ; Bank 1 table address:
0B1B: 67       ASR   A             (1197)     mov     A, >UnloadConfigTBL_response3_Bank1
                                   (1198)     mov     X, <UnloadConfigTBL_response3_Bank1
0B1C: 50 03    MOV   A,3           (1199)     lcall   LoadConfig              ; Unload the bank 1 values
0B1E: 57 76    MOV   X,118         (1200) 
0B20: 7C 0C 66 LCALL 0x0C66        (1201) 	M8C_SetBank0
                                   (1202) ; writing Row_0_LogicSelect_0 register
0B23: 50 01    MOV   A,1           (1203) 	and		reg[b3h], ~ fh
0B25: 67       ASR   A             (1204) 	or		reg[b3h],  5h
                                   (1205) ; writing Row_0_LogicSelect_1 register
0B26: 50 03    MOV   A,3           (1206) 	and		reg[b4h], ~ fh
0B28: 57 89    MOV   X,137         (1207) 	or		reg[b4h],  5h
0B2A: 7C 0C 66 LCALL 0x0C66        (1208) ; writing Row_0_OutputDrive_0 register
                                   (1209) 	and		reg[b5h], ~13h
0B2D: 62 D0 00 MOV   REG[208],0    (1210) 	or		reg[b5h], 12h
                                   (1211) ; writing Row_0_OutputDrive_1 register
0B30: 2E 04 80 OR    [4],128       (1212) 	and		reg[b6h], ~11h
0B33: 70 EF    AND   F,239         (1213) 	or		reg[b6h], 11h
0B35: 20       POP   X             (1214) ; writing Row_1_InputMux register
                                   (1215) 	and		reg[b8h], ~ 3h
                                   (1216) ; writing Port_0_GlobalSelect register
0B36: 7F       RET                 (1217) 	and		reg[ 2h], ~16h
                                   (1218) 	or		reg[ 2h], 16h
                                   (1219) ; writing Port_0_DriveMode_2 register
                                   (1220) 	and		reg[ 3h], ~16h
                                   (1221) ; writing Port_0_DriveMode_1 register
                                   (1222) 	M8C_SetBank1
                                   (1223) 	and		reg[ 1h], ~1fh
                                   (1224) 	or		reg[ 1h],  1h
                                   (1225) ; writing Port_0_DriveMode_0 register
                                   (1226) 	and		reg[ 0h], ~1fh
                                   (1227) 	or		reg[ 0h], 1eh
                                   (1228) 	M8C_SetBank0
                                   (1229) ; clear config active bit
                                   (1230) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1231) 	and		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], ~response3_BIT
                                   (1232)     M8C_SetBank0                    ; Force return to bank 0
                                   (1233) 	pop		x
                                   (1234) 
                                   (1235)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1236)     ret
                                   (1237) 
                                   (1238) ;---------------------------------------------------------------------------
                                   (1239) ; Load Configuration response4
                                   (1240) ;
                                   (1241) ;    Load configuration registers for response4.
                                   (1242) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0B37: 10       PUSH  X             (1243) ;
0B38: 70 EF    AND   F,239         (1244) ;       INPUTS: None.
0B3A: 50 00    MOV   A,0           (1245) ;      RETURNS: Nothing.
0B3C: 67       ASR   A             (1246) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (1247) ;               modified as may the Page Pointer registers!
0B3D: 50 03    MOV   A,3           (1248) ;               In the large memory model currently only the page
0B3F: 57 9C    MOV   X,156         (1249) ;               pointer registers listed below are modified.  This does
0B41: 7C 0C 66 LCALL 0x0C66        (1250) ;               not guarantee that in future implementations of this
                                   (1251) ;               function other page pointer registers will not be
0B44: 50 01    MOV   A,1           (1252) ;               modified.
0B46: 67       ASR   A             (1253) ;          
                                   (1254) ;               Page Pointer Registers Modified: 
0B47: 50 03    MOV   A,3           (1255) ;               CUR_PP
0B49: 57 A3    MOV   X,163         (1256) ;
0B4B: 7C 0C 66 LCALL 0x0C66        (1257) _LoadConfig_response4:
                                   (1258)  LoadConfig_response4:
0B4E: 70 EF    AND   F,239         (1259)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1260) 	M8C_SetBank1
0B50: 41 B0 FC AND   REG[176],252  (1261) ; writing Port_0_DriveMode_0 register
                                   (1262) 	and		reg[ 0h], ~1fh
0B53: 41 B3 F0 AND   REG[179],240  (1263) 	or		reg[ 0h],  1h
0B56: 43 B3 05 OR    REG[179],5    (1264) ; writing Port_0_DriveMode_1 register
                                   (1265) 	and		reg[ 1h], ~1fh
0B59: 41 B4 F0 AND   REG[180],240  (1266) 	or		reg[ 1h], 1eh
0B5C: 43 B4 05 OR    REG[180],5    (1267) ; writing Port_0_DriveMode_2 register
                                   (1268) 	M8C_SetBank0
0B5F: 41 B5 EC AND   REG[181],236  (1269) 	and		reg[ 3h], ~ eh
0B62: 43 B5 12 OR    REG[181],18   (1270) 	or		reg[ 3h],  eh
                                   (1271) ; writing Port_0_GlobalSelect register
0B65: 41 B6 EE AND   REG[182],238  (1272) 	and		reg[ 2h], ~ eh
0B68: 43 B6 11 OR    REG[182],17   (1273) ; writing Row_0_InputMux register
                                   (1274) 	and		reg[b0h], ~ 3h
0B6B: 41 B8 FC AND   REG[184],252  (1275) 	or		reg[b0h],  1h
                                   (1276) ; writing Row_0_LogicSelect_0 register
0B6E: 41 02 F1 AND   REG[2],241    (1277) 	and		reg[b3h], ~ fh
0B71: 43 02 0E OR    REG[2],14     (1278) 	or		reg[b3h],  3h
                                   (1279) ; writing Row_0_LogicSelect_1 register
0B74: 41 03 F1 AND   REG[3],241    (1280) 	and		reg[b4h], ~ fh
                                   (1281) 	or		reg[b4h],  3h
0B77: 71 10    OR    F,16          (1282) ; writing Row_0_OutputDrive_0 register
0B79: 41 01 E0 AND   REG[1],224    (1283) 	and		reg[b5h], ~13h
0B7C: 43 01 01 OR    REG[1],1      (1284) 	or		reg[b5h],  1h
                                   (1285) ; writing Row_0_OutputDrive_1 register
0B7F: 41 00 E0 AND   REG[0],224    (1286) 	and		reg[b6h], ~11h
0B82: 43 00 1E OR    REG[0],30     (1287) ; writing Row_1_InputMux register
0B85: 70 EF    AND   F,239         (1288) 	and		reg[b8h], ~ 3h
                                   (1289) 	or		reg[b8h],  1h
0B87: 62 D0 00 MOV   REG[208],0    (1290) 
0B8A: 26 04 7F AND   [4],127       (1291) 	push	x
0B8D: 70 EF    AND   F,239         (1292)     M8C_SetBank0                    ; Force bank 0
0B8F: 20       POP   X             (1293)     mov     a, 0                    ; Specify bank 0
                                   (1294)     asr     a                       ; Store in carry flag
                                   (1295)                                     ; Load bank 0 table:
0B90: 7F       RET                 (1296)     mov     A, >LoadConfigTBL_response4_Bank0
                                   (1297)     mov     X, <LoadConfigTBL_response4_Bank0
                                   (1298)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1299) 
                                   (1300)     mov     a, 1                    ; Specify bank 1
                                   (1301)     asr     a                       ; Store in carry flag
                                   (1302)                                     ; Load bank 1 table:
                                   (1303)     mov     A, >LoadConfigTBL_response4_Bank1
                                   (1304)     mov     X, <LoadConfigTBL_response4_Bank1
                                   (1305)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1306) 
                                   (1307) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1308) ; set config active bit
                                   (1309) 	or		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
                                   (1310)     M8C_SetBank0                    ; Force return to bank 0
                                   (1311) 	pop		x
                                   (1312) 
                                   (1313)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1314)     ret
                                   (1315) 
                                   (1316) ;---------------------------------------------------------------------------
                                   (1317) ; Unload Configuration response4
                                   (1318) ;
                                   (1319) ;    Reset configuration registers for response4
0B91: 71 10    OR    F,16          (1320) ;    to their values as initially configured.
                                   (1321) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0B93: 41 00 E0 AND   REG[0],224    (1322) ;
0B96: 43 00 01 OR    REG[0],1      (1323) ;       INPUTS: None.
                                   (1324) ;      RETURNS: Nothing.
0B99: 41 01 E0 AND   REG[1],224    (1325) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0B9C: 43 01 1E OR    REG[1],30     (1326) ;               modified as may the Page Pointer registers!
                                   (1327) ;               In the large memory model currently only the page
0B9F: 70 EF    AND   F,239         (1328) ;               pointer registers listed below are modified.  This does
0BA1: 41 03 E1 AND   REG[3],225    (1329) ;               not guarantee that in future implementations of this
0BA4: 43 03 1E OR    REG[3],30     (1330) ;               function other page pointer registers will not be
                                   (1331) ;               modified.
0BA7: 41 02 E1 AND   REG[2],225    (1332) ;          
                                   (1333) ;               Page Pointer Registers Modified: 
0BAA: 41 B3 F0 AND   REG[179],240  (1334) ;               CUR_PP
0BAD: 43 B3 03 OR    REG[179],3    (1335) ;
                                   (1336) _UnloadConfig_response4:
0BB0: 41 B4 F0 AND   REG[180],240  (1337)  UnloadConfig_response4:
0BB3: 43 B4 03 OR    REG[180],3    (1338)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1339) 
0BB6: 41 B5 EC AND   REG[181],236  (1340) 	push	x
0BB9: 43 B5 01 OR    REG[181],1    (1341)     M8C_SetBank0                    ; Force bank 0
                                   (1342)     mov     a, 0                    ; Specify bank 0
0BBC: 41 B6 EE AND   REG[182],238  (1343)     asr     a                       ; Store in carry flag
                                   (1344)                                     ; Bank 0 table address:
0BBF: 41 B8 FC AND   REG[184],252  (1345)     mov     A, >UnloadConfigTBL_response4_Bank0
0BC2: 43 B8 01 OR    REG[184],1    (1346)     mov     X, <UnloadConfigTBL_response4_Bank0
                                   (1347)     lcall   LoadConfig              ; Unload the bank 0 values
0BC5: 10       PUSH  X             (1348) 
0BC6: 70 EF    AND   F,239         (1349)     mov     a, 1                    ; Specify bank 1
0BC8: 50 00    MOV   A,0           (1350)     asr     a                       ; Store in carry flag
0BCA: 67       ASR   A             (1351)                                     ; Bank 1 table address:
                                   (1352)     mov     A, >UnloadConfigTBL_response4_Bank1
0BCB: 50 03    MOV   A,3           (1353)     mov     X, <UnloadConfigTBL_response4_Bank1
0BCD: 57 B7    MOV   X,183         (1354)     lcall   LoadConfig              ; Unload the bank 1 values
0BCF: 7C 0C 66 LCALL 0x0C66        (1355) 
                                   (1356) 	M8C_SetBank0
0BD2: 50 01    MOV   A,1           (1357) ; writing Row_0_InputMux register
0BD4: 67       ASR   A             (1358) 	and		reg[b0h], ~ 3h
                                   (1359) ; writing Row_0_LogicSelect_0 register
0BD5: 50 03    MOV   A,3           (1360) 	and		reg[b3h], ~ fh
0BD7: 57 BE    MOV   X,190         (1361) 	or		reg[b3h],  5h
0BD9: 7C 0C 66 LCALL 0x0C66        (1362) ; writing Row_0_LogicSelect_1 register
                                   (1363) 	and		reg[b4h], ~ fh
0BDC: 62 D0 00 MOV   REG[208],0    (1364) 	or		reg[b4h],  5h
                                   (1365) ; writing Row_0_OutputDrive_0 register
0BDF: 2E 05 01 OR    [5],1         (1366) 	and		reg[b5h], ~13h
0BE2: 70 EF    AND   F,239         (1367) 	or		reg[b5h], 12h
0BE4: 20       POP   X             (1368) ; writing Row_0_OutputDrive_1 register
                                   (1369) 	and		reg[b6h], ~11h
                                   (1370) 	or		reg[b6h], 11h
0BE5: 7F       RET                 (1371) ; writing Row_1_InputMux register
                                   (1372) 	and		reg[b8h], ~ 3h
                                   (1373) ; writing Port_0_GlobalSelect register
                                   (1374) 	and		reg[ 2h], ~ eh
                                   (1375) 	or		reg[ 2h],  eh
                                   (1376) ; writing Port_0_DriveMode_2 register
                                   (1377) 	and		reg[ 3h], ~ eh
                                   (1378) ; writing Port_0_DriveMode_1 register
                                   (1379) 	M8C_SetBank1
                                   (1380) 	and		reg[ 1h], ~1fh
                                   (1381) 	or		reg[ 1h],  1h
                                   (1382) ; writing Port_0_DriveMode_0 register
                                   (1383) 	and		reg[ 0h], ~1fh
                                   (1384) 	or		reg[ 0h], 1eh
                                   (1385) 	M8C_SetBank0
                                   (1386) ; clear config active bit
                                   (1387) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1388) 	and		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], ~response4_BIT
                                   (1389)     M8C_SetBank0                    ; Force return to bank 0
                                   (1390) 	pop		x
                                   (1391) 
                                   (1392)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1393)     ret
                                   (1394) 
                                   (1395) ;---------------------------------------------------------------------------
                                   (1396) ; Load Configuration servo_transmit
0BE6: 10       PUSH  X             (1397) ;
0BE7: 70 EF    AND   F,239         (1398) ;    Load configuration registers for servo_transmit.
0BE9: 50 00    MOV   A,0           (1399) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0BEB: 67       ASR   A             (1400) ;
                                   (1401) ;       INPUTS: None.
0BEC: 50 03    MOV   A,3           (1402) ;      RETURNS: Nothing.
0BEE: 57 C5    MOV   X,197         (1403) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0BF0: 7C 0C 66 LCALL 0x0C66        (1404) ;               modified as may the Page Pointer registers!
                                   (1405) ;               In the large memory model currently only the page
0BF3: 50 01    MOV   A,1           (1406) ;               pointer registers listed below are modified.  This does
0BF5: 67       ASR   A             (1407) ;               not guarantee that in future implementations of this
                                   (1408) ;               function other page pointer registers will not be
0BF6: 50 03    MOV   A,3           (1409) ;               modified.
0BF8: 57 C8    MOV   X,200         (1410) ;          
0BFA: 7C 0C 66 LCALL 0x0C66        (1411) ;               Page Pointer Registers Modified: 
                                   (1412) ;               CUR_PP
0BFD: 70 EF    AND   F,239         (1413) ;
                                   (1414) _LoadConfig_servo_transmit:
0BFF: 41 B3 F0 AND   REG[179],240  (1415)  LoadConfig_servo_transmit:
0C02: 43 B3 05 OR    REG[179],5    (1416)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1417) 	M8C_SetBank1
0C05: 41 B4 F0 AND   REG[180],240  (1418) ; writing Port_0_DriveMode_0 register
0C08: 43 B4 05 OR    REG[180],5    (1419) 	and		reg[ 0h], ~1fh
                                   (1420) 	or		reg[ 0h],  1h
0C0B: 41 B5 EC AND   REG[181],236  (1421) ; writing Port_0_DriveMode_1 register
0C0E: 43 B5 12 OR    REG[181],18   (1422) 	and		reg[ 1h], ~1fh
                                   (1423) 	or		reg[ 1h], 1eh
0C11: 41 B6 EE AND   REG[182],238  (1424) ; writing Port_0_DriveMode_2 register
0C14: 43 B6 11 OR    REG[182],17   (1425) 	M8C_SetBank0
                                   (1426) 	and		reg[ 3h], ~1eh
0C17: 41 B8 FC AND   REG[184],252  (1427) 	or		reg[ 3h], 1eh
                                   (1428) ; writing Port_0_GlobalSelect register
0C1A: 41 02 E1 AND   REG[2],225    (1429) 	and		reg[ 2h], ~1eh
0C1D: 43 02 1E OR    REG[2],30     (1430) ; writing Row_0_LogicSelect_0 register
                                   (1431) 	and		reg[b3h], ~ fh
0C20: 41 03 E1 AND   REG[3],225    (1432) 	or		reg[b3h],  3h
                                   (1433) ; writing Row_0_LogicSelect_1 register
0C23: 71 10    OR    F,16          (1434) 	and		reg[b4h], ~ fh
0C25: 41 01 E0 AND   REG[1],224    (1435) 	or		reg[b4h],  3h
0C28: 43 01 01 OR    REG[1],1      (1436) ; writing Row_0_OutputDrive_0 register
                                   (1437) 	and		reg[b5h], ~13h
0C2B: 41 00 E0 AND   REG[0],224    (1438) 	or		reg[b5h],  1h
0C2E: 43 00 1E OR    REG[0],30     (1439) ; writing Row_0_OutputDrive_1 register
0C31: 70 EF    AND   F,239         (1440) 	and		reg[b6h], ~11h
                                   (1441) ; writing Row_1_InputMux register
0C33: 62 D0 00 MOV   REG[208],0    (1442) 	and		reg[b8h], ~ 3h
0C36: 26 05 FE AND   [5],254       (1443) 	or		reg[b8h],  1h
0C39: 70 EF    AND   F,239         (1444) 
0C3B: 20       POP   X             (1445) 	push	x
                                   (1446)     M8C_SetBank0                    ; Force bank 0
                                   (1447)     mov     a, 0                    ; Specify bank 0
0C3C: 7F       RET                 (1448)     asr     a                       ; Store in carry flag
                                   (1449)                                     ; Load bank 0 table:
                                   (1450)     mov     A, >LoadConfigTBL_servo_transmit_Bank0
                                   (1451)     mov     X, <LoadConfigTBL_servo_transmit_Bank0
                                   (1452)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1453) 
                                   (1454)     mov     a, 1                    ; Specify bank 1
                                   (1455)     asr     a                       ; Store in carry flag
                                   (1456)                                     ; Load bank 1 table:
                                   (1457)     mov     A, >LoadConfigTBL_servo_transmit_Bank1
                                   (1458)     mov     X, <LoadConfigTBL_servo_transmit_Bank1
                                   (1459)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1460) 
                                   (1461) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1462) ; set config active bit
                                   (1463) 	or		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
                                   (1464)     M8C_SetBank0                    ; Force return to bank 0
                                   (1465) 	pop		x
                                   (1466) 
                                   (1467)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1468)     ret
                                   (1469) 
                                   (1470) ;---------------------------------------------------------------------------
                                   (1471) ; Unload Configuration servo_transmit
                                   (1472) ;
                                   (1473) ;    Reset configuration registers for servo_transmit
0C3D: 10       PUSH  X             (1474) ;    to their values as initially configured.
0C3E: 70 EF    AND   F,239         (1475) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C40: 50 00    MOV   A,0           (1476) ;
0C42: 67       ASR   A             (1477) ;       INPUTS: None.
                                   (1478) ;      RETURNS: Nothing.
0C43: 50 05    MOV   A,5           (1479) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C45: 57 B2    MOV   X,178         (1480) ;               modified as may the Page Pointer registers!
0C47: 7C 0C 66 LCALL 0x0C66        (1481) ;               In the large memory model currently only the page
                                   (1482) ;               pointer registers listed below are modified.  This does
0C4A: 50 01    MOV   A,1           (1483) ;               not guarantee that in future implementations of this
0C4C: 67       ASR   A             (1484) ;               function other page pointer registers will not be
                                   (1485) ;               modified.
0C4D: 50 06    MOV   A,6           (1486) ;          
0C4F: 57 33    MOV   X,51          (1487) ;               Page Pointer Registers Modified: 
0C51: 7C 0C 66 LCALL 0x0C66        (1488) ;               CUR_PP
                                   (1489) ;
0C54: 70 EF    AND   F,239         (1490) _UnloadConfig_servo_transmit:
                                   (1491)  UnloadConfig_servo_transmit:
0C56: 62 D0 00 MOV   REG[208],0    (1492)     RAM_PROLOGUE RAM_USE_CLASS_4
0C59: 55 04 00 MOV   [4],0         (1493) 
0C5C: 62 D0 00 MOV   REG[208],0    (1494) 	push	x
0C5F: 55 05 00 MOV   [5],0         (1495)     M8C_SetBank0                    ; Force bank 0
0C62: 70 EF    AND   F,239         (1496)     mov     a, 0                    ; Specify bank 0
0C64: 20       POP   X             (1497)     asr     a                       ; Store in carry flag
                                   (1498)                                     ; Bank 0 table address:
                                   (1499)     mov     A, >UnloadConfigTBL_servo_transmit_Bank0
0C65: 7F       RET                 (1500)     mov     X, <UnloadConfigTBL_servo_transmit_Bank0
                                   (1501)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1502) 
                                   (1503)     mov     a, 1                    ; Specify bank 1
                                   (1504)     asr     a                       ; Store in carry flag
                                   (1505)                                     ; Bank 1 table address:
                                   (1506)     mov     A, >UnloadConfigTBL_servo_transmit_Bank1
                                   (1507)     mov     X, <UnloadConfigTBL_servo_transmit_Bank1
                                   (1508)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1509) 
                                   (1510) 	M8C_SetBank0
                                   (1511) ; writing Row_0_LogicSelect_0 register
                                   (1512) 	and		reg[b3h], ~ fh
                                   (1513) 	or		reg[b3h],  5h
                                   (1514) ; writing Row_0_LogicSelect_1 register
                                   (1515) 	and		reg[b4h], ~ fh
                                   (1516) 	or		reg[b4h],  5h
                                   (1517) ; writing Row_0_OutputDrive_0 register
                                   (1518) 	and		reg[b5h], ~13h
                                   (1519) 	or		reg[b5h], 12h
                                   (1520) ; writing Row_0_OutputDrive_1 register
                                   (1521) 	and		reg[b6h], ~11h
0C66: 38 02    ADD   SP,2          (1522) 	or		reg[b6h], 11h
0C68: 10       PUSH  X             (1523) ; writing Row_1_InputMux register
0C69: 08       PUSH  A             (1524) 	and		reg[b8h], ~ 3h
0C6A: 4F       MOV   X,SP          (1525) ; writing Port_0_GlobalSelect register
0C6B: 56 FC 00 MOV   [X-4],0       (1526) 	and		reg[ 2h], ~1eh
0C6E: D0 04    JNC   0x0C73        (1527) 	or		reg[ 2h], 1eh
0C70: 56 FC 01 MOV   [X-4],1       (1528) ; writing Port_0_DriveMode_2 register
                                   (1529) 	and		reg[ 3h], ~1eh
0C73: 18       POP   A             (1530) ; writing Port_0_DriveMode_1 register
0C74: 20       POP   X             (1531) 	M8C_SetBank1
                                   (1532) 	and		reg[ 1h], ~1fh
                                   (1533) 	or		reg[ 1h],  1h
0C75: 70 EF    AND   F,239         (1534) ; writing Port_0_DriveMode_0 register
0C77: 62 E3 00 MOV   REG[227],0    (1535) 	and		reg[ 0h], ~1fh
0C7A: 10       PUSH  X             (1536) 	or		reg[ 0h], 1eh
0C7B: 08       PUSH  A             (1537) 	M8C_SetBank0
0C7C: 28       ROMX                (1538) ; clear config active bit
0C7D: 39 FF    CMP   A,255         (1539) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0C7F: A0 1F    JZ    0x0C9F        (1540) 	and		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], ~servo_transmit_BIT
0C81: 4F       MOV   X,SP          (1541)     M8C_SetBank0                    ; Force return to bank 0
0C82: 48 FC 01 TST   [X-4],1       (1542) 	pop		x
0C85: A0 03    JZ    0x0C89        (1543) 
0C87: 71 10    OR    F,16          (1544)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1545)     ret
0C89: 54 FD    MOV   [X-3],A       (1546) 
0C8B: 18       POP   A             (1547) ;---------------------------------------------------------------------------
0C8C: 20       POP   X             (1548) ; Unload Configuration Total
0C8D: 75       INC   X             (1549) ;
0C8E: 09 00    ADC   A,0           (1550) ;    Reset configuration registers for Total
0C90: 10       PUSH  X             (1551) ;    to their values as initially configured.
0C91: 08       PUSH  A             (1552) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C92: 28       ROMX                (1553) ;
0C93: 4F       MOV   X,SP          (1554) ;       INPUTS: None.
0C94: 59 FD    MOV   X,[X-3]       (1555) ;      RETURNS: Nothing.
0C96: 61 00    MOV   REG[X+0],A    (1556) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C98: 18       POP   A             (1557) ;               modified as may the Page Pointer registers!
0C99: 20       POP   X             (1558) ;               In the large memory model currently only the page
0C9A: 75       INC   X             (1559) ;               pointer registers listed below are modified.  This does
0C9B: 09 00    ADC   A,0           (1560) ;               not guarantee that in future implementations of this
0C9D: 8F D7    JMP   0x0C75        (1561) ;               function other page pointer registers will not be
                                   (1562) ;               modified.
0C9F: 38 FC    ADD   SP,252        (1563) ;          
0CA1: 70 3F    AND   F,63
0CA3: 71 C0    OR    F,192         (1564) ;               Page Pointer Registers Modified: 
0CA6: 08       PUSH  A             (1565) ;               CUR_PP

FILE: lib\wait_recvint.asm
0CA7: 10       PUSH  X             (0104) ;;*****************************************************************************
0CA8: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: WAIT_RECVINT.asm
0CAA: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0CAB: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0CAD: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0CAF: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0CB0: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0CB2: B0 04    JNZ   0x0CB7        (0115) 
0CB4: 18       POP   A             (0116) include "m8c.inc"
0CB5: 80 5E    JMP   0x0D14        (0117) include "memory.inc"
                                   (0118) include "WAIT_RECV.inc"
                                   (0119) 
                                   (0120) 
0CB7: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0CB8: 21 E0    AND   A,224         (0124) export  _WAIT_RECV_ISR
0CBA: A0 12    JZ    0x0CCD        (0125) 
                                   (0126) 
0CBC: 2C 00    OR    [0],A         (0127) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0128) export  WAIT_RECV_aRxBuffer
0CBE: 49 2A 00 TST   REG[42],0     (0129) export _WAIT_RECV_aRxBuffer
                                   (0130) export  WAIT_RECV_bRxCnt
0CC1: 21 20    AND   A,32          (0131) export _WAIT_RECV_bRxCnt
0CC3: A0 50    JZ    0x0D14        (0132) export  WAIT_RECV_fStatus
                                   (0133) export _WAIT_RECV_fStatus
                                   (0134) ENDIF
                                   (0135) 
0CC5: 41 2B FE AND   REG[43],254   (0136) 
0CC8: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0CCB: 80 48    JMP   0x0D14        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (WAIT_RECV_RXBUF_ENABLE)
0CCD: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  WAIT_RECV_fStatus:
                                   (0144) _WAIT_RECV_fStatus:      BLK  1
0CCF: 47 00 01 TST   [0],1         (0145)  WAIT_RECV_bRxCnt:
0CD2: B0 41    JNZ   0x0D14        (0146) _WAIT_RECV_bRxCnt:       BLK  1
                                   (0147) AREA WAIT_RECV_RAM(RAM,REL,CON)
0CD4: 39 00    CMP   A,0           (0148)  WAIT_RECV_aRxBuffer:    
0CD6: B0 14    JNZ   0x0CEB        (0149) _WAIT_RECV_aRxBuffer:    BLK WAIT_RECV_RX_BUFFER_SIZE
0CD8: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0CDB: 62 D3 00 MOV   REG[211],0    (0152) 
0CDE: 70 3F    AND   F,63
0CE0: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0CE2: 56 58 00 MOV   [X+88],0      (0154) 
0CE5: 70 3F    AND   F,63
0CE7: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0CE9: 80 2A    JMP   0x0D14        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0CEB: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0CEE: C0 14    JC    0x0D03        (0168) 
0CF0: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0CF3: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0CF6: 70 3F    AND   F,63
0CF8: 71 80    OR    F,128         (0172) ;------------------------
0CFA: 56 58 00 MOV   [X+88],0      (0173) 
0CFD: 70 3F    AND   F,63
0CFF: 71 00    OR    F,0           (0174) 
0D01: 80 12    JMP   0x0D14        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0D03: 75       INC   X             (0179) 
0D04: 5A 01    MOV   [1],X         (0180) 
0D06: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0D07: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0D0A: 70 3F    AND   F,63
0D0C: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _WAIT_RECV_ISR
0D0E: 54 58    MOV   [X+88],A      (0185) ;
0D10: 70 3F    AND   F,63
0D12: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0D14: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0D15: 60 D3    MOV   REG[211],A    (0191) _WAIT_RECV_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0D17: 20       POP   X             (0195)    ; Insert your custom code below this banner
0D18: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0D1A: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\wait_recv_timeout.asm
                                   (0102) ;;*****************************************************************************
0D1D: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: WAIT_RECV_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "WAIT_RECV_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0D1E: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0D21: 7F       RET                 (0131) export  WAIT_RECV_TIMEOUT_EnableInt
                                   (0132) export _WAIT_RECV_TIMEOUT_EnableInt
                                   (0133) export  WAIT_RECV_TIMEOUT_DisableInt
                                   (0134) export _WAIT_RECV_TIMEOUT_DisableInt
                                   (0135) export  WAIT_RECV_TIMEOUT_Start
                                   (0136) export _WAIT_RECV_TIMEOUT_Start
                                   (0137) export  WAIT_RECV_TIMEOUT_Stop
                                   (0138) export _WAIT_RECV_TIMEOUT_Stop
                                   (0139) export  WAIT_RECV_TIMEOUT_WritePeriod
                                   (0140) export _WAIT_RECV_TIMEOUT_WritePeriod
                                   (0141) export  WAIT_RECV_TIMEOUT_WriteCompareValue
                                   (0142) export _WAIT_RECV_TIMEOUT_WriteCompareValue
                                   (0143) export  WAIT_RECV_TIMEOUT_wReadCompareValue
                                   (0144) export _WAIT_RECV_TIMEOUT_wReadCompareValue
                                   (0145) export  WAIT_RECV_TIMEOUT_wReadTimer
                                   (0146) export _WAIT_RECV_TIMEOUT_wReadTimer
                                   (0147) export  WAIT_RECV_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _WAIT_RECV_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wWAIT_RECV_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wWAIT_RECV_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wWAIT_RECV_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wWAIT_RECV_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wWAIT_RECV_TIMEOUT_ReadTimerSaveCV   ; deprecated
0D22: 43 23 01 OR    REG[35],1     (0157) export _wWAIT_RECV_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0D25: 7F       RET                 (0159) export  wWAIT_RECV_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wWAIT_RECV_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wWAIT_RECV_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wWAIT_RECV_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA waiting_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0D26: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0D29: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  WAIT_RECV_TIMEOUT_EnableInt:
                                   (0200) _WAIT_RECV_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    WAIT_RECV_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0D2A: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0D2C: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0D2D: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0D2F: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  WAIT_RECV_TIMEOUT_DisableInt:
                                   (0228) _WAIT_RECV_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    WAIT_RECV_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0D30: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0D32: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0D33: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0D35: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  WAIT_RECV_TIMEOUT_Start:
                                   (0256) _WAIT_RECV_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    WAIT_RECV_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0D36: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0D38: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0D39: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0D3B: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  WAIT_RECV_TIMEOUT_Stop:
                                   (0284) _WAIT_RECV_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    WAIT_RECV_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  WAIT_RECV_TIMEOUT_WritePeriod:
                                   (0313) _WAIT_RECV_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[WAIT_RECV_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[WAIT_RECV_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call WAIT_RECV_TIMEOUT_Stop to disable).
0D3C: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0D3D: 38 03    ADD   SP,3          (0334) ;
0D3F: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0D41: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0D42: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0D44: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0D45: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0D47: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0D48: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0D4A: 5D 26    MOV   A,REG[38]     (0343) ;
0D4C: 54 01    MOV   [X+1],A       (0344)  WAIT_RECV_TIMEOUT_WriteCompareValue:
0D4E: 5D 22    MOV   A,REG[34]     (0345) _WAIT_RECV_TIMEOUT_WriteCompareValue:
0D50: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0D52: 50 00    MOV   A,0           (0347)    mov   reg[WAIT_RECV_TIMEOUT_COMPARE_LSB_REG], A
0D54: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0D57: A0 03    JZ    0x0D5B        (0349)    mov   reg[WAIT_RECV_TIMEOUT_COMPARE_MSB_REG], A
0D59: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0D5B: 54 00    MOV   [X+0],A       (0352) 
0D5D: 70 FE    AND   F,254         (0353) .ENDSECTION
0D5F: 41 23 FE AND   REG[35],254   (0354) 
0D62: 18       POP   A             (0355) 
0D63: 60 26    MOV   REG[38],A     (0356) .SECTION
0D65: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0D66: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_wReadCompareValue
0D68: 18       POP   A             (0359) ;
0D69: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0D6B: 18       POP   A             (0361) ;     Reads the Compare registers.
0D6C: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0D6D: 70 3F    AND   F,63
0D6F: 71 C0    OR    F,192         (0363) ;
0D71: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  WAIT_RECV_TIMEOUT_wReadCompareValue:
                                   (0374) _WAIT_RECV_TIMEOUT_wReadCompareValue:
                                   (0375)  wWAIT_RECV_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wWAIT_RECV_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[WAIT_RECV_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[WAIT_RECV_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: WAIT_RECV_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0D72: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0D74: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0D76: 5C       MOV   X,A           (0409) ;
0D77: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0D7A: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\wait_recv.asm
                                   (0121) ;;*****************************************************************************
0D7D: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: WAIT_RECV.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "WAIT_RECV.inc"
0D7E: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0D81: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   WAIT_RECV_EnableInt
                                   (0155) export  _WAIT_RECV_EnableInt
                                   (0156) export   WAIT_RECV_DisableInt
                                   (0157) export  _WAIT_RECV_DisableInt
                                   (0158) export   WAIT_RECV_Start
                                   (0159) export  _WAIT_RECV_Start
                                   (0160) export   WAIT_RECV_Stop
                                   (0161) export  _WAIT_RECV_Stop
                                   (0162) export   WAIT_RECV_bReadRxData
                                   (0163) export  _WAIT_RECV_bReadRxData
                                   (0164) export   WAIT_RECV_bReadRxStatus
                                   (0165) export  _WAIT_RECV_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bWAIT_RECV_ReadRxData
                                   (0170) export _bWAIT_RECV_ReadRxData
                                   (0171) export  bWAIT_RECV_ReadRxStatus
                                   (0172) export _bWAIT_RECV_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  WAIT_RECV_cGetChar
0D82: 29 01    OR    A,1           (0179) export _WAIT_RECV_cGetChar
0D84: 60 2B    MOV   REG[43],A     (0180) export  WAIT_RECV_cReadChar
                                   (0181) export _WAIT_RECV_cReadChar
0D86: 7F       RET                 (0182) export  WAIT_RECV_iReadChar
                                   (0183) export _WAIT_RECV_iReadChar
                                   (0184) 
                                   (0185) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0186) export  WAIT_RECV_CmdReset
                                   (0187) export _WAIT_RECV_CmdReset
                                   (0188) export  WAIT_RECV_bCmdCheck
                                   (0189) export _WAIT_RECV_bCmdCheck
                                   (0190) export  WAIT_RECV_bCmdLength
                                   (0191) export _WAIT_RECV_bCmdLength
                                   (0192) export  WAIT_RECV_bErrCheck
                                   (0193) export _WAIT_RECV_bErrCheck
                                   (0194) 
                                   (0195) export  WAIT_RECV_szGetParam
                                   (0196) export _WAIT_RECV_szGetParam
                                   (0197) export  WAIT_RECV_szGetRestOfParams
                                   (0198) export _WAIT_RECV_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA WAIT_RECV_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0D87: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0D8A: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: WAIT_RECV_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  WAIT_RECV_EnableInt:
                                   (0238) _WAIT_RECV_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0D8B: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0D8D: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: WAIT_RECV_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  WAIT_RECV_DisableInt:
                                   (0267) _WAIT_RECV_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0D8E: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0D90: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: WAIT_RECV_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  WAIT_RECV_Start:
                                   (0297) _WAIT_RECV_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[WAIT_RECV_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: WAIT_RECV_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0D91: 49 2B 08 TST   REG[43],8     (0311) ;
0D94: AF FC    JZ    0x0D91        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0D96: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0D98: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  WAIT_RECV_Stop:
                                   (0326) _WAIT_RECV_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[WAIT_RECV_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: WAIT_RECV_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0D99: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0D9B: 08       PUSH  A             (0347) ;
0D9C: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0D9E: B0 04    JNZ   0x0DA3        (0349) ;    The A and X registers may be modified by this or future implementations
0DA0: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0DA1: 80 0B    JMP   0x0DAD        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0DA3: 5D 2A    MOV   A,REG[42]     (0354) ;
0DA5: 4B       SWAP  A,X           (0355)  WAIT_RECV_bReadRxData:
                                   (0356) _WAIT_RECV_bReadRxData:
0DA6: 18       POP   A             (0357)  bWAIT_RECV_ReadRxData:
0DA7: 21 A0    AND   A,160         (0358) _bWAIT_RECV_ReadRxData:
0DA9: B0 03    JNZ   0x0DAD        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0DAB: 4B       SWAP  A,X           (0360)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0DAC: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0DAD: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: WAIT_RECV_bReadRxStatus
                                   (0368) ;
0DAF: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  WAIT_RECV_bReadRxStatus:
                                   (0388) _WAIT_RECV_bReadRxStatus:
                                   (0389)  bWAIT_RECV_ReadRxStatus:
                                   (0390) _bWAIT_RECV_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[WAIT_RECV_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: WAIT_RECV_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0DB0: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0DB2: 21 E8    AND   A,232         (0408) ;
0DB4: 08       PUSH  A             (0409) ;  ARGUMENTS:
0DB5: 21 08    AND   A,8           (0410) ;      none
0DB7: B0 07    JNZ   0x0DBF        (0411) ;
0DB9: 18       POP   A             (0412) ;  RETURNS:
0DBA: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0DBC: 4B       SWAP  A,X           (0414) ;
0DBD: 80 07    JMP   0x0DC5        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0DBF: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0DC0: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0DC2: 4B       SWAP  A,X           (0420) ;    functions.
0DC3: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0DC5: 7F       RET                 (0426)  WAIT_RECV_cGetChar:
                                   (0427) _WAIT_RECV_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[WAIT_RECV_CONTROL_REG],WAIT_RECV_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: WAIT_RECV_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  WAIT_RECV_cReadChar:
                                   (0463) _WAIT_RECV_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
0DC6: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0DC9: 55 58 00 MOV   [88],0        (0470)    pop  A
0DCC: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0DCF: 55 E5 00 MOV   [CHILD+2],0   (0472) 
0DD2: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0DD5: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
0DD8: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0DDB: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(WAIT_RECV_RX_PARITY_ERROR | WAIT_RECV_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_WAIT_RECV_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: WAIT_RECV_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0DDC: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0DDF: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0DE1: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0DE3: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  WAIT_RECV_iReadChar:
                                   (0523) _WAIT_RECV_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(WAIT_RECV_RX_ERROR|WAIT_RECV_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,WAIT_RECV_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_WAIT_RECV_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,WAIT_RECV_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_WAIT_RECV_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0552) .SECTION
0DE4: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0DE7: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0DE9: 21 F0    AND   A,240         (0555) ;
0DEB: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0DEE: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: WAIT_RECV_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  WAIT_RECV_CmdReset:
0DEF: 62 D0 00 MOV   REG[208],0    (0587) _WAIT_RECV_CmdReset:
0DF2: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >WAIT_RECV_aRxBuffer
0DF4: 7F       RET                 (0590)    mov [WAIT_RECV_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
                                   (0594)    mov [WAIT_RECV_bRxCnt], 0x00
                                   (0595)    and [WAIT_RECV_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: WAIT_RECV_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  WAIT_RECV_bCmdCheck:
                                   (0628) _WAIT_RECV_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0631)    mov A,  [WAIT_RECV_fStatus]
                                   (0632)    and A, WAIT_RECV_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: WAIT_RECV_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0DF5: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0DF7: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0DFA: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0DFD: 50 58    MOV   A,88          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0DFF: 02 E5    ADD   A,[CHILD+2]   (0649) ;                     Returns non-zero value in A if command is valid.
0E01: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0E02: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0E04: B0 04    JNZ   0x0E09        (0653) ;           0x10 => Software Buffer OverRun
0E06: 10       PUSH  X             (0654) ;
0E07: 80 33    JMP   0x0E3B        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0E09: 39 00    CMP   A,0           (0660) ;    functions.
0E0B: B0 11    JNZ   0x0E1D        (0661) ;          
0E0D: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0E0E: 76 E5    INC   [CHILD+2]     (0663) ;          CUR_PP
0E10: 52 00    MOV   A,[X+0]       (0664) ;
0E12: 3C E5 0F CMP   [CHILD+2],15  (0665) ;     Error Status is clear when read.
0E15: BF F3    JNZ   0x0E09        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0E17: 10       PUSH  X             (0669) ;
                                   (0670)  WAIT_RECV_bErrCheck:
0E18: 56 00 00 MOV   [X+0],0       (0671) _WAIT_RECV_bErrCheck:
0E1B: 80 1F    JMP   0x0E3B        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0674)    mov A,  [WAIT_RECV_fStatus]
0E1D: 10       PUSH  X             (0675)    and A, WAIT_RECV_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [WAIT_RECV_fStatus], ~WAIT_RECV_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0E1E: 75       INC   X             (0679) .ENDSECTION
0E1F: 76 E5    INC   [CHILD+2]     (0680) 
0E21: 3C E5 0F CMP   [CHILD+2],15  (0681) .SECTION
0E24: AF F3    JZ    0x0E18        (0682) ;-----------------------------------------------------------------------------
0E26: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: WAIT_RECV_bCmdLength
0E28: A0 12    JZ    0x0E3B        (0684) ;
0E2A: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0E2C: BF F1    JNZ   0x0E1E        (0686) ;     Get length of command string
                                   (0687) ;
0E2E: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0E31: 76 E5    INC   [CHILD+2]     (0689) ;     none.
0E33: 3C E5 0F CMP   [CHILD+2],15  (0690) ;
0E36: B0 04    JNZ   0x0E3B        (0691) ;  RETURNS:
0E38: 55 E5 0F MOV   [CHILD+2],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0E3B: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0E3C: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0E3D: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0E40: B0 0B    JNZ   0x0E4C        (0699) ;    functions.
0E42: 20       POP   X             (0700) ;          
0E43: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0E45: 50 00    MOV   A,0           (0702) ;          CUR_PP
0E47: 70 3F    AND   F,63
0E49: 71 C0    OR    F,192         (0703) ;
                                   (0704)  WAIT_RECV_bCmdLength:
0E4B: 7F       RET                 (0705) _WAIT_RECV_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
0E4C: 20       POP   X             (0708)    mov A,  [WAIT_RECV_bRxCnt]
0E4D: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0E4F: 70 3F    AND   F,63
0E51: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0E53: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: WAIT_RECV_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0E54: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0E57: 50 58    MOV   A,88          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0E59: 02 E5    ADD   A,[CHILD+2]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0E5B: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0E5C: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     WAIT_RECV_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, WAIT_RECV_szGetParam, is
0E60: 43 E1 04 OR    REG[225],4    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\tx_23.asm
                                   (0109) ;;*****************************************************************************
0E63: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_23.inc"
0E64: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0E67: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_23_SetTxIntMode
                                   (0143) export  _TX_23_SetTxIntMode
                                   (0144) export   TX_23_EnableInt
                                   (0145) export  _TX_23_EnableInt
                                   (0146) export   TX_23_DisableInt
                                   (0147) export  _TX_23_DisableInt
                                   (0148) export   TX_23_Start
                                   (0149) export  _TX_23_Start
                                   (0150) export   TX_23_Stop
                                   (0151) export  _TX_23_Stop
                                   (0152) export   TX_23_SendData
                                   (0153) export  _TX_23_SendData
                                   (0154) export   TX_23_bReadTxStatus
                                   (0155) export  _TX_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_23_ReadTxStatus
                                   (0160) export  _bTX_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_23_PutSHexByte
                                   (0166) export _TX_23_PutSHexByte
                                   (0167) export  TX_23_PutSHexInt
                                   (0168) export _TX_23_PutSHexInt
                                   (0169) 
0E68: 71 10    OR    F,16          (0170) export  TX_23_CPutString
0E6A: 21 01    AND   A,1           (0171) export _TX_23_CPutString
0E6C: A0 07    JZ    0x0E74        (0172) export  TX_23_PutString
0E6E: 43 28 10 OR    REG[40],16    (0173) export _TX_23_PutString
0E71: 70 EF    AND   F,239         (0174) export  TX_23_PutChar
                                   (0175) export _TX_23_PutChar
0E73: 7F       RET                 (0176) export  TX_23_Write
                                   (0177) export _TX_23_Write
                                   (0178) export  TX_23_CWrite
0E74: 41 28 EF AND   REG[40],239   (0179) export _TX_23_CWrite
0E77: 70 EF    AND   F,239         (0180) export  TX_23_PutCRLF
                                   (0181) export _TX_23_PutCRLF 
0E79: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0E7A: 29 01    OR    A,1           (0211) ;    functions.
0E7C: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_23_EnableInt:
0E7E: 7F       RET                 (0214) _TX_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_23_INT_REG, TX_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0E7F: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0E82: 7F       RET                 (0242)  TX_23_DisableInt:
                                   (0243) _TX_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_23_INT_REG, TX_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0E83: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0E85: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_23_SetTxIntMode:
                                   (0276) _TX_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0E86: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0E88: 7F       RET                 (0303) ;
0E89: 30       HALT  
0E8A: 31 32    XOR   A,50
0E8C: 33 34    XOR   A,[X+52]
0E8E: 35 36    XOR   [X+54],A
0E90: 37 38 39 XOR   [X+56],57
0E93: 41 42 43 AND   REG[66],67
0E96: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_23_Start:
                                   (0317) _TX_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0E99: 08       PUSH  A             (0335) ;
0E9A: 67       ASR   A             (0336) ;  RETURNS:  none
0E9B: 67       ASR   A             (0337) ;
0E9C: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0E9D: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0E9E: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0EA0: FF E7    INDEX 0x0E89        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0EA2: 90 0F    CALL  0x0EB3        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0EA4: 18       POP   A             (0343) ;    functions.
0EA5: 21 0F    AND   A,15          (0344) ;
0EA7: FF E0    INDEX 0x0E89        (0345)  TX_23_Stop:
0EA9: 90 08    CALL  0x0EB3        (0346) _TX_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0EAB: 7F       RET                 (0348)    and   REG[TX_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_23_SendData:
                                   (0375) _TX_23_SendData:
0EAC: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0EAD: 9F EA    CALL  0x0E99        (0377)    mov REG[TX_23_TX_BUFFER_REG], A
0EAF: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0EB0: 9F E7    CALL  0x0E99        (0379)    ret
                                   (0380) .ENDSECTION
0EB2: 7F       RET                 (0381) 
0EB3: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_23_bReadTxStatus:
                                   (0405) _TX_23_bReadTxStatus:
                                   (0406)  bTX_23_ReadTxStatus:
                                   (0407) _bTX_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0EB6: AF FC    JZ    0x0EB3        (0416) ;  FUNCTION NAME: TX_23_PutSHexByte
0EB8: 60 29    MOV   REG[41],A
                                   (0417) ;
0EBA: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_23_PutSHexByte:
                                   (0441) _TX_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_23_HEX_STR                ; Get Hex value
                                   (0450)     call  TX_23_PutChar                ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_23_HEX_STR                ; Get Hex value
                                   (0454)     call  TX_23_PutChar                ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0EBB: 70 BF    AND   F,191         (0456)     ret
0EBD: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0EBF: 52 00    MOV   A,[X+0]       (0459) .SECTION
0EC1: A0 06    JZ    0x0EC8        (0460) ;-----------------------------------------------------------------------------
0EC3: 9F EE    CALL  0x0EB3        (0461) ;  FUNCTION NAME: TX_23_PutSHexInt
0EC5: 75       INC   X             (0462) ;
0EC6: 8F F8    JMP   0x0EBF        (0463) ;  DESCRIPTION:
0EC8: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0ECA: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0ECC: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_23_PutSHexInt:
                                   (0482) _TX_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_23_PutSHexByte            ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_23_PutSHexByte            ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0ECD: 70 BF    AND   F,191         (0503) ;  RETURNS:
0ECF: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0ED2: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0ED3: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0ED5: A0 1A    JZ    0x0EF0        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0ED7: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0ED9: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_23_CONTROL_REG], TX_23_TX_BUFFER_EMPTY    ; Check Tx Status
0EDB: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0EDD: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0EDF: 52 00    MOV   A,[X+0]       (0518)    endm
0EE1: 49 2B 10 TST   REG[43],16
0EE4: AF FC    JZ    0x0EE1        (0519) 
0EE6: 60 29    MOV   REG[41],A
0EE8: 4F       MOV   X,SP          (0520) 
0EE9: 62 D3 07 MOV   REG[211],7    (0521)  TX_23_PutChar:
0EEC: 77 FD    INC   [X-3]         (0522) _TX_23_PutChar:
0EEE: 8F E4    JMP   0x0ED3        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0EF0: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0EF2: 71 C0    OR    F,192         (0526)    ret
0EF4: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_23_PutString:
                                   (0563) _TX_23_PutString:
0EF5: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0EF6: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0EF9: B0 06    JNZ   0x0F00        (0569)    call  TX_23_PutChar                      ; Send character to Tx port
0EFB: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0EFE: A0 1D    JZ    0x0F1C        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0F00: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0F01: 52 FC    MOV   A,[X-4]       (0575)    ret
0F03: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0F05: 28       ROMX                (0577) 
0F06: 49 2B 10 TST   REG[43],16
0F09: AF FC    JZ    0x0F06        (0578) .SECTION
0F0B: 60 29    MOV   REG[41],A
0F0D: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_23_Write
0F0E: 07 FD 01 ADD   [X-3],1       (0581) ;
0F11: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0F14: 17 FB 01 SUB   [X-5],1       (0585) ;
0F17: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0F1A: 8F DB    JMP   0x0EF6        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0F1C: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_23_Write:
                                   (0610) _TX_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0F1D: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0F1E: 10       PUSH  X             (0622)    ENDIF
0F1F: 28       ROMX                (0623) 
0F20: A0 0B    JZ    0x0F2C        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0F22: 9F 8F    CALL  0x0EB3        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0F24: 20       POP   X             (0626)    mov   A,[X]
0F25: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0F26: 75       INC   X             (0628)    mov   X, SP
0F27: DF F5    JNC   0x0F1D        (0629)    RAM_SETPAGE_IDX2STK
0F29: 74       INC   A             (0630)    inc   [X+STR_LSB]
0F2A: 8F F2    JMP   0x0F1D        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0F2C: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0F2E: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0F2F: 50 0D    MOV   A,13          (0663) ;
0F31: 9F 80    CALL  0x0EB3        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0F33: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0F35: 9F 7C    CALL  0x0EB3        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0F39: 43 E1 08 OR    REG[225],8    (0668) 

FILE: lib\tx_014.asm
                                   (0109) ;;*****************************************************************************
0F3C: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_014.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_014.inc"
0F3D: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0F40: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_014_SetTxIntMode
                                   (0143) export  _TX_014_SetTxIntMode
                                   (0144) export   TX_014_EnableInt
                                   (0145) export  _TX_014_EnableInt
                                   (0146) export   TX_014_DisableInt
                                   (0147) export  _TX_014_DisableInt
                                   (0148) export   TX_014_Start
                                   (0149) export  _TX_014_Start
                                   (0150) export   TX_014_Stop
                                   (0151) export  _TX_014_Stop
                                   (0152) export   TX_014_SendData
                                   (0153) export  _TX_014_SendData
                                   (0154) export   TX_014_bReadTxStatus
                                   (0155) export  _TX_014_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_014_ReadTxStatus
                                   (0160) export  _bTX_014_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_014_PutSHexByte
                                   (0166) export _TX_014_PutSHexByte
                                   (0167) export  TX_014_PutSHexInt
                                   (0168) export _TX_014_PutSHexInt
                                   (0169) 
0F41: 71 10    OR    F,16          (0170) export  TX_014_CPutString
0F43: 21 01    AND   A,1           (0171) export _TX_014_CPutString
0F45: A0 07    JZ    0x0F4D        (0172) export  TX_014_PutString
0F47: 43 2C 10 OR    REG[44],16    (0173) export _TX_014_PutString
0F4A: 70 EF    AND   F,239         (0174) export  TX_014_PutChar
                                   (0175) export _TX_014_PutChar
0F4C: 7F       RET                 (0176) export  TX_014_Write
                                   (0177) export _TX_014_Write
                                   (0178) export  TX_014_CWrite
0F4D: 41 2C EF AND   REG[44],239   (0179) export _TX_014_CWrite
0F50: 70 EF    AND   F,239         (0180) export  TX_014_PutCRLF
                                   (0181) export _TX_014_PutCRLF 
0F52: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_014_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0F53: 29 01    OR    A,1           (0211) ;    functions.
0F55: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_014_EnableInt:
0F57: 7F       RET                 (0214) _TX_014_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_014_INT_REG, TX_014_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_014_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0F58: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
0F5B: 7F       RET                 (0242)  TX_014_DisableInt:
                                   (0243) _TX_014_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_014_INT_REG, TX_014_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_014_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0F5C: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
0F5E: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_014_SetTxIntMode:
                                   (0276) _TX_014_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_014_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_014_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_014_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_014_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0F5F: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0F61: 7F       RET                 (0303) ;
0F62: 30       HALT  
0F63: 31 32    XOR   A,50
0F65: 33 34    XOR   A,[X+52]
0F67: 35 36    XOR   [X+54],A
0F69: 37 38 39 XOR   [X+56],57
0F6C: 41 42 43 AND   REG[66],67
0F6F: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_014_Start:
                                   (0317) _TX_014_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_014_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_014_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0F72: 08       PUSH  A             (0335) ;
0F73: 67       ASR   A             (0336) ;  RETURNS:  none
0F74: 67       ASR   A             (0337) ;
0F75: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0F76: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0F77: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0F79: FF E7    INDEX 0x0F62        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0F7B: 90 0F    CALL  0x0F8C        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0F7D: 18       POP   A             (0343) ;    functions.
0F7E: 21 0F    AND   A,15          (0344) ;
0F80: FF E0    INDEX 0x0F62        (0345)  TX_014_Stop:
0F82: 90 08    CALL  0x0F8C        (0346) _TX_014_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0F84: 7F       RET                 (0348)    and   REG[TX_014_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_014_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_014_SendData:
                                   (0375) _TX_014_SendData:
0F85: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0F86: 9F EA    CALL  0x0F72        (0377)    mov REG[TX_014_TX_BUFFER_REG], A
0F88: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0F89: 9F E7    CALL  0x0F72        (0379)    ret
                                   (0380) .ENDSECTION
0F8B: 7F       RET                 (0381) 
0F8C: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_014_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_014_bReadTxStatus:
                                   (0405) _TX_014_bReadTxStatus:
                                   (0406)  bTX_014_ReadTxStatus:
                                   (0407) _bTX_014_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_014_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0F8F: AF FC    JZ    0x0F8C        (0416) ;  FUNCTION NAME: TX_014_PutSHexByte
0F91: 60 2D    MOV   REG[45],A
                                   (0417) ;
0F93: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_014_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_014_PutSHexByte:
                                   (0441) _TX_014_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_014_HEX_STR               ; Get Hex value
                                   (0450)     call  TX_014_PutChar               ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_014_HEX_STR               ; Get Hex value
                                   (0454)     call  TX_014_PutChar               ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0F94: 70 BF    AND   F,191         (0456)     ret
0F96: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0F98: 52 00    MOV   A,[X+0]       (0459) .SECTION
0F9A: A0 06    JZ    0x0FA1        (0460) ;-----------------------------------------------------------------------------
0F9C: 9F EE    CALL  0x0F8C        (0461) ;  FUNCTION NAME: TX_014_PutSHexInt
0F9E: 75       INC   X             (0462) ;
0F9F: 8F F8    JMP   0x0F98        (0463) ;  DESCRIPTION:
0FA1: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0FA3: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0FA5: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_014_PutSHexInt:
                                   (0482) _TX_014_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_014_PutSHexByte           ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_014_PutSHexByte           ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_014_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0FA6: 70 BF    AND   F,191         (0503) ;  RETURNS:
0FA8: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0FAB: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0FAC: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0FAE: A0 1A    JZ    0x0FC9        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0FB0: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0FB2: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_014_CONTROL_REG], TX_014_TX_BUFFER_EMPTY    ; Check Tx Status
0FB4: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0FB6: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_014_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0FB8: 52 00    MOV   A,[X+0]       (0518)    endm
0FBA: 49 2F 10 TST   REG[47],16
0FBD: AF FC    JZ    0x0FBA        (0519) 
0FBF: 60 2D    MOV   REG[45],A
0FC1: 4F       MOV   X,SP          (0520) 
0FC2: 62 D3 07 MOV   REG[211],7    (0521)  TX_014_PutChar:
0FC5: 77 FD    INC   [X-3]         (0522) _TX_014_PutChar:
0FC7: 8F E4    JMP   0x0FAC        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0FC9: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0FCB: 71 C0    OR    F,192         (0526)    ret
0FCD: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_014_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_014_PutString:
                                   (0563) _TX_014_PutString:
0FCE: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0FCF: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0FD2: B0 06    JNZ   0x0FD9        (0569)    call  TX_014_PutChar                     ; Send character to Tx port
0FD4: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0FD7: A0 1D    JZ    0x0FF5        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0FD9: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0FDA: 52 FC    MOV   A,[X-4]       (0575)    ret
0FDC: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0FDE: 28       ROMX                (0577) 
0FDF: 49 2F 10 TST   REG[47],16
0FE2: AF FC    JZ    0x0FDF        (0578) .SECTION
0FE4: 60 2D    MOV   REG[45],A
0FE6: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_014_Write
0FE7: 07 FD 01 ADD   [X-3],1       (0581) ;
0FEA: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0FED: 17 FB 01 SUB   [X-5],1       (0585) ;
0FF0: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0FF3: 8F DB    JMP   0x0FCF        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0FF5: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_014_Write:
                                   (0610) _TX_014_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0FF6: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0FF7: 10       PUSH  X             (0622)    ENDIF
0FF8: 28       ROMX                (0623) 
0FF9: A0 0B    JZ    0x1005        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0FFB: 9F 8F    CALL  0x0F8C        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0FFD: 20       POP   X             (0626)    mov   A,[X]
0FFE: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0FFF: 75       INC   X             (0628)    mov   X, SP
1000: DF F5    JNC   0x0FF6        (0629)    RAM_SETPAGE_IDX2STK
1002: 74       INC   A             (0630)    inc   [X+STR_LSB]
1003: 8F F2    JMP   0x0FF6        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
1005: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
1007: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_014_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
1008: 50 0D    MOV   A,13          (0663) ;
100A: 9F 80    CALL  0x0F8C        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
100C: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
100E: 9F 7C    CALL  0x0F8C        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
1011: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\tx_01234_timeout.asm
                                   (0102) ;;*****************************************************************************
1014: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_01234_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_01234_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1015: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1018: 7F       RET                 (0131) export  TX_01234_TIMEOUT_EnableInt
                                   (0132) export _TX_01234_TIMEOUT_EnableInt
                                   (0133) export  TX_01234_TIMEOUT_DisableInt
                                   (0134) export _TX_01234_TIMEOUT_DisableInt
                                   (0135) export  TX_01234_TIMEOUT_Start
                                   (0136) export _TX_01234_TIMEOUT_Start
                                   (0137) export  TX_01234_TIMEOUT_Stop
                                   (0138) export _TX_01234_TIMEOUT_Stop
                                   (0139) export  TX_01234_TIMEOUT_WritePeriod
                                   (0140) export _TX_01234_TIMEOUT_WritePeriod
                                   (0141) export  TX_01234_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_01234_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_01234_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_01234_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_01234_TIMEOUT_wReadTimer
                                   (0146) export _TX_01234_TIMEOUT_wReadTimer
                                   (0147) export  TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
1019: 43 23 01 OR    REG[35],1     (0157) export _wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
101C: 7F       RET                 (0159) export  wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA my_response_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_01234_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
101D: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1020: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_01234_TIMEOUT_EnableInt:
                                   (0200) _TX_01234_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_01234_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_01234_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1021: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1023: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1024: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1026: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_01234_TIMEOUT_DisableInt:
                                   (0228) _TX_01234_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_01234_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_01234_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1027: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1029: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
102A: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
102C: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_01234_TIMEOUT_Start:
                                   (0256) _TX_01234_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_01234_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_01234_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
102D: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
102F: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1030: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1032: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_01234_TIMEOUT_Stop:
                                   (0284) _TX_01234_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_01234_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_01234_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_01234_TIMEOUT_WritePeriod:
                                   (0313) _TX_01234_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_01234_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_01234_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_01234_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_01234_TIMEOUT_Stop to disable).
1033: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1034: 38 03    ADD   SP,3          (0334) ;
1036: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1038: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1039: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
103B: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
103C: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
103E: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
103F: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1041: 5D 26    MOV   A,REG[38]     (0343) ;
1043: 54 01    MOV   [X+1],A       (0344)  TX_01234_TIMEOUT_WriteCompareValue:
1045: 5D 22    MOV   A,REG[34]     (0345) _TX_01234_TIMEOUT_WriteCompareValue:
1047: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1049: 50 00    MOV   A,0           (0347)    mov   reg[TX_01234_TIMEOUT_COMPARE_LSB_REG], A
104B: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
104E: A0 03    JZ    0x1052        (0349)    mov   reg[TX_01234_TIMEOUT_COMPARE_MSB_REG], A
1050: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1052: 54 00    MOV   [X+0],A       (0352) 
1054: 70 FE    AND   F,254         (0353) .ENDSECTION
1056: 41 23 FE AND   REG[35],254   (0354) 
1059: 18       POP   A             (0355) 
105A: 60 26    MOV   REG[38],A     (0356) .SECTION
105C: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
105D: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadCompareValue
105F: 18       POP   A             (0359) ;
1060: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1062: 18       POP   A             (0361) ;     Reads the Compare registers.
1063: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1064: 70 3F    AND   F,63
1066: 71 C0    OR    F,192         (0363) ;
1068: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_01234_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_01234_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1069: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
106B: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
106D: 5C       MOV   X,A           (0409) ;
106E: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1072: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\servo_tx.asm
                                   (0109) ;;*****************************************************************************
1075: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: SERVO_TX.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "SERVO_TX.inc"
1076: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
1079: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   SERVO_TX_SetTxIntMode
                                   (0143) export  _SERVO_TX_SetTxIntMode
                                   (0144) export   SERVO_TX_EnableInt
                                   (0145) export  _SERVO_TX_EnableInt
                                   (0146) export   SERVO_TX_DisableInt
                                   (0147) export  _SERVO_TX_DisableInt
                                   (0148) export   SERVO_TX_Start
                                   (0149) export  _SERVO_TX_Start
                                   (0150) export   SERVO_TX_Stop
                                   (0151) export  _SERVO_TX_Stop
                                   (0152) export   SERVO_TX_SendData
                                   (0153) export  _SERVO_TX_SendData
                                   (0154) export   SERVO_TX_bReadTxStatus
                                   (0155) export  _SERVO_TX_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bSERVO_TX_ReadTxStatus
                                   (0160) export  _bSERVO_TX_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  SERVO_TX_PutSHexByte
                                   (0166) export _SERVO_TX_PutSHexByte
                                   (0167) export  SERVO_TX_PutSHexInt
                                   (0168) export _SERVO_TX_PutSHexInt
                                   (0169) 
107A: 71 10    OR    F,16          (0170) export  SERVO_TX_CPutString
107C: 21 01    AND   A,1           (0171) export _SERVO_TX_CPutString
107E: A0 07    JZ    0x1086        (0172) export  SERVO_TX_PutString
1080: 43 28 10 OR    REG[40],16    (0173) export _SERVO_TX_PutString
1083: 70 EF    AND   F,239         (0174) export  SERVO_TX_PutChar
                                   (0175) export _SERVO_TX_PutChar
1085: 7F       RET                 (0176) export  SERVO_TX_Write
                                   (0177) export _SERVO_TX_Write
                                   (0178) export  SERVO_TX_CWrite
1086: 41 28 EF AND   REG[40],239   (0179) export _SERVO_TX_CWrite
1089: 70 EF    AND   F,239         (0180) export  SERVO_TX_PutCRLF
                                   (0181) export _SERVO_TX_PutCRLF 
108B: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: SERVO_TX_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
108C: 29 01    OR    A,1           (0211) ;    functions.
108E: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  SERVO_TX_EnableInt:
1090: 7F       RET                 (0214) _SERVO_TX_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: SERVO_TX_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
1091: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
1094: 7F       RET                 (0242)  SERVO_TX_DisableInt:
                                   (0243) _SERVO_TX_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: SERVO_TX_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
1095: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
1097: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  SERVO_TX_SetTxIntMode:
                                   (0276) _SERVO_TX_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, SERVO_TX_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[SERVO_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[SERVO_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: SERVO_TX_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
1098: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
109A: 7F       RET                 (0303) ;
109B: 30       HALT  
109C: 31 32    XOR   A,50
109E: 33 34    XOR   A,[X+52]
10A0: 35 36    XOR   [X+54],A
10A2: 37 38 39 XOR   [X+56],57
10A5: 41 42 43 AND   REG[66],67
10A8: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  SERVO_TX_Start:
                                   (0317) _SERVO_TX_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[SERVO_TX_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: SERVO_TX_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
10AB: 08       PUSH  A             (0335) ;
10AC: 67       ASR   A             (0336) ;  RETURNS:  none
10AD: 67       ASR   A             (0337) ;
10AE: 67       ASR   A             (0338) ;  SIDE EFFECTS:
10AF: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
10B0: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
10B2: FF E7    INDEX 0x109B        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
10B4: 90 0F    CALL  0x10C5        (0342) ;    responsibility to perserve their values across calls to fastcall16 
10B6: 18       POP   A             (0343) ;    functions.
10B7: 21 0F    AND   A,15          (0344) ;
10B9: FF E0    INDEX 0x109B        (0345)  SERVO_TX_Stop:
10BB: 90 08    CALL  0x10C5        (0346) _SERVO_TX_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
10BD: 7F       RET                 (0348)    and   REG[SERVO_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: SERVO_TX_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  SERVO_TX_SendData:
                                   (0375) _SERVO_TX_SendData:
10BE: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
10BF: 9F EA    CALL  0x10AB        (0377)    mov REG[SERVO_TX_TX_BUFFER_REG], A
10C1: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
10C2: 9F E7    CALL  0x10AB        (0379)    ret
                                   (0380) .ENDSECTION
10C4: 7F       RET                 (0381) 
10C5: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: SERVO_TX_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  SERVO_TX_bReadTxStatus:
                                   (0405) _SERVO_TX_bReadTxStatus:
                                   (0406)  bSERVO_TX_ReadTxStatus:
                                   (0407) _bSERVO_TX_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[SERVO_TX_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
10C8: AF FC    JZ    0x10C5        (0416) ;  FUNCTION NAME: SERVO_TX_PutSHexByte
10CA: 60 29    MOV   REG[41],A
                                   (0417) ;
10CC: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) SERVO_TX_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  SERVO_TX_PutSHexByte:
                                   (0441) _SERVO_TX_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0450)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0454)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
10CD: 70 BF    AND   F,191         (0456)     ret
10CF: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
10D1: 52 00    MOV   A,[X+0]       (0459) .SECTION
10D3: A0 06    JZ    0x10DA        (0460) ;-----------------------------------------------------------------------------
10D5: 9F EE    CALL  0x10C5        (0461) ;  FUNCTION NAME: SERVO_TX_PutSHexInt
10D7: 75       INC   X             (0462) ;
10D8: 8F F8    JMP   0x10D1        (0463) ;  DESCRIPTION:
10DA: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
10DC: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
10DE: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  SERVO_TX_PutSHexInt:
                                   (0482) _SERVO_TX_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  SERVO_TX_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  SERVO_TX_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: SERVO_TX_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
10DF: 70 BF    AND   F,191         (0503) ;  RETURNS:
10E1: 62 D3 07 MOV   REG[211],7    (0504) ;     none
10E4: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
10E5: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
10E7: A0 1A    JZ    0x1102        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
10E9: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
10EB: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[SERVO_TX_CONTROL_REG], SERVO_TX_TX_BUFFER_EMPTY    ; Check Tx Status
10ED: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
10EF: 60 D3    MOV   REG[211],A    (0517)    mov REG[SERVO_TX_TX_BUFFER_REG], @Source    ; Write data to Tx Port
10F1: 52 00    MOV   A,[X+0]       (0518)    endm
10F3: 49 2B 10 TST   REG[43],16
10F6: AF FC    JZ    0x10F3        (0519) 
10F8: 60 29    MOV   REG[41],A
10FA: 4F       MOV   X,SP          (0520) 
10FB: 62 D3 07 MOV   REG[211],7    (0521)  SERVO_TX_PutChar:
10FE: 77 FD    INC   [X-3]         (0522) _SERVO_TX_PutChar:
1100: 8F E4    JMP   0x10E5        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
1102: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
1104: 71 C0    OR    F,192         (0526)    ret
1106: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: SERVO_TX_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  SERVO_TX_PutString:
                                   (0563) _SERVO_TX_PutString:
1107: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
1108: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
110B: B0 06    JNZ   0x1112        (0569)    call  SERVO_TX_PutChar                   ; Send character to Tx port
110D: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
1110: A0 1D    JZ    0x112E        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
1112: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
1113: 52 FC    MOV   A,[X-4]       (0575)    ret
1115: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
1117: 28       ROMX                (0577) 
1118: 49 2B 10 TST   REG[43],16
111B: AF FC    JZ    0x1118        (0578) .SECTION
111D: 60 29    MOV   REG[41],A
111F: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: SERVO_TX_Write
1120: 07 FD 01 ADD   [X-3],1       (0581) ;
1123: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
1126: 17 FB 01 SUB   [X-5],1       (0585) ;
1129: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
112C: 8F DB    JMP   0x1108        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
112E: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  SERVO_TX_Write:
                                   (0610) _SERVO_TX_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
112F: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
1130: 10       PUSH  X             (0622)    ENDIF
1131: 28       ROMX                (0623) 
1132: A0 0B    JZ    0x113E        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
1134: 9F 8F    CALL  0x10C5        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
1136: 20       POP   X             (0626)    mov   A,[X]
1137: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
1138: 75       INC   X             (0628)    mov   X, SP
1139: DF F5    JNC   0x112F        (0629)    RAM_SETPAGE_IDX2STK
113B: 74       INC   A             (0630)    inc   [X+STR_LSB]
113C: 8F F2    JMP   0x112F        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
113E: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
1140: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: SERVO_TX_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
1141: 50 0D    MOV   A,13          (0663) ;
1143: 9F 80    CALL  0x10C5        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
1145: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
1147: 9F 7C    CALL  0x10C5        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
114A: 08       PUSH  A             (0668) 

FILE: lib\rx8_2int.asm
114B: 10       PUSH  X             (0104) ;;*****************************************************************************
114C: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RX8_2INT.asm
114E: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
114F: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1151: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
1153: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1154: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1156: B0 04    JNZ   0x115B        (0115) 
1158: 18       POP   A             (0116) include "m8c.inc"
1159: 80 5E    JMP   0x11B8        (0117) include "memory.inc"
                                   (0118) include "RX8_2.inc"
                                   (0119) 
                                   (0120) 
115B: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
115C: 21 E0    AND   A,224         (0124) export  _RX8_2_ISR
115E: A0 12    JZ    0x1171        (0125) 
                                   (0126) 
1160: 2C 02    OR    [2],A         (0127) IF (RX8_2_RXBUF_ENABLE)
                                   (0128) export  RX8_2_aRxBuffer
1162: 49 2E 00 TST   REG[46],0     (0129) export _RX8_2_aRxBuffer
                                   (0130) export  RX8_2_bRxCnt
1165: 21 20    AND   A,32          (0131) export _RX8_2_bRxCnt
1167: A0 50    JZ    0x11B8        (0132) export  RX8_2_fStatus
                                   (0133) export _RX8_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
1169: 41 2F FE AND   REG[47],254   (0136) 
116C: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
116F: 80 48    JMP   0x11B8        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RX8_2_RXBUF_ENABLE)
1171: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RX8_2_fStatus:
                                   (0144) _RX8_2_fStatus:      BLK  1
1173: 47 02 01 TST   [2],1         (0145)  RX8_2_bRxCnt:
1176: B0 41    JNZ   0x11B8        (0146) _RX8_2_bRxCnt:       BLK  1
                                   (0147) AREA RX8_2_RAM(RAM,REL,CON)
1178: 39 00    CMP   A,0           (0148)  RX8_2_aRxBuffer:    
117A: B0 14    JNZ   0x118F        (0149) _RX8_2_aRxBuffer:    BLK RX8_2_RX_BUFFER_SIZE
117C: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
117F: 62 D3 00 MOV   REG[211],0    (0152) 
1182: 70 3F    AND   F,63
1184: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1186: 56 88 00 MOV   [X-120],0     (0154) 
1189: 70 3F    AND   F,63
118B: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
118D: 80 2A    JMP   0x11B8        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
118F: 3C 03 0F CMP   [3],15        (0167) ;------------------------
1192: C0 14    JC    0x11A7        (0168) 
1194: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
1197: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
119A: 70 3F    AND   F,63
119C: 71 80    OR    F,128         (0172) ;------------------------
119E: 56 88 00 MOV   [X-120],0     (0173) 
11A1: 70 3F    AND   F,63
11A3: 71 00    OR    F,0           (0174) 
11A5: 80 12    JMP   0x11B8        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
11A7: 75       INC   X             (0179) 
11A8: 5A 03    MOV   [3],X         (0180) 
11AA: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
11AB: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
11AE: 70 3F    AND   F,63
11B0: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RX8_2_ISR
11B2: 54 88    MOV   [X-120],A     (0185) ;
11B4: 70 3F    AND   F,63
11B6: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
11B8: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
11B9: 60 D3    MOV   REG[211],A    (0191) _RX8_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
11BB: 20       POP   X             (0195)    ; Insert your custom code below this banner
11BC: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
11BE: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\rx8_2.asm
                                   (0121) ;;*****************************************************************************
11C1: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RX8_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RX8_2.inc"
11C2: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
11C5: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RX8_2_EnableInt
                                   (0155) export  _RX8_2_EnableInt
                                   (0156) export   RX8_2_DisableInt
                                   (0157) export  _RX8_2_DisableInt
                                   (0158) export   RX8_2_Start
                                   (0159) export  _RX8_2_Start
                                   (0160) export   RX8_2_Stop
                                   (0161) export  _RX8_2_Stop
                                   (0162) export   RX8_2_bReadRxData
                                   (0163) export  _RX8_2_bReadRxData
                                   (0164) export   RX8_2_bReadRxStatus
                                   (0165) export  _RX8_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRX8_2_ReadRxData
                                   (0170) export _bRX8_2_ReadRxData
                                   (0171) export  bRX8_2_ReadRxStatus
                                   (0172) export _bRX8_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RX8_2_cGetChar
11C6: 29 01    OR    A,1           (0179) export _RX8_2_cGetChar
11C8: 60 2F    MOV   REG[47],A     (0180) export  RX8_2_cReadChar
                                   (0181) export _RX8_2_cReadChar
11CA: 7F       RET                 (0182) export  RX8_2_iReadChar
                                   (0183) export _RX8_2_iReadChar
                                   (0184) 
                                   (0185) IF (RX8_2_RXBUF_ENABLE)
                                   (0186) export  RX8_2_CmdReset
                                   (0187) export _RX8_2_CmdReset
                                   (0188) export  RX8_2_bCmdCheck
                                   (0189) export _RX8_2_bCmdCheck
                                   (0190) export  RX8_2_bCmdLength
                                   (0191) export _RX8_2_bCmdLength
                                   (0192) export  RX8_2_bErrCheck
                                   (0193) export _RX8_2_bErrCheck
                                   (0194) 
                                   (0195) export  RX8_2_szGetParam
                                   (0196) export _RX8_2_szGetParam
                                   (0197) export  RX8_2_szGetRestOfParams
                                   (0198) export _RX8_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RX8_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
11CB: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
11CE: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RX8_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RX8_2_EnableInt:
                                   (0238) _RX8_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
11CF: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
11D1: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RX8_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RX8_2_DisableInt:
                                   (0267) _RX8_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
11D2: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
11D4: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RX8_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RX8_2_Start:
                                   (0297) _RX8_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RX8_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RX8_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
11D5: 49 2F 08 TST   REG[47],8     (0311) ;
11D8: AF FC    JZ    0x11D5        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
11DA: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
11DC: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RX8_2_Stop:
                                   (0326) _RX8_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RX8_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RX8_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
11DD: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
11DF: 08       PUSH  A             (0347) ;
11E0: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
11E2: B0 04    JNZ   0x11E7        (0349) ;    The A and X registers may be modified by this or future implementations
11E4: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
11E5: 80 0B    JMP   0x11F1        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
11E7: 5D 2E    MOV   A,REG[46]     (0354) ;
11E9: 4B       SWAP  A,X           (0355)  RX8_2_bReadRxData:
                                   (0356) _RX8_2_bReadRxData:
11EA: 18       POP   A             (0357)  bRX8_2_ReadRxData:
11EB: 21 A0    AND   A,160         (0358) _bRX8_2_ReadRxData:
11ED: B0 03    JNZ   0x11F1        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
11EF: 4B       SWAP  A,X           (0360)    mov A, REG[RX8_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
11F0: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
11F1: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RX8_2_bReadRxStatus
                                   (0368) ;
11F3: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RX8_2_bReadRxStatus:
                                   (0388) _RX8_2_bReadRxStatus:
                                   (0389)  bRX8_2_ReadRxStatus:
                                   (0390) _bRX8_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RX8_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RX8_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
11F4: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
11F6: 21 E8    AND   A,232         (0408) ;
11F8: 08       PUSH  A             (0409) ;  ARGUMENTS:
11F9: 21 08    AND   A,8           (0410) ;      none
11FB: B0 07    JNZ   0x1203        (0411) ;
11FD: 18       POP   A             (0412) ;  RETURNS:
11FE: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1200: 4B       SWAP  A,X           (0414) ;
1201: 80 07    JMP   0x1209        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1203: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1204: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1206: 4B       SWAP  A,X           (0420) ;    functions.
1207: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1209: 7F       RET                 (0426)  RX8_2_cGetChar:
                                   (0427) _RX8_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RX8_2_CONTROL_REG],RX8_2_RX_REG_FULL  ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RX8_2_RX_BUFFER_REG]               ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RX8_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RX8_2_cReadChar:
                                   (0463) _RX8_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
120A: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
120D: 55 88 00 MOV   [136],0       (0470)    pop  A
1210: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1213: 55 E4 00 MOV   [CHILD+1],0   (0472) 
1216: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1219: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
121C: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
121F: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RX8_2_RX_PARITY_ERROR | RX8_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RX8_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RX8_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1220: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1223: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
1225: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1227: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RX8_2_iReadChar:
                                   (0523) _RX8_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RX8_2_RX_ERROR|RX8_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RX8_2_RX_NO_DATA                                 ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RX8_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RX8_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RX8_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RX8_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1228: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
122B: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
122D: 21 F0    AND   A,240         (0555) ;
122F: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
1232: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RX8_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RX8_2_CmdReset:
1233: 62 D0 00 MOV   REG[208],0    (0587) _RX8_2_CmdReset:
1236: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RX8_2_aRxBuffer
1238: 7F       RET                 (0590)    mov [RX8_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                   (0594)    mov [RX8_2_bRxCnt], 0x00
                                   (0595)    and [RX8_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RX8_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RX8_2_bCmdCheck:
                                   (0628) _RX8_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0631)    mov A,  [RX8_2_fStatus]
                                   (0632)    and A, RX8_2_RX_BUF_CMDTERM                   ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RX8_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1239: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
123B: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
123E: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1241: 50 88    MOV   A,136         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1243: 02 E4    ADD   A,[CHILD+1]   (0649) ;                     Returns non-zero value in A if command is valid.
1245: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1246: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1248: B0 04    JNZ   0x124D        (0653) ;           0x10 => Software Buffer OverRun
124A: 10       PUSH  X             (0654) ;
124B: 80 33    JMP   0x127F        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
124D: 39 00    CMP   A,0           (0660) ;    functions.
124F: B0 11    JNZ   0x1261        (0661) ;          
1251: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1252: 76 E4    INC   [CHILD+1]     (0663) ;          CUR_PP
1254: 52 00    MOV   A,[X+0]       (0664) ;
1256: 3C E4 0F CMP   [CHILD+1],15  (0665) ;     Error Status is clear when read.
1259: BF F3    JNZ   0x124D        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
125B: 10       PUSH  X             (0669) ;
                                   (0670)  RX8_2_bErrCheck:
125C: 56 00 00 MOV   [X+0],0       (0671) _RX8_2_bErrCheck:
125F: 80 1F    JMP   0x127F        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0674)    mov A,  [RX8_2_fStatus]
1261: 10       PUSH  X             (0675)    and A, RX8_2_RX_BUF_ERROR                     ; Mask off Error status
                                   (0676)    and [RX8_2_fStatus], ~RX8_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1262: 75       INC   X             (0679) .ENDSECTION
1263: 76 E4    INC   [CHILD+1]     (0680) 
1265: 3C E4 0F CMP   [CHILD+1],15  (0681) .SECTION
1268: AF F3    JZ    0x125C        (0682) ;-----------------------------------------------------------------------------
126A: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RX8_2_bCmdLength
126C: A0 12    JZ    0x127F        (0684) ;
126E: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1270: BF F1    JNZ   0x1262        (0686) ;     Get length of command string
                                   (0687) ;
1272: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1275: 76 E4    INC   [CHILD+1]     (0689) ;     none.
1277: 3C E4 0F CMP   [CHILD+1],15  (0690) ;
127A: B0 04    JNZ   0x127F        (0691) ;  RETURNS:
127C: 55 E4 0F MOV   [CHILD+1],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
127F: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1280: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1281: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1284: B0 0B    JNZ   0x1290        (0699) ;    functions.
1286: 20       POP   X             (0700) ;          
1287: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1289: 50 00    MOV   A,0           (0702) ;          CUR_PP
128B: 70 3F    AND   F,63
128D: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RX8_2_bCmdLength:
128F: 7F       RET                 (0705) _RX8_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
1290: 20       POP   X             (0708)    mov A,  [RX8_2_bRxCnt]
1291: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1293: 70 3F    AND   F,63
1295: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1297: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RX8_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1298: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
129B: 50 88    MOV   A,136         (0744) ;     each lexically distinct element into a null-terminated string by replacing
129D: 02 E4    ADD   A,[CHILD+1]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
129F: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
12A0: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RX8_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RX8_2_szGetParam, is
12A3: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\init_timeout.asm
                                   (0102) ;;*****************************************************************************
12A6: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: INIT_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "INIT_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
12A7: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
12AA: 7F       RET                 (0131) export  INIT_TIMEOUT_EnableInt
                                   (0132) export _INIT_TIMEOUT_EnableInt
                                   (0133) export  INIT_TIMEOUT_DisableInt
                                   (0134) export _INIT_TIMEOUT_DisableInt
                                   (0135) export  INIT_TIMEOUT_Start
                                   (0136) export _INIT_TIMEOUT_Start
                                   (0137) export  INIT_TIMEOUT_Stop
                                   (0138) export _INIT_TIMEOUT_Stop
                                   (0139) export  INIT_TIMEOUT_WritePeriod
                                   (0140) export _INIT_TIMEOUT_WritePeriod
                                   (0141) export  INIT_TIMEOUT_WriteCompareValue
                                   (0142) export _INIT_TIMEOUT_WriteCompareValue
                                   (0143) export  INIT_TIMEOUT_wReadCompareValue
                                   (0144) export _INIT_TIMEOUT_wReadCompareValue
                                   (0145) export  INIT_TIMEOUT_wReadTimer
                                   (0146) export _INIT_TIMEOUT_wReadTimer
                                   (0147) export  INIT_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _INIT_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
12AB: 43 23 01 OR    REG[35],1     (0157) export _wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
12AE: 7F       RET                 (0159) export  wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA initial_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: INIT_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
12AF: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
12B2: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  INIT_TIMEOUT_EnableInt:
                                   (0200) _INIT_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    INIT_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: INIT_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
12B3: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
12B5: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
12B6: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
12B8: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  INIT_TIMEOUT_DisableInt:
                                   (0228) _INIT_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    INIT_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: INIT_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
12B9: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
12BB: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
12BC: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
12BE: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  INIT_TIMEOUT_Start:
                                   (0256) _INIT_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    INIT_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: INIT_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
12BF: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
12C1: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
12C2: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
12C4: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  INIT_TIMEOUT_Stop:
                                   (0284) _INIT_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    INIT_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: INIT_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  INIT_TIMEOUT_WritePeriod:
                                   (0313) _INIT_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[INIT_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[INIT_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: INIT_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call INIT_TIMEOUT_Stop to disable).
12C5: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
12C6: 38 03    ADD   SP,3          (0334) ;
12C8: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
12CA: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
12CB: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
12CD: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
12CE: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
12D0: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
12D1: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
12D3: 5D 26    MOV   A,REG[38]     (0343) ;
12D5: 54 01    MOV   [X+1],A       (0344)  INIT_TIMEOUT_WriteCompareValue:
12D7: 5D 22    MOV   A,REG[34]     (0345) _INIT_TIMEOUT_WriteCompareValue:
12D9: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
12DB: 50 00    MOV   A,0           (0347)    mov   reg[INIT_TIMEOUT_COMPARE_LSB_REG], A
12DD: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
12E0: A0 03    JZ    0x12E4        (0349)    mov   reg[INIT_TIMEOUT_COMPARE_MSB_REG], A
12E2: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
12E4: 54 00    MOV   [X+0],A       (0352) 
12E6: 70 FE    AND   F,254         (0353) .ENDSECTION
12E8: 41 23 FE AND   REG[35],254   (0354) 
12EB: 18       POP   A             (0355) 
12EC: 60 26    MOV   REG[38],A     (0356) .SECTION
12EE: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
12EF: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: INIT_TIMEOUT_wReadCompareValue
12F1: 18       POP   A             (0359) ;
12F2: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
12F4: 18       POP   A             (0361) ;     Reads the Compare registers.
12F5: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
12F6: 70 3F    AND   F,63
12F8: 71 C0    OR    F,192         (0363) ;
12FA: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  INIT_TIMEOUT_wReadCompareValue:
                                   (0374) _INIT_TIMEOUT_wReadCompareValue:
                                   (0375)  wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0376) _wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[INIT_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[INIT_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: INIT_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
12FB: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
12FD: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
12FF: 5C       MOV   X,A           (0409) ;
1300: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1303: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\init_rxint.asm
1304: 10       PUSH  X             (0104) ;;*****************************************************************************
1305: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: INIT_RXINT.asm
1307: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1308: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
130A: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
130C: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
130D: 21 08    AND   A,8           (0114) ;;*****************************************************************************
130F: B0 04    JNZ   0x1314        (0115) 
1311: 18       POP   A             (0116) include "m8c.inc"
1312: 80 5E    JMP   0x1371        (0117) include "memory.inc"
                                   (0118) include "INIT_RX.inc"
                                   (0119) 
                                   (0120) 
1314: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1315: 21 E0    AND   A,224         (0124) export  _INIT_RX_ISR
1317: A0 12    JZ    0x132A        (0125) 
                                   (0126) 
1319: 2C 06    OR    [6],A         (0127) IF (INIT_RX_RXBUF_ENABLE)
                                   (0128) export  INIT_RX_aRxBuffer
131B: 49 2A 00 TST   REG[42],0     (0129) export _INIT_RX_aRxBuffer
                                   (0130) export  INIT_RX_bRxCnt
131E: 21 20    AND   A,32          (0131) export _INIT_RX_bRxCnt
1320: A0 50    JZ    0x1371        (0132) export  INIT_RX_fStatus
                                   (0133) export _INIT_RX_fStatus
                                   (0134) ENDIF
                                   (0135) 
1322: 41 2B FE AND   REG[43],254   (0136) 
1325: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1328: 80 48    JMP   0x1371        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (INIT_RX_RXBUF_ENABLE)
132A: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  INIT_RX_fStatus:
                                   (0144) _INIT_RX_fStatus:      BLK  1
132C: 47 06 01 TST   [6],1         (0145)  INIT_RX_bRxCnt:
132F: B0 41    JNZ   0x1371        (0146) _INIT_RX_bRxCnt:       BLK  1
                                   (0147) AREA INIT_RX_RAM(RAM,REL,CON)
1331: 39 00    CMP   A,0           (0148)  INIT_RX_aRxBuffer:    
1333: B0 14    JNZ   0x1348        (0149) _INIT_RX_aRxBuffer:    BLK INIT_RX_RX_BUFFER_SIZE
1335: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
1338: 62 D3 00 MOV   REG[211],0    (0152) 
133B: 70 3F    AND   F,63
133D: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
133F: 56 38 00 MOV   [X+56],0      (0154) 
1342: 70 3F    AND   F,63
1344: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1346: 80 2A    JMP   0x1371        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1348: 3C 07 0F CMP   [7],15        (0167) ;------------------------
134B: C0 14    JC    0x1360        (0168) 
134D: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
1350: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1353: 70 3F    AND   F,63
1355: 71 80    OR    F,128         (0172) ;------------------------
1357: 56 38 00 MOV   [X+56],0      (0173) 
135A: 70 3F    AND   F,63
135C: 71 00    OR    F,0           (0174) 
135E: 80 12    JMP   0x1371        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1360: 75       INC   X             (0179) 
1361: 5A 07    MOV   [7],X         (0180) 
1363: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1364: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1367: 70 3F    AND   F,63
1369: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _INIT_RX_ISR
136B: 54 38    MOV   [X+56],A      (0185) ;
136D: 70 3F    AND   F,63
136F: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1371: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1372: 60 D3    MOV   REG[211],A    (0191) _INIT_RX_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1374: 20       POP   X             (0195)    ; Insert your custom code below this banner
1375: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1377: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\init_rx.asm
                                   (0121) ;;*****************************************************************************
137A: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: INIT_RX.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "INIT_RX.inc"
137B: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
137E: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   INIT_RX_EnableInt
                                   (0155) export  _INIT_RX_EnableInt
                                   (0156) export   INIT_RX_DisableInt
                                   (0157) export  _INIT_RX_DisableInt
                                   (0158) export   INIT_RX_Start
                                   (0159) export  _INIT_RX_Start
                                   (0160) export   INIT_RX_Stop
                                   (0161) export  _INIT_RX_Stop
                                   (0162) export   INIT_RX_bReadRxData
                                   (0163) export  _INIT_RX_bReadRxData
                                   (0164) export   INIT_RX_bReadRxStatus
                                   (0165) export  _INIT_RX_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bINIT_RX_ReadRxData
                                   (0170) export _bINIT_RX_ReadRxData
                                   (0171) export  bINIT_RX_ReadRxStatus
                                   (0172) export _bINIT_RX_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  INIT_RX_cGetChar
137F: 29 01    OR    A,1           (0179) export _INIT_RX_cGetChar
1381: 60 2B    MOV   REG[43],A     (0180) export  INIT_RX_cReadChar
                                   (0181) export _INIT_RX_cReadChar
1383: 7F       RET                 (0182) export  INIT_RX_iReadChar
                                   (0183) export _INIT_RX_iReadChar
                                   (0184) 
                                   (0185) IF (INIT_RX_RXBUF_ENABLE)
                                   (0186) export  INIT_RX_CmdReset
                                   (0187) export _INIT_RX_CmdReset
                                   (0188) export  INIT_RX_bCmdCheck
                                   (0189) export _INIT_RX_bCmdCheck
                                   (0190) export  INIT_RX_bCmdLength
                                   (0191) export _INIT_RX_bCmdLength
                                   (0192) export  INIT_RX_bErrCheck
                                   (0193) export _INIT_RX_bErrCheck
                                   (0194) 
                                   (0195) export  INIT_RX_szGetParam
                                   (0196) export _INIT_RX_szGetParam
                                   (0197) export  INIT_RX_szGetRestOfParams
                                   (0198) export _INIT_RX_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA INIT_RX_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1384: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1387: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: INIT_RX_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  INIT_RX_EnableInt:
                                   (0238) _INIT_RX_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1388: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
138A: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: INIT_RX_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  INIT_RX_DisableInt:
                                   (0267) _INIT_RX_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
138B: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
138D: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: INIT_RX_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  INIT_RX_Start:
                                   (0297) _INIT_RX_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[INIT_RX_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: INIT_RX_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
138E: 49 2B 08 TST   REG[43],8     (0311) ;
1391: AF FC    JZ    0x138E        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1393: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1395: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  INIT_RX_Stop:
                                   (0326) _INIT_RX_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[INIT_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: INIT_RX_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1396: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1398: 08       PUSH  A             (0347) ;
1399: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
139B: B0 04    JNZ   0x13A0        (0349) ;    The A and X registers may be modified by this or future implementations
139D: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
139E: 80 0B    JMP   0x13AA        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
13A0: 5D 2A    MOV   A,REG[42]     (0354) ;
13A2: 4B       SWAP  A,X           (0355)  INIT_RX_bReadRxData:
                                   (0356) _INIT_RX_bReadRxData:
13A3: 18       POP   A             (0357)  bINIT_RX_ReadRxData:
13A4: 21 A0    AND   A,160         (0358) _bINIT_RX_ReadRxData:
13A6: B0 03    JNZ   0x13AA        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
13A8: 4B       SWAP  A,X           (0360)    mov A, REG[INIT_RX_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
13A9: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
13AA: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: INIT_RX_bReadRxStatus
                                   (0368) ;
13AC: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  INIT_RX_bReadRxStatus:
                                   (0388) _INIT_RX_bReadRxStatus:
                                   (0389)  bINIT_RX_ReadRxStatus:
                                   (0390) _bINIT_RX_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[INIT_RX_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: INIT_RX_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
13AD: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
13AF: 21 E8    AND   A,232         (0408) ;
13B1: 08       PUSH  A             (0409) ;  ARGUMENTS:
13B2: 21 08    AND   A,8           (0410) ;      none
13B4: B0 07    JNZ   0x13BC        (0411) ;
13B6: 18       POP   A             (0412) ;  RETURNS:
13B7: 29 01    OR    A,1           (0413) ;     char that is returned from UART
13B9: 4B       SWAP  A,X           (0414) ;
13BA: 80 07    JMP   0x13C2        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
13BC: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
13BD: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
13BF: 4B       SWAP  A,X           (0420) ;    functions.
13C0: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
13C2: 7F       RET                 (0426)  INIT_RX_cGetChar:
                                   (0427) _INIT_RX_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[INIT_RX_CONTROL_REG],INIT_RX_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[INIT_RX_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: INIT_RX_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  INIT_RX_cReadChar:
                                   (0463) _INIT_RX_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
13C3: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
13C6: 55 38 00 MOV   [56],0        (0470)    pop  A
13C9: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
13CC: 55 DB 00 MOV   [219],0       (0472) 
13CF: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
13D2: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
13D5: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
13D8: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(INIT_RX_RX_PARITY_ERROR | INIT_RX_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_INIT_RX_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: INIT_RX_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
13D9: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
13DC: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
13DE: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
13E0: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  INIT_RX_iReadChar:
                                   (0523) _INIT_RX_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(INIT_RX_RX_ERROR|INIT_RX_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,INIT_RX_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_INIT_RX_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,INIT_RX_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_INIT_RX_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (INIT_RX_RXBUF_ENABLE)
                                   (0552) .SECTION
13E1: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
13E4: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
13E6: 21 F0    AND   A,240         (0555) ;
13E8: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
13EB: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: INIT_RX_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  INIT_RX_CmdReset:
13EC: 62 D0 00 MOV   REG[208],0    (0587) _INIT_RX_CmdReset:
13EF: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >INIT_RX_aRxBuffer
13F1: 7F       RET                 (0590)    mov [INIT_RX_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
                                   (0594)    mov [INIT_RX_bRxCnt], 0x00
                                   (0595)    and [INIT_RX_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: INIT_RX_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  INIT_RX_bCmdCheck:
                                   (0628) _INIT_RX_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0631)    mov A,  [INIT_RX_fStatus]
                                   (0632)    and A, INIT_RX_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: INIT_RX_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
13F2: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
13F4: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
13F7: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
13FA: 50 38    MOV   A,56          (0648) ;     BYTE  fStatus - Status of command receive buffer.
13FC: 02 DB    ADD   A,[219]       (0649) ;                     Returns non-zero value in A if command is valid.
13FE: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
13FF: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1401: B0 04    JNZ   0x1406        (0653) ;           0x10 => Software Buffer OverRun
1403: 10       PUSH  X             (0654) ;
1404: 80 33    JMP   0x1438        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1406: 39 00    CMP   A,0           (0660) ;    functions.
1408: B0 11    JNZ   0x141A        (0661) ;          
140A: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
140B: 76 DB    INC   [219]         (0663) ;          CUR_PP
140D: 52 00    MOV   A,[X+0]       (0664) ;
140F: 3C DB 0F CMP   [219],15      (0665) ;     Error Status is clear when read.
1412: BF F3    JNZ   0x1406        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1414: 10       PUSH  X             (0669) ;
                                   (0670)  INIT_RX_bErrCheck:
1415: 56 00 00 MOV   [X+0],0       (0671) _INIT_RX_bErrCheck:
1418: 80 1F    JMP   0x1438        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0674)    mov A,  [INIT_RX_fStatus]
141A: 10       PUSH  X             (0675)    and A, INIT_RX_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [INIT_RX_fStatus], ~INIT_RX_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
141B: 75       INC   X             (0679) .ENDSECTION
141C: 76 DB    INC   [219]         (0680) 
141E: 3C DB 0F CMP   [219],15      (0681) .SECTION
1421: AF F3    JZ    0x1415        (0682) ;-----------------------------------------------------------------------------
1423: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: INIT_RX_bCmdLength
1425: A0 12    JZ    0x1438        (0684) ;
1427: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1429: BF F1    JNZ   0x141B        (0686) ;     Get length of command string
                                   (0687) ;
142B: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
142E: 76 DB    INC   [219]         (0689) ;     none.
1430: 3C DB 0F CMP   [219],15      (0690) ;
1433: B0 04    JNZ   0x1438        (0691) ;  RETURNS:
1435: 55 DB 0F MOV   [219],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1438: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1439: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
143A: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
143D: B0 0B    JNZ   0x1449        (0699) ;    functions.
143F: 20       POP   X             (0700) ;          
1440: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1442: 50 00    MOV   A,0           (0702) ;          CUR_PP
1444: 70 3F    AND   F,63
1446: 71 C0    OR    F,192         (0703) ;
                                   (0704)  INIT_RX_bCmdLength:
1448: 7F       RET                 (0705) _INIT_RX_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
1449: 20       POP   X             (0708)    mov A,  [INIT_RX_bRxCnt]
144A: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
144C: 70 3F    AND   F,63
144E: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1450: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: INIT_RX_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1451: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1454: 50 38    MOV   A,56          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1456: 02 DB    ADD   A,[219]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1458: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1459: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     INIT_RX_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, INIT_RX_szGetParam, is
145C: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_timeout.asm
                                   (0102) ;;*****************************************************************************
145F: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: HELLO_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "HELLO_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1460: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1463: 7F       RET                 (0131) export  HELLO_TIMEOUT_EnableInt
                                   (0132) export _HELLO_TIMEOUT_EnableInt
                                   (0133) export  HELLO_TIMEOUT_DisableInt
                                   (0134) export _HELLO_TIMEOUT_DisableInt
                                   (0135) export  HELLO_TIMEOUT_Start
                                   (0136) export _HELLO_TIMEOUT_Start
                                   (0137) export  HELLO_TIMEOUT_Stop
                                   (0138) export _HELLO_TIMEOUT_Stop
                                   (0139) export  HELLO_TIMEOUT_WritePeriod
                                   (0140) export _HELLO_TIMEOUT_WritePeriod
                                   (0141) export  HELLO_TIMEOUT_WriteCompareValue
                                   (0142) export _HELLO_TIMEOUT_WriteCompareValue
                                   (0143) export  HELLO_TIMEOUT_wReadCompareValue
                                   (0144) export _HELLO_TIMEOUT_wReadCompareValue
                                   (0145) export  HELLO_TIMEOUT_wReadTimer
                                   (0146) export _HELLO_TIMEOUT_wReadTimer
                                   (0147) export  HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
1464: 43 23 01 OR    REG[35],1     (0157) export _wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1467: 7F       RET                 (0159) export  wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA hello_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: HELLO_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1468: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
146B: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  HELLO_TIMEOUT_EnableInt:
                                   (0200) _HELLO_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    HELLO_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: HELLO_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
146C: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
146E: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
146F: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1471: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  HELLO_TIMEOUT_DisableInt:
                                   (0228) _HELLO_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    HELLO_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: HELLO_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1472: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1474: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1475: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1477: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  HELLO_TIMEOUT_Start:
                                   (0256) _HELLO_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    HELLO_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: HELLO_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1478: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
147A: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
147B: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
147D: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  HELLO_TIMEOUT_Stop:
                                   (0284) _HELLO_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    HELLO_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: HELLO_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  HELLO_TIMEOUT_WritePeriod:
                                   (0313) _HELLO_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[HELLO_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[HELLO_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: HELLO_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call HELLO_TIMEOUT_Stop to disable).
147E: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
147F: 38 03    ADD   SP,3          (0334) ;
1481: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1483: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1484: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1486: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1487: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1489: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
148A: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
148C: 5D 26    MOV   A,REG[38]     (0343) ;
148E: 54 01    MOV   [X+1],A       (0344)  HELLO_TIMEOUT_WriteCompareValue:
1490: 5D 22    MOV   A,REG[34]     (0345) _HELLO_TIMEOUT_WriteCompareValue:
1492: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1494: 50 00    MOV   A,0           (0347)    mov   reg[HELLO_TIMEOUT_COMPARE_LSB_REG], A
1496: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1499: A0 03    JZ    0x149D        (0349)    mov   reg[HELLO_TIMEOUT_COMPARE_MSB_REG], A
149B: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
149D: 54 00    MOV   [X+0],A       (0352) 
149F: 70 FE    AND   F,254         (0353) .ENDSECTION
14A1: 41 23 FE AND   REG[35],254   (0354) 
14A4: 18       POP   A             (0355) 
14A5: 60 26    MOV   REG[38],A     (0356) .SECTION
14A7: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
14A8: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadCompareValue
14AA: 18       POP   A             (0359) ;
14AB: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
14AD: 18       POP   A             (0361) ;     Reads the Compare registers.
14AE: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
14AF: 70 3F    AND   F,63
14B1: 71 C0    OR    F,192         (0363) ;
14B3: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  HELLO_TIMEOUT_wReadCompareValue:
                                   (0374) _HELLO_TIMEOUT_wReadCompareValue:
                                   (0375)  wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[HELLO_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[HELLO_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
14B4: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
14B6: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
14B8: 5C       MOV   X,A           (0409) ;
14B9: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
14BC: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\hello_4int.asm
14BD: 10       PUSH  X             (0104) ;;*****************************************************************************
14BE: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_4INT.asm
14C0: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
14C1: 58 09    MOV   X,[9]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
14C3: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
14C5: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
14C6: 21 08    AND   A,8           (0114) ;;*****************************************************************************
14C8: B0 04    JNZ   0x14CD        (0115) 
14CA: 18       POP   A             (0116) include "m8c.inc"
14CB: 80 5E    JMP   0x152A        (0117) include "memory.inc"
                                   (0118) include "HELLO_4.inc"
                                   (0119) 
                                   (0120) 
14CD: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
14CE: 21 E0    AND   A,224         (0124) export  _HELLO_4_ISR
14D0: A0 12    JZ    0x14E3        (0125) 
                                   (0126) 
14D2: 2C 08    OR    [8],A         (0127) IF (HELLO_4_RXBUF_ENABLE)
                                   (0128) export  HELLO_4_aRxBuffer
14D4: 49 3E 00 TST   REG[62],0     (0129) export _HELLO_4_aRxBuffer
                                   (0130) export  HELLO_4_bRxCnt
14D7: 21 20    AND   A,32          (0131) export _HELLO_4_bRxCnt
14D9: A0 50    JZ    0x152A        (0132) export  HELLO_4_fStatus
                                   (0133) export _HELLO_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
14DB: 41 3F FE AND   REG[63],254   (0136) 
14DE: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
14E1: 80 48    JMP   0x152A        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_4_RXBUF_ENABLE)
14E3: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_4_fStatus:
                                   (0144) _HELLO_4_fStatus:      BLK  1
14E5: 47 08 01 TST   [8],1         (0145)  HELLO_4_bRxCnt:
14E8: B0 41    JNZ   0x152A        (0146) _HELLO_4_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_4_RAM(RAM,REL,CON)
14EA: 39 00    CMP   A,0           (0148)  HELLO_4_aRxBuffer:    
14EC: B0 14    JNZ   0x1501        (0149) _HELLO_4_aRxBuffer:    BLK HELLO_4_RX_BUFFER_SIZE
14EE: 2E 08 01 OR    [8],1         (0150) ENDIF
                                   (0151) 
14F1: 62 D3 00 MOV   REG[211],0    (0152) 
14F4: 70 3F    AND   F,63
14F6: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
14F8: 56 18 00 MOV   [X+24],0      (0154) 
14FB: 70 3F    AND   F,63
14FD: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
14FF: 80 2A    JMP   0x152A        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1501: 3C 09 0F CMP   [9],15        (0167) ;------------------------
1504: C0 14    JC    0x1519        (0168) 
1506: 2E 08 10 OR    [8],16        (0169) 
                                   (0170) ;------------------------
1509: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
150C: 70 3F    AND   F,63
150E: 71 80    OR    F,128         (0172) ;------------------------
1510: 56 18 00 MOV   [X+24],0      (0173) 
1513: 70 3F    AND   F,63
1515: 71 00    OR    F,0           (0174) 
1517: 80 12    JMP   0x152A        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1519: 75       INC   X             (0179) 
151A: 5A 09    MOV   [9],X         (0180) 
151C: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
151D: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1520: 70 3F    AND   F,63
1522: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_4_ISR
1524: 54 18    MOV   [X+24],A      (0185) ;
1526: 70 3F    AND   F,63
1528: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
152A: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
152B: 60 D3    MOV   REG[211],A    (0191) _HELLO_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
152D: 20       POP   X             (0195)    ; Insert your custom code below this banner
152E: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1530: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\hello_4.asm
                                   (0121) ;;*****************************************************************************
1533: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_4.inc"
1534: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
1537: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_4_EnableInt
                                   (0155) export  _HELLO_4_EnableInt
                                   (0156) export   HELLO_4_DisableInt
                                   (0157) export  _HELLO_4_DisableInt
                                   (0158) export   HELLO_4_Start
                                   (0159) export  _HELLO_4_Start
                                   (0160) export   HELLO_4_Stop
                                   (0161) export  _HELLO_4_Stop
                                   (0162) export   HELLO_4_bReadRxData
                                   (0163) export  _HELLO_4_bReadRxData
                                   (0164) export   HELLO_4_bReadRxStatus
                                   (0165) export  _HELLO_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_4_ReadRxData
                                   (0170) export _bHELLO_4_ReadRxData
                                   (0171) export  bHELLO_4_ReadRxStatus
                                   (0172) export _bHELLO_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_4_cGetChar
1538: 29 01    OR    A,1           (0179) export _HELLO_4_cGetChar
153A: 60 3F    MOV   REG[63],A     (0180) export  HELLO_4_cReadChar
                                   (0181) export _HELLO_4_cReadChar
153C: 7F       RET                 (0182) export  HELLO_4_iReadChar
                                   (0183) export _HELLO_4_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_4_RXBUF_ENABLE)
                                   (0186) export  HELLO_4_CmdReset
                                   (0187) export _HELLO_4_CmdReset
                                   (0188) export  HELLO_4_bCmdCheck
                                   (0189) export _HELLO_4_bCmdCheck
                                   (0190) export  HELLO_4_bCmdLength
                                   (0191) export _HELLO_4_bCmdLength
                                   (0192) export  HELLO_4_bErrCheck
                                   (0193) export _HELLO_4_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_4_szGetParam
                                   (0196) export _HELLO_4_szGetParam
                                   (0197) export  HELLO_4_szGetRestOfParams
                                   (0198) export _HELLO_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
153D: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1540: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_4_EnableInt:
                                   (0238) _HELLO_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1541: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1543: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_4_DisableInt:
                                   (0267) _HELLO_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1544: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
1546: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_4_Start:
                                   (0297) _HELLO_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1547: 49 3F 08 TST   REG[63],8     (0311) ;
154A: AF FC    JZ    0x1547        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
154C: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
154E: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_4_Stop:
                                   (0326) _HELLO_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
154F: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
1551: 08       PUSH  A             (0347) ;
1552: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1554: B0 04    JNZ   0x1559        (0349) ;    The A and X registers may be modified by this or future implementations
1556: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1557: 80 0B    JMP   0x1563        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1559: 5D 3E    MOV   A,REG[62]     (0354) ;
155B: 4B       SWAP  A,X           (0355)  HELLO_4_bReadRxData:
                                   (0356) _HELLO_4_bReadRxData:
155C: 18       POP   A             (0357)  bHELLO_4_ReadRxData:
155D: 21 A0    AND   A,160         (0358) _bHELLO_4_ReadRxData:
155F: B0 03    JNZ   0x1563        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1561: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1562: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1563: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_4_bReadRxStatus
                                   (0368) ;
1565: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_4_bReadRxStatus:
                                   (0388) _HELLO_4_bReadRxStatus:
                                   (0389)  bHELLO_4_ReadRxStatus:
                                   (0390) _bHELLO_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1566: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1568: 21 E8    AND   A,232         (0408) ;
156A: 08       PUSH  A             (0409) ;  ARGUMENTS:
156B: 21 08    AND   A,8           (0410) ;      none
156D: B0 07    JNZ   0x1575        (0411) ;
156F: 18       POP   A             (0412) ;  RETURNS:
1570: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1572: 4B       SWAP  A,X           (0414) ;
1573: 80 07    JMP   0x157B        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1575: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1576: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1578: 4B       SWAP  A,X           (0420) ;    functions.
1579: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
157B: 7F       RET                 (0426)  HELLO_4_cGetChar:
                                   (0427) _HELLO_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_4_CONTROL_REG],HELLO_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_4_cReadChar:
                                   (0463) _HELLO_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
157C: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
157F: 55 18 00 MOV   [24],0        (0470)    pop  A
1582: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1585: 55 DA 00 MOV   [218],0       (0472) 
1588: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
158B: 55 09 00 MOV   [9],0         (0474)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
158E: 26 08 00 AND   [8],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1591: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_4_RX_PARITY_ERROR | HELLO_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1592: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1595: 51 08    MOV   A,[8]         (0511) ;        0x40CC    Overrun Error
1597: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1599: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_4_iReadChar:
                                   (0523) _HELLO_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_4_RX_ERROR|HELLO_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_4_RXBUF_ENABLE)
                                   (0552) .SECTION
159A: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
159D: 51 08    MOV   A,[8]         (0554) ;-----------------------------------------------------------------------------
159F: 21 F0    AND   A,240         (0555) ;
15A1: 26 08 0F AND   [8],15        (0556) ;     Command Buffer commands
                                   (0557) ;
15A4: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_4_CmdReset:
15A5: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_4_CmdReset:
15A8: 51 09    MOV   A,[9]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_4_aRxBuffer
15AA: 7F       RET                 (0590)    mov [HELLO_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
                                   (0594)    mov [HELLO_4_bRxCnt], 0x00
                                   (0595)    and [HELLO_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_4_bCmdCheck:
                                   (0628) _HELLO_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0631)    mov A,  [HELLO_4_fStatus]
                                   (0632)    and A, HELLO_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
15AB: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
15AD: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
15B0: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
15B3: 50 18    MOV   A,24          (0648) ;     BYTE  fStatus - Status of command receive buffer.
15B5: 02 DA    ADD   A,[218]       (0649) ;                     Returns non-zero value in A if command is valid.
15B7: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
15B8: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
15BA: B0 04    JNZ   0x15BF        (0653) ;           0x10 => Software Buffer OverRun
15BC: 10       PUSH  X             (0654) ;
15BD: 80 33    JMP   0x15F1        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
15BF: 39 00    CMP   A,0           (0660) ;    functions.
15C1: B0 11    JNZ   0x15D3        (0661) ;          
15C3: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
15C4: 76 DA    INC   [218]         (0663) ;          CUR_PP
15C6: 52 00    MOV   A,[X+0]       (0664) ;
15C8: 3C DA 0F CMP   [218],15      (0665) ;     Error Status is clear when read.
15CB: BF F3    JNZ   0x15BF        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
15CD: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_4_bErrCheck:
15CE: 56 00 00 MOV   [X+0],0       (0671) _HELLO_4_bErrCheck:
15D1: 80 1F    JMP   0x15F1        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0674)    mov A,  [HELLO_4_fStatus]
15D3: 10       PUSH  X             (0675)    and A, HELLO_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_4_fStatus], ~HELLO_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
15D4: 75       INC   X             (0679) .ENDSECTION
15D5: 76 DA    INC   [218]         (0680) 
15D7: 3C DA 0F CMP   [218],15      (0681) .SECTION
15DA: AF F3    JZ    0x15CE        (0682) ;-----------------------------------------------------------------------------
15DC: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_4_bCmdLength
15DE: A0 12    JZ    0x15F1        (0684) ;
15E0: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
15E2: BF F1    JNZ   0x15D4        (0686) ;     Get length of command string
                                   (0687) ;
15E4: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
15E7: 76 DA    INC   [218]         (0689) ;     none.
15E9: 3C DA 0F CMP   [218],15      (0690) ;
15EC: B0 04    JNZ   0x15F1        (0691) ;  RETURNS:
15EE: 55 DA 0F MOV   [218],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
15F1: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
15F2: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
15F3: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
15F6: B0 0B    JNZ   0x1602        (0699) ;    functions.
15F8: 20       POP   X             (0700) ;          
15F9: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
15FB: 50 00    MOV   A,0           (0702) ;          CUR_PP
15FD: 70 3F    AND   F,63
15FF: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_4_bCmdLength:
1601: 7F       RET                 (0705) _HELLO_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
1602: 20       POP   X             (0708)    mov A,  [HELLO_4_bRxCnt]
1603: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1605: 70 3F    AND   F,63
1607: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1609: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
160A: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
160D: 50 18    MOV   A,24          (0744) ;     each lexically distinct element into a null-terminated string by replacing
160F: 02 DA    ADD   A,[218]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1611: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1612: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_4_szGetParam, is
1615: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_3int.asm
1616: 10       PUSH  X             (0104) ;;*****************************************************************************
1617: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_3INT.asm
1619: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
161A: 58 0B    MOV   X,[11]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
161C: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
161E: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
161F: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1621: B0 04    JNZ   0x1626        (0115) 
1623: 18       POP   A             (0116) include "m8c.inc"
1624: 80 5E    JMP   0x1683        (0117) include "memory.inc"
                                   (0118) include "HELLO_3.inc"
                                   (0119) 
                                   (0120) 
1626: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1627: 21 E0    AND   A,224         (0124) export  _HELLO_3_ISR
1629: A0 12    JZ    0x163C        (0125) 
                                   (0126) 
162B: 2C 0A    OR    [10],A        (0127) IF (HELLO_3_RXBUF_ENABLE)
                                   (0128) export  HELLO_3_aRxBuffer
162D: 49 3A 00 TST   REG[58],0     (0129) export _HELLO_3_aRxBuffer
                                   (0130) export  HELLO_3_bRxCnt
1630: 21 20    AND   A,32          (0131) export _HELLO_3_bRxCnt
1632: A0 50    JZ    0x1683        (0132) export  HELLO_3_fStatus
                                   (0133) export _HELLO_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1634: 41 3B FE AND   REG[59],254   (0136) 
1637: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
163A: 80 48    JMP   0x1683        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_3_RXBUF_ENABLE)
163C: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_3_fStatus:
                                   (0144) _HELLO_3_fStatus:      BLK  1
163E: 47 0A 01 TST   [10],1        (0145)  HELLO_3_bRxCnt:
1641: B0 41    JNZ   0x1683        (0146) _HELLO_3_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_3_RAM(RAM,REL,CON)
1643: 39 00    CMP   A,0           (0148)  HELLO_3_aRxBuffer:    
1645: B0 14    JNZ   0x165A        (0149) _HELLO_3_aRxBuffer:    BLK HELLO_3_RX_BUFFER_SIZE
1647: 2E 0A 01 OR    [10],1        (0150) ENDIF
                                   (0151) 
164A: 62 D3 00 MOV   REG[211],0    (0152) 
164D: 70 3F    AND   F,63
164F: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1651: 56 28 00 MOV   [X+40],0      (0154) 
1654: 70 3F    AND   F,63
1656: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1658: 80 2A    JMP   0x1683        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
165A: 3C 0B 0F CMP   [11],15       (0167) ;------------------------
165D: C0 14    JC    0x1672        (0168) 
165F: 2E 0A 10 OR    [10],16       (0169) 
                                   (0170) ;------------------------
1662: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1665: 70 3F    AND   F,63
1667: 71 80    OR    F,128         (0172) ;------------------------
1669: 56 28 00 MOV   [X+40],0      (0173) 
166C: 70 3F    AND   F,63
166E: 71 00    OR    F,0           (0174) 
1670: 80 12    JMP   0x1683        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1672: 75       INC   X             (0179) 
1673: 5A 0B    MOV   [11],X        (0180) 
1675: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1676: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1679: 70 3F    AND   F,63
167B: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_3_ISR
167D: 54 28    MOV   [X+40],A      (0185) ;
167F: 70 3F    AND   F,63
1681: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1683: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1684: 60 D3    MOV   REG[211],A    (0191) _HELLO_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1686: 20       POP   X             (0195)    ; Insert your custom code below this banner
1687: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1689: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\hello_3.asm
                                   (0121) ;;*****************************************************************************
168C: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_3.inc"
168D: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
1690: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_3_EnableInt
                                   (0155) export  _HELLO_3_EnableInt
                                   (0156) export   HELLO_3_DisableInt
                                   (0157) export  _HELLO_3_DisableInt
                                   (0158) export   HELLO_3_Start
                                   (0159) export  _HELLO_3_Start
                                   (0160) export   HELLO_3_Stop
                                   (0161) export  _HELLO_3_Stop
                                   (0162) export   HELLO_3_bReadRxData
                                   (0163) export  _HELLO_3_bReadRxData
                                   (0164) export   HELLO_3_bReadRxStatus
                                   (0165) export  _HELLO_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_3_ReadRxData
                                   (0170) export _bHELLO_3_ReadRxData
                                   (0171) export  bHELLO_3_ReadRxStatus
                                   (0172) export _bHELLO_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_3_cGetChar
1691: 29 01    OR    A,1           (0179) export _HELLO_3_cGetChar
1693: 60 3B    MOV   REG[59],A     (0180) export  HELLO_3_cReadChar
                                   (0181) export _HELLO_3_cReadChar
1695: 7F       RET                 (0182) export  HELLO_3_iReadChar
                                   (0183) export _HELLO_3_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_3_RXBUF_ENABLE)
                                   (0186) export  HELLO_3_CmdReset
                                   (0187) export _HELLO_3_CmdReset
                                   (0188) export  HELLO_3_bCmdCheck
                                   (0189) export _HELLO_3_bCmdCheck
                                   (0190) export  HELLO_3_bCmdLength
                                   (0191) export _HELLO_3_bCmdLength
                                   (0192) export  HELLO_3_bErrCheck
                                   (0193) export _HELLO_3_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_3_szGetParam
                                   (0196) export _HELLO_3_szGetParam
                                   (0197) export  HELLO_3_szGetRestOfParams
                                   (0198) export _HELLO_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1696: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1699: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_3_EnableInt:
                                   (0238) _HELLO_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
169A: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
169C: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_3_DisableInt:
                                   (0267) _HELLO_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
169D: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
169F: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_3_Start:
                                   (0297) _HELLO_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
16A0: 49 3B 08 TST   REG[59],8     (0311) ;
16A3: AF FC    JZ    0x16A0        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
16A5: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
16A7: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_3_Stop:
                                   (0326) _HELLO_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
16A8: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
16AA: 08       PUSH  A             (0347) ;
16AB: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
16AD: B0 04    JNZ   0x16B2        (0349) ;    The A and X registers may be modified by this or future implementations
16AF: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
16B0: 80 0B    JMP   0x16BC        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
16B2: 5D 3A    MOV   A,REG[58]     (0354) ;
16B4: 4B       SWAP  A,X           (0355)  HELLO_3_bReadRxData:
                                   (0356) _HELLO_3_bReadRxData:
16B5: 18       POP   A             (0357)  bHELLO_3_ReadRxData:
16B6: 21 A0    AND   A,160         (0358) _bHELLO_3_ReadRxData:
16B8: B0 03    JNZ   0x16BC        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
16BA: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
16BB: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
16BC: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_3_bReadRxStatus
                                   (0368) ;
16BE: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_3_bReadRxStatus:
                                   (0388) _HELLO_3_bReadRxStatus:
                                   (0389)  bHELLO_3_ReadRxStatus:
                                   (0390) _bHELLO_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
16BF: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
16C1: 21 E8    AND   A,232         (0408) ;
16C3: 08       PUSH  A             (0409) ;  ARGUMENTS:
16C4: 21 08    AND   A,8           (0410) ;      none
16C6: B0 07    JNZ   0x16CE        (0411) ;
16C8: 18       POP   A             (0412) ;  RETURNS:
16C9: 29 01    OR    A,1           (0413) ;     char that is returned from UART
16CB: 4B       SWAP  A,X           (0414) ;
16CC: 80 07    JMP   0x16D4        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
16CE: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
16CF: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
16D1: 4B       SWAP  A,X           (0420) ;    functions.
16D2: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
16D4: 7F       RET                 (0426)  HELLO_3_cGetChar:
                                   (0427) _HELLO_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_3_CONTROL_REG],HELLO_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_3_cReadChar:
                                   (0463) _HELLO_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
16D5: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
16D8: 55 28 00 MOV   [40],0        (0470)    pop  A
16DB: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
16DE: 55 D9 00 MOV   [217],0       (0472) 
16E1: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
16E4: 55 0B 00 MOV   [11],0        (0474)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
16E7: 26 0A 00 AND   [10],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
16EA: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_3_RX_PARITY_ERROR | HELLO_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
16EB: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
16EE: 51 0A    MOV   A,[10]        (0511) ;        0x40CC    Overrun Error
16F0: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
16F2: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_3_iReadChar:
                                   (0523) _HELLO_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_3_RX_ERROR|HELLO_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_3_RXBUF_ENABLE)
                                   (0552) .SECTION
16F3: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
16F6: 51 0A    MOV   A,[10]        (0554) ;-----------------------------------------------------------------------------
16F8: 21 F0    AND   A,240         (0555) ;
16FA: 26 0A 0F AND   [10],15       (0556) ;     Command Buffer commands
                                   (0557) ;
16FD: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_3_CmdReset:
16FE: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_3_CmdReset:
1701: 51 0B    MOV   A,[11]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_3_aRxBuffer
1703: 7F       RET                 (0590)    mov [HELLO_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
                                   (0594)    mov [HELLO_3_bRxCnt], 0x00
                                   (0595)    and [HELLO_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_3_bCmdCheck:
                                   (0628) _HELLO_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0631)    mov A,  [HELLO_3_fStatus]
                                   (0632)    and A, HELLO_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1704: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1706: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1709: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
170C: 50 28    MOV   A,40          (0648) ;     BYTE  fStatus - Status of command receive buffer.
170E: 02 D9    ADD   A,[217]       (0649) ;                     Returns non-zero value in A if command is valid.
1710: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1711: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1713: B0 04    JNZ   0x1718        (0653) ;           0x10 => Software Buffer OverRun
1715: 10       PUSH  X             (0654) ;
1716: 80 33    JMP   0x174A        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1718: 39 00    CMP   A,0           (0660) ;    functions.
171A: B0 11    JNZ   0x172C        (0661) ;          
171C: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
171D: 76 D9    INC   [217]         (0663) ;          CUR_PP
171F: 52 00    MOV   A,[X+0]       (0664) ;
1721: 3C D9 0F CMP   [217],15      (0665) ;     Error Status is clear when read.
1724: BF F3    JNZ   0x1718        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1726: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_3_bErrCheck:
1727: 56 00 00 MOV   [X+0],0       (0671) _HELLO_3_bErrCheck:
172A: 80 1F    JMP   0x174A        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0674)    mov A,  [HELLO_3_fStatus]
172C: 10       PUSH  X             (0675)    and A, HELLO_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_3_fStatus], ~HELLO_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
172D: 75       INC   X             (0679) .ENDSECTION
172E: 76 D9    INC   [217]         (0680) 
1730: 3C D9 0F CMP   [217],15      (0681) .SECTION
1733: AF F3    JZ    0x1727        (0682) ;-----------------------------------------------------------------------------
1735: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_3_bCmdLength
1737: A0 12    JZ    0x174A        (0684) ;
1739: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
173B: BF F1    JNZ   0x172D        (0686) ;     Get length of command string
                                   (0687) ;
173D: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1740: 76 D9    INC   [217]         (0689) ;     none.
1742: 3C D9 0F CMP   [217],15      (0690) ;
1745: B0 04    JNZ   0x174A        (0691) ;  RETURNS:
1747: 55 D9 0F MOV   [217],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
174A: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
174B: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
174C: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
174F: B0 0B    JNZ   0x175B        (0699) ;    functions.
1751: 20       POP   X             (0700) ;          
1752: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1754: 50 00    MOV   A,0           (0702) ;          CUR_PP
1756: 70 3F    AND   F,63
1758: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_3_bCmdLength:
175A: 7F       RET                 (0705) _HELLO_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
175B: 20       POP   X             (0708)    mov A,  [HELLO_3_bRxCnt]
175C: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
175E: 70 3F    AND   F,63
1760: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1762: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1763: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1766: 50 28    MOV   A,40          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1768: 02 D9    ADD   A,[217]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
176A: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
176B: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_3_szGetParam, is
176E: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_2int.asm
176F: 10       PUSH  X             (0104) ;;*****************************************************************************
1770: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_2INT.asm
1772: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1773: 58 0D    MOV   X,[13]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1775: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
1777: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1778: 21 08    AND   A,8           (0114) ;;*****************************************************************************
177A: B0 04    JNZ   0x177F        (0115) 
177C: 18       POP   A             (0116) include "m8c.inc"
177D: 80 5E    JMP   0x17DC        (0117) include "memory.inc"
                                   (0118) include "HELLO_2.inc"
                                   (0119) 
                                   (0120) 
177F: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1780: 21 E0    AND   A,224         (0124) export  _HELLO_2_ISR
1782: A0 12    JZ    0x1795        (0125) 
                                   (0126) 
1784: 2C 0C    OR    [12],A        (0127) IF (HELLO_2_RXBUF_ENABLE)
                                   (0128) export  HELLO_2_aRxBuffer
1786: 49 2E 00 TST   REG[46],0     (0129) export _HELLO_2_aRxBuffer
                                   (0130) export  HELLO_2_bRxCnt
1789: 21 20    AND   A,32          (0131) export _HELLO_2_bRxCnt
178B: A0 50    JZ    0x17DC        (0132) export  HELLO_2_fStatus
                                   (0133) export _HELLO_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
178D: 41 2F FE AND   REG[47],254   (0136) 
1790: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
1793: 80 48    JMP   0x17DC        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_2_RXBUF_ENABLE)
1795: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_2_fStatus:
                                   (0144) _HELLO_2_fStatus:      BLK  1
1797: 47 0C 01 TST   [12],1        (0145)  HELLO_2_bRxCnt:
179A: B0 41    JNZ   0x17DC        (0146) _HELLO_2_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_2_RAM(RAM,REL,CON)
179C: 39 00    CMP   A,0           (0148)  HELLO_2_aRxBuffer:    
179E: B0 14    JNZ   0x17B3        (0149) _HELLO_2_aRxBuffer:    BLK HELLO_2_RX_BUFFER_SIZE
17A0: 2E 0C 01 OR    [12],1        (0150) ENDIF
                                   (0151) 
17A3: 62 D3 00 MOV   REG[211],0    (0152) 
17A6: 70 3F    AND   F,63
17A8: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
17AA: 56 B8 00 MOV   [X-72],0      (0154) 
17AD: 70 3F    AND   F,63
17AF: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
17B1: 80 2A    JMP   0x17DC        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
17B3: 3C 0D 0F CMP   [13],15       (0167) ;------------------------
17B6: C0 14    JC    0x17CB        (0168) 
17B8: 2E 0C 10 OR    [12],16       (0169) 
                                   (0170) ;------------------------
17BB: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
17BE: 70 3F    AND   F,63
17C0: 71 80    OR    F,128         (0172) ;------------------------
17C2: 56 B8 00 MOV   [X-72],0      (0173) 
17C5: 70 3F    AND   F,63
17C7: 71 00    OR    F,0           (0174) 
17C9: 80 12    JMP   0x17DC        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
17CB: 75       INC   X             (0179) 
17CC: 5A 0D    MOV   [13],X        (0180) 
17CE: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
17CF: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
17D2: 70 3F    AND   F,63
17D4: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_2_ISR
17D6: 54 B8    MOV   [X-72],A      (0185) ;
17D8: 70 3F    AND   F,63
17DA: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
17DC: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
17DD: 60 D3    MOV   REG[211],A    (0191) _HELLO_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
17DF: 20       POP   X             (0195)    ; Insert your custom code below this banner
17E0: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
17E2: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_2.asm
                                   (0121) ;;*****************************************************************************
17E5: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_2.inc"
17E6: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
17E9: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_2_EnableInt
                                   (0155) export  _HELLO_2_EnableInt
                                   (0156) export   HELLO_2_DisableInt
                                   (0157) export  _HELLO_2_DisableInt
                                   (0158) export   HELLO_2_Start
                                   (0159) export  _HELLO_2_Start
                                   (0160) export   HELLO_2_Stop
                                   (0161) export  _HELLO_2_Stop
                                   (0162) export   HELLO_2_bReadRxData
                                   (0163) export  _HELLO_2_bReadRxData
                                   (0164) export   HELLO_2_bReadRxStatus
                                   (0165) export  _HELLO_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_2_ReadRxData
                                   (0170) export _bHELLO_2_ReadRxData
                                   (0171) export  bHELLO_2_ReadRxStatus
                                   (0172) export _bHELLO_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_2_cGetChar
17EA: 29 01    OR    A,1           (0179) export _HELLO_2_cGetChar
17EC: 60 2F    MOV   REG[47],A     (0180) export  HELLO_2_cReadChar
                                   (0181) export _HELLO_2_cReadChar
17EE: 7F       RET                 (0182) export  HELLO_2_iReadChar
                                   (0183) export _HELLO_2_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_2_RXBUF_ENABLE)
                                   (0186) export  HELLO_2_CmdReset
                                   (0187) export _HELLO_2_CmdReset
                                   (0188) export  HELLO_2_bCmdCheck
                                   (0189) export _HELLO_2_bCmdCheck
                                   (0190) export  HELLO_2_bCmdLength
                                   (0191) export _HELLO_2_bCmdLength
                                   (0192) export  HELLO_2_bErrCheck
                                   (0193) export _HELLO_2_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_2_szGetParam
                                   (0196) export _HELLO_2_szGetParam
                                   (0197) export  HELLO_2_szGetRestOfParams
                                   (0198) export _HELLO_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
17EF: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
17F2: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_2_EnableInt:
                                   (0238) _HELLO_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
17F3: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
17F5: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_2_DisableInt:
                                   (0267) _HELLO_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
17F6: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
17F8: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_2_Start:
                                   (0297) _HELLO_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
17F9: 49 2F 08 TST   REG[47],8     (0311) ;
17FC: AF FC    JZ    0x17F9        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
17FE: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1800: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_2_Stop:
                                   (0326) _HELLO_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1801: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
1803: 08       PUSH  A             (0347) ;
1804: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1806: B0 04    JNZ   0x180B        (0349) ;    The A and X registers may be modified by this or future implementations
1808: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1809: 80 0B    JMP   0x1815        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
180B: 5D 2E    MOV   A,REG[46]     (0354) ;
180D: 4B       SWAP  A,X           (0355)  HELLO_2_bReadRxData:
                                   (0356) _HELLO_2_bReadRxData:
180E: 18       POP   A             (0357)  bHELLO_2_ReadRxData:
180F: 21 A0    AND   A,160         (0358) _bHELLO_2_ReadRxData:
1811: B0 03    JNZ   0x1815        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1813: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1814: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1815: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_2_bReadRxStatus
                                   (0368) ;
1817: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_2_bReadRxStatus:
                                   (0388) _HELLO_2_bReadRxStatus:
                                   (0389)  bHELLO_2_ReadRxStatus:
                                   (0390) _bHELLO_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1818: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
181A: 21 E8    AND   A,232         (0408) ;
181C: 08       PUSH  A             (0409) ;  ARGUMENTS:
181D: 21 08    AND   A,8           (0410) ;      none
181F: B0 07    JNZ   0x1827        (0411) ;
1821: 18       POP   A             (0412) ;  RETURNS:
1822: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1824: 4B       SWAP  A,X           (0414) ;
1825: 80 07    JMP   0x182D        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1827: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1828: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
182A: 4B       SWAP  A,X           (0420) ;    functions.
182B: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
182D: 7F       RET                 (0426)  HELLO_2_cGetChar:
                                   (0427) _HELLO_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_2_CONTROL_REG],HELLO_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_2_cReadChar:
                                   (0463) _HELLO_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
182E: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1831: 55 B8 00 MOV   [184],0       (0470)    pop  A
1834: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1837: 55 D8 00 MOV   [216],0       (0472) 
183A: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
183D: 55 0D 00 MOV   [13],0        (0474)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
1840: 26 0C 00 AND   [12],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1843: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_2_RX_PARITY_ERROR | HELLO_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1844: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1847: 51 0C    MOV   A,[12]        (0511) ;        0x40CC    Overrun Error
1849: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
184B: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_2_iReadChar:
                                   (0523) _HELLO_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_2_RX_ERROR|HELLO_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_2_RXBUF_ENABLE)
                                   (0552) .SECTION
184C: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
184F: 51 0C    MOV   A,[12]        (0554) ;-----------------------------------------------------------------------------
1851: 21 F0    AND   A,240         (0555) ;
1853: 26 0C 0F AND   [12],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1856: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_2_CmdReset:
1857: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_2_CmdReset:
185A: 51 0D    MOV   A,[13]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_2_aRxBuffer
185C: 7F       RET                 (0590)    mov [HELLO_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
                                   (0594)    mov [HELLO_2_bRxCnt], 0x00
                                   (0595)    and [HELLO_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_2_bCmdCheck:
                                   (0628) _HELLO_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0631)    mov A,  [HELLO_2_fStatus]
                                   (0632)    and A, HELLO_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
185D: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
185F: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1862: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1865: 50 B8    MOV   A,184         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1867: 02 D8    ADD   A,[216]       (0649) ;                     Returns non-zero value in A if command is valid.
1869: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
186A: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
186C: B0 04    JNZ   0x1871        (0653) ;           0x10 => Software Buffer OverRun
186E: 10       PUSH  X             (0654) ;
186F: 80 33    JMP   0x18A3        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1871: 39 00    CMP   A,0           (0660) ;    functions.
1873: B0 11    JNZ   0x1885        (0661) ;          
1875: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1876: 76 D8    INC   [216]         (0663) ;          CUR_PP
1878: 52 00    MOV   A,[X+0]       (0664) ;
187A: 3C D8 0F CMP   [216],15      (0665) ;     Error Status is clear when read.
187D: BF F3    JNZ   0x1871        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
187F: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_2_bErrCheck:
1880: 56 00 00 MOV   [X+0],0       (0671) _HELLO_2_bErrCheck:
1883: 80 1F    JMP   0x18A3        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0674)    mov A,  [HELLO_2_fStatus]
1885: 10       PUSH  X             (0675)    and A, HELLO_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_2_fStatus], ~HELLO_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1886: 75       INC   X             (0679) .ENDSECTION
1887: 76 D8    INC   [216]         (0680) 
1889: 3C D8 0F CMP   [216],15      (0681) .SECTION
188C: AF F3    JZ    0x1880        (0682) ;-----------------------------------------------------------------------------
188E: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_2_bCmdLength
1890: A0 12    JZ    0x18A3        (0684) ;
1892: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1894: BF F1    JNZ   0x1886        (0686) ;     Get length of command string
                                   (0687) ;
1896: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1899: 76 D8    INC   [216]         (0689) ;     none.
189B: 3C D8 0F CMP   [216],15      (0690) ;
189E: B0 04    JNZ   0x18A3        (0691) ;  RETURNS:
18A0: 55 D8 0F MOV   [216],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
18A3: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
18A4: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
18A5: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
18A8: B0 0B    JNZ   0x18B4        (0699) ;    functions.
18AA: 20       POP   X             (0700) ;          
18AB: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
18AD: 50 00    MOV   A,0           (0702) ;          CUR_PP
18AF: 70 3F    AND   F,63
18B1: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_2_bCmdLength:
18B3: 7F       RET                 (0705) _HELLO_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
18B4: 20       POP   X             (0708)    mov A,  [HELLO_2_bRxCnt]
18B5: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
18B7: 70 3F    AND   F,63
18B9: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
18BB: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
18BC: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
18BF: 50 B8    MOV   A,184         (0744) ;     each lexically distinct element into a null-terminated string by replacing
18C1: 02 D8    ADD   A,[216]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
18C3: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
18C4: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_2_szGetParam, is
18C7: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_1int.asm
18C8: 10       PUSH  X             (0104) ;;*****************************************************************************
18C9: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_1INT.asm
18CB: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
18CC: 58 0F    MOV   X,[15]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
18CE: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
18D0: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
18D1: 21 08    AND   A,8           (0114) ;;*****************************************************************************
18D3: B0 04    JNZ   0x18D8        (0115) 
18D5: 18       POP   A             (0116) include "m8c.inc"
18D6: 80 5E    JMP   0x1935        (0117) include "memory.inc"
                                   (0118) include "HELLO_1.inc"
                                   (0119) 
                                   (0120) 
18D8: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
18D9: 21 E0    AND   A,224         (0124) export  _HELLO_1_ISR
18DB: A0 12    JZ    0x18EE        (0125) 
                                   (0126) 
18DD: 2C 0E    OR    [14],A        (0127) IF (HELLO_1_RXBUF_ENABLE)
                                   (0128) export  HELLO_1_aRxBuffer
18DF: 49 2A 00 TST   REG[42],0     (0129) export _HELLO_1_aRxBuffer
                                   (0130) export  HELLO_1_bRxCnt
18E2: 21 20    AND   A,32          (0131) export _HELLO_1_bRxCnt
18E4: A0 50    JZ    0x1935        (0132) export  HELLO_1_fStatus
                                   (0133) export _HELLO_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
18E6: 41 2B FE AND   REG[43],254   (0136) 
18E9: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
18EC: 80 48    JMP   0x1935        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_1_RXBUF_ENABLE)
18EE: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_1_fStatus:
                                   (0144) _HELLO_1_fStatus:      BLK  1
18F0: 47 0E 01 TST   [14],1        (0145)  HELLO_1_bRxCnt:
18F3: B0 41    JNZ   0x1935        (0146) _HELLO_1_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_1_RAM(RAM,REL,CON)
18F5: 39 00    CMP   A,0           (0148)  HELLO_1_aRxBuffer:    
18F7: B0 14    JNZ   0x190C        (0149) _HELLO_1_aRxBuffer:    BLK HELLO_1_RX_BUFFER_SIZE
18F9: 2E 0E 01 OR    [14],1        (0150) ENDIF
                                   (0151) 
18FC: 62 D3 00 MOV   REG[211],0    (0152) 
18FF: 70 3F    AND   F,63
1901: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1903: 56 68 00 MOV   [X+104],0     (0154) 
1906: 70 3F    AND   F,63
1908: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
190A: 80 2A    JMP   0x1935        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
190C: 3C 0F 0F CMP   [15],15       (0167) ;------------------------
190F: C0 14    JC    0x1924        (0168) 
1911: 2E 0E 10 OR    [14],16       (0169) 
                                   (0170) ;------------------------
1914: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1917: 70 3F    AND   F,63
1919: 71 80    OR    F,128         (0172) ;------------------------
191B: 56 68 00 MOV   [X+104],0     (0173) 
191E: 70 3F    AND   F,63
1920: 71 00    OR    F,0           (0174) 
1922: 80 12    JMP   0x1935        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1924: 75       INC   X             (0179) 
1925: 5A 0F    MOV   [15],X        (0180) 
1927: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1928: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
192B: 70 3F    AND   F,63
192D: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_1_ISR
192F: 54 68    MOV   [X+104],A     (0185) ;
1931: 70 3F    AND   F,63
1933: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1935: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1936: 60 D3    MOV   REG[211],A    (0191) _HELLO_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1938: 20       POP   X             (0195)    ; Insert your custom code below this banner
1939: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
193B: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_1.asm
                                   (0121) ;;*****************************************************************************
193E: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_1.inc"
193F: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1942: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_1_EnableInt
                                   (0155) export  _HELLO_1_EnableInt
                                   (0156) export   HELLO_1_DisableInt
                                   (0157) export  _HELLO_1_DisableInt
                                   (0158) export   HELLO_1_Start
                                   (0159) export  _HELLO_1_Start
                                   (0160) export   HELLO_1_Stop
                                   (0161) export  _HELLO_1_Stop
                                   (0162) export   HELLO_1_bReadRxData
                                   (0163) export  _HELLO_1_bReadRxData
                                   (0164) export   HELLO_1_bReadRxStatus
                                   (0165) export  _HELLO_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_1_ReadRxData
                                   (0170) export _bHELLO_1_ReadRxData
                                   (0171) export  bHELLO_1_ReadRxStatus
                                   (0172) export _bHELLO_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_1_cGetChar
1943: 29 01    OR    A,1           (0179) export _HELLO_1_cGetChar
1945: 60 2B    MOV   REG[43],A     (0180) export  HELLO_1_cReadChar
                                   (0181) export _HELLO_1_cReadChar
1947: 7F       RET                 (0182) export  HELLO_1_iReadChar
                                   (0183) export _HELLO_1_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_1_RXBUF_ENABLE)
                                   (0186) export  HELLO_1_CmdReset
                                   (0187) export _HELLO_1_CmdReset
                                   (0188) export  HELLO_1_bCmdCheck
                                   (0189) export _HELLO_1_bCmdCheck
                                   (0190) export  HELLO_1_bCmdLength
                                   (0191) export _HELLO_1_bCmdLength
                                   (0192) export  HELLO_1_bErrCheck
                                   (0193) export _HELLO_1_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_1_szGetParam
                                   (0196) export _HELLO_1_szGetParam
                                   (0197) export  HELLO_1_szGetRestOfParams
                                   (0198) export _HELLO_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1948: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
194B: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_1_EnableInt:
                                   (0238) _HELLO_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
194C: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
194E: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_1_DisableInt:
                                   (0267) _HELLO_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
194F: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1951: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_1_Start:
                                   (0297) _HELLO_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1952: 49 2B 08 TST   REG[43],8     (0311) ;
1955: AF FC    JZ    0x1952        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1957: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1959: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_1_Stop:
                                   (0326) _HELLO_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
195A: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
195C: 08       PUSH  A             (0347) ;
195D: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
195F: B0 04    JNZ   0x1964        (0349) ;    The A and X registers may be modified by this or future implementations
1961: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1962: 80 0B    JMP   0x196E        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1964: 5D 2A    MOV   A,REG[42]     (0354) ;
1966: 4B       SWAP  A,X           (0355)  HELLO_1_bReadRxData:
                                   (0356) _HELLO_1_bReadRxData:
1967: 18       POP   A             (0357)  bHELLO_1_ReadRxData:
1968: 21 A0    AND   A,160         (0358) _bHELLO_1_ReadRxData:
196A: B0 03    JNZ   0x196E        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
196C: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
196D: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
196E: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_1_bReadRxStatus
                                   (0368) ;
1970: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_1_bReadRxStatus:
                                   (0388) _HELLO_1_bReadRxStatus:
                                   (0389)  bHELLO_1_ReadRxStatus:
                                   (0390) _bHELLO_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1971: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1973: 21 E8    AND   A,232         (0408) ;
1975: 08       PUSH  A             (0409) ;  ARGUMENTS:
1976: 21 08    AND   A,8           (0410) ;      none
1978: B0 07    JNZ   0x1980        (0411) ;
197A: 18       POP   A             (0412) ;  RETURNS:
197B: 29 01    OR    A,1           (0413) ;     char that is returned from UART
197D: 4B       SWAP  A,X           (0414) ;
197E: 80 07    JMP   0x1986        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1980: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1981: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1983: 4B       SWAP  A,X           (0420) ;    functions.
1984: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1986: 7F       RET                 (0426)  HELLO_1_cGetChar:
                                   (0427) _HELLO_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_1_CONTROL_REG],HELLO_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_1_cReadChar:
                                   (0463) _HELLO_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
1987: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
198A: 55 68 00 MOV   [104],0       (0470)    pop  A
198D: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1990: 55 D7 00 MOV   [215],0       (0472) 
1993: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1996: 55 0F 00 MOV   [15],0        (0474)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
1999: 26 0E 00 AND   [14],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
199C: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_1_RX_PARITY_ERROR | HELLO_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
199D: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
19A0: 51 0E    MOV   A,[14]        (0511) ;        0x40CC    Overrun Error
19A2: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
19A4: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_1_iReadChar:
                                   (0523) _HELLO_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_1_RX_ERROR|HELLO_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_1_RXBUF_ENABLE)
                                   (0552) .SECTION
19A5: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
19A8: 51 0E    MOV   A,[14]        (0554) ;-----------------------------------------------------------------------------
19AA: 21 F0    AND   A,240         (0555) ;
19AC: 26 0E 0F AND   [14],15       (0556) ;     Command Buffer commands
                                   (0557) ;
19AF: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_1_CmdReset:
19B0: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_1_CmdReset:
19B3: 51 0F    MOV   A,[15]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_1_aRxBuffer
19B5: 7F       RET                 (0590)    mov [HELLO_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
                                   (0594)    mov [HELLO_1_bRxCnt], 0x00
                                   (0595)    and [HELLO_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_1_bCmdCheck:
                                   (0628) _HELLO_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0631)    mov A,  [HELLO_1_fStatus]
                                   (0632)    and A, HELLO_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
19B6: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
19B8: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
19BB: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
19BE: 50 68    MOV   A,104         (0648) ;     BYTE  fStatus - Status of command receive buffer.
19C0: 02 D7    ADD   A,[215]       (0649) ;                     Returns non-zero value in A if command is valid.
19C2: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
19C3: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
19C5: B0 04    JNZ   0x19CA        (0653) ;           0x10 => Software Buffer OverRun
19C7: 10       PUSH  X             (0654) ;
19C8: 80 33    JMP   0x19FC        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
19CA: 39 00    CMP   A,0           (0660) ;    functions.
19CC: B0 11    JNZ   0x19DE        (0661) ;          
19CE: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
19CF: 76 D7    INC   [215]         (0663) ;          CUR_PP
19D1: 52 00    MOV   A,[X+0]       (0664) ;
19D3: 3C D7 0F CMP   [215],15      (0665) ;     Error Status is clear when read.
19D6: BF F3    JNZ   0x19CA        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
19D8: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_1_bErrCheck:
19D9: 56 00 00 MOV   [X+0],0       (0671) _HELLO_1_bErrCheck:
19DC: 80 1F    JMP   0x19FC        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0674)    mov A,  [HELLO_1_fStatus]
19DE: 10       PUSH  X             (0675)    and A, HELLO_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_1_fStatus], ~HELLO_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
19DF: 75       INC   X             (0679) .ENDSECTION
19E0: 76 D7    INC   [215]         (0680) 
19E2: 3C D7 0F CMP   [215],15      (0681) .SECTION
19E5: AF F3    JZ    0x19D9        (0682) ;-----------------------------------------------------------------------------
19E7: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_1_bCmdLength
19E9: A0 12    JZ    0x19FC        (0684) ;
19EB: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
19ED: BF F1    JNZ   0x19DF        (0686) ;     Get length of command string
                                   (0687) ;
19EF: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
19F2: 76 D7    INC   [215]         (0689) ;     none.
19F4: 3C D7 0F CMP   [215],15      (0690) ;
19F7: B0 04    JNZ   0x19FC        (0691) ;  RETURNS:
19F9: 55 D7 0F MOV   [215],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
19FC: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
19FD: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
19FE: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1A01: B0 0B    JNZ   0x1A0D        (0699) ;    functions.
1A03: 20       POP   X             (0700) ;          
1A04: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1A06: 50 00    MOV   A,0           (0702) ;          CUR_PP
1A08: 70 3F    AND   F,63
1A0A: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_1_bCmdLength:
1A0C: 7F       RET                 (0705) _HELLO_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
1A0D: 20       POP   X             (0708)    mov A,  [HELLO_1_bRxCnt]
1A0E: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1A10: 70 3F    AND   F,63
1A12: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1A14: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1A15: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1A18: 50 68    MOV   A,104         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1A1A: 02 D7    ADD   A,[215]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1A1C: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1A1D: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_1_szGetParam, is
1A20: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_4int.asm
1A21: 10       PUSH  X             (0104) ;;*****************************************************************************
1A22: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_4INT.asm
1A24: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1A25: 58 11    MOV   X,[17]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1A27: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1A29: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1A2A: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1A2C: B0 04    JNZ   0x1A31        (0115) 
1A2E: 18       POP   A             (0116) include "m8c.inc"
1A2F: 80 5E    JMP   0x1A8E        (0117) include "memory.inc"
                                   (0118) include "CHILD_4.inc"
                                   (0119) 
                                   (0120) 
1A31: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1A32: 21 E0    AND   A,224         (0124) export  _CHILD_4_ISR
1A34: A0 12    JZ    0x1A47        (0125) 
                                   (0126) 
1A36: 2C 10    OR    [16],A        (0127) IF (CHILD_4_RXBUF_ENABLE)
                                   (0128) export  CHILD_4_aRxBuffer
1A38: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_4_aRxBuffer
                                   (0130) export  CHILD_4_bRxCnt
1A3B: 21 20    AND   A,32          (0131) export _CHILD_4_bRxCnt
1A3D: A0 50    JZ    0x1A8E        (0132) export  CHILD_4_fStatus
                                   (0133) export _CHILD_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
1A3F: 41 2B FE AND   REG[43],254   (0136) 
1A42: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1A45: 80 48    JMP   0x1A8E        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_4_RXBUF_ENABLE)
1A47: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_4_fStatus:
                                   (0144) _CHILD_4_fStatus:      BLK  1
1A49: 47 10 01 TST   [16],1        (0145)  CHILD_4_bRxCnt:
1A4C: B0 41    JNZ   0x1A8E        (0146) _CHILD_4_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_4_RAM(RAM,REL,CON)
1A4E: 39 00    CMP   A,0           (0148)  CHILD_4_aRxBuffer:    
1A50: B0 14    JNZ   0x1A65        (0149) _CHILD_4_aRxBuffer:    BLK CHILD_4_RX_BUFFER_SIZE
1A52: 2E 10 01 OR    [16],1        (0150) ENDIF
                                   (0151) 
1A55: 62 D3 00 MOV   REG[211],0    (0152) 
1A58: 70 3F    AND   F,63
1A5A: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1A5C: 56 98 00 MOV   [X-104],0     (0154) 
1A5F: 70 3F    AND   F,63
1A61: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1A63: 80 2A    JMP   0x1A8E        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1A65: 3C 11 0F CMP   [17],15       (0167) ;------------------------
1A68: C0 14    JC    0x1A7D        (0168) 
1A6A: 2E 10 10 OR    [16],16       (0169) 
                                   (0170) ;------------------------
1A6D: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1A70: 70 3F    AND   F,63
1A72: 71 80    OR    F,128         (0172) ;------------------------
1A74: 56 98 00 MOV   [X-104],0     (0173) 
1A77: 70 3F    AND   F,63
1A79: 71 00    OR    F,0           (0174) 
1A7B: 80 12    JMP   0x1A8E        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1A7D: 75       INC   X             (0179) 
1A7E: 5A 11    MOV   [17],X        (0180) 
1A80: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1A81: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1A84: 70 3F    AND   F,63
1A86: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_4_ISR
1A88: 54 98    MOV   [X-104],A     (0185) ;
1A8A: 70 3F    AND   F,63
1A8C: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1A8E: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1A8F: 60 D3    MOV   REG[211],A    (0191) _CHILD_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1A91: 20       POP   X             (0195)    ; Insert your custom code below this banner
1A92: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1A94: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_4_timeout.asm
                                   (0102) ;;*****************************************************************************
1A97: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_4_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_4_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1A98: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1A9B: 7F       RET                 (0131) export  CHILD_4_TIMEOUT_EnableInt
                                   (0132) export _CHILD_4_TIMEOUT_EnableInt
                                   (0133) export  CHILD_4_TIMEOUT_DisableInt
                                   (0134) export _CHILD_4_TIMEOUT_DisableInt
                                   (0135) export  CHILD_4_TIMEOUT_Start
                                   (0136) export _CHILD_4_TIMEOUT_Start
                                   (0137) export  CHILD_4_TIMEOUT_Stop
                                   (0138) export _CHILD_4_TIMEOUT_Stop
                                   (0139) export  CHILD_4_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_4_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_4_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_4_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_4_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_4_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_4_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_4_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
1A9C: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1A9F: 7F       RET                 (0159) export  wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response4_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_4_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1AA0: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1AA3: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_4_TIMEOUT_EnableInt:
                                   (0200) _CHILD_4_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_4_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_4_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1AA4: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1AA6: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1AA7: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1AA9: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_4_TIMEOUT_DisableInt:
                                   (0228) _CHILD_4_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_4_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1AAA: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1AAC: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1AAD: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1AAF: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_4_TIMEOUT_Start:
                                   (0256) _CHILD_4_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_4_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1AB0: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1AB2: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1AB3: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1AB5: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_4_TIMEOUT_Stop:
                                   (0284) _CHILD_4_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_4_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_4_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_4_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_4_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_4_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_4_TIMEOUT_Stop to disable).
1AB6: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1AB7: 38 03    ADD   SP,3          (0334) ;
1AB9: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1ABB: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1ABC: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1ABE: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1ABF: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1AC1: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1AC2: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1AC4: 5D 26    MOV   A,REG[38]     (0343) ;
1AC6: 54 01    MOV   [X+1],A       (0344)  CHILD_4_TIMEOUT_WriteCompareValue:
1AC8: 5D 22    MOV   A,REG[34]     (0345) _CHILD_4_TIMEOUT_WriteCompareValue:
1ACA: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1ACC: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG], A
1ACE: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1AD1: A0 03    JZ    0x1AD5        (0349)    mov   reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG], A
1AD3: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1AD5: 54 00    MOV   [X+0],A       (0352) 
1AD7: 70 FE    AND   F,254         (0353) .ENDSECTION
1AD9: 41 23 FE AND   REG[35],254   (0354) 
1ADC: 18       POP   A             (0355) 
1ADD: 60 26    MOV   REG[38],A     (0356) .SECTION
1ADF: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1AE0: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadCompareValue
1AE2: 18       POP   A             (0359) ;
1AE3: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1AE5: 18       POP   A             (0361) ;     Reads the Compare registers.
1AE6: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1AE7: 70 3F    AND   F,63
1AE9: 71 C0    OR    F,192         (0363) ;
1AEB: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1AEC: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1AEE: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1AF0: 5C       MOV   X,A           (0409) ;
1AF1: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1AF4: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_4.asm
                                   (0121) ;;*****************************************************************************
1AF7: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_4.inc"
1AF8: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1AFB: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_4_EnableInt
                                   (0155) export  _CHILD_4_EnableInt
                                   (0156) export   CHILD_4_DisableInt
                                   (0157) export  _CHILD_4_DisableInt
                                   (0158) export   CHILD_4_Start
                                   (0159) export  _CHILD_4_Start
                                   (0160) export   CHILD_4_Stop
                                   (0161) export  _CHILD_4_Stop
                                   (0162) export   CHILD_4_bReadRxData
                                   (0163) export  _CHILD_4_bReadRxData
                                   (0164) export   CHILD_4_bReadRxStatus
                                   (0165) export  _CHILD_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_4_ReadRxData
                                   (0170) export _bCHILD_4_ReadRxData
                                   (0171) export  bCHILD_4_ReadRxStatus
                                   (0172) export _bCHILD_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_4_cGetChar
1AFC: 29 01    OR    A,1           (0179) export _CHILD_4_cGetChar
1AFE: 60 2B    MOV   REG[43],A     (0180) export  CHILD_4_cReadChar
                                   (0181) export _CHILD_4_cReadChar
1B00: 7F       RET                 (0182) export  CHILD_4_iReadChar
                                   (0183) export _CHILD_4_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_4_RXBUF_ENABLE)
                                   (0186) export  CHILD_4_CmdReset
                                   (0187) export _CHILD_4_CmdReset
                                   (0188) export  CHILD_4_bCmdCheck
                                   (0189) export _CHILD_4_bCmdCheck
                                   (0190) export  CHILD_4_bCmdLength
                                   (0191) export _CHILD_4_bCmdLength
                                   (0192) export  CHILD_4_bErrCheck
                                   (0193) export _CHILD_4_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_4_szGetParam
                                   (0196) export _CHILD_4_szGetParam
                                   (0197) export  CHILD_4_szGetRestOfParams
                                   (0198) export _CHILD_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1B01: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1B04: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_4_EnableInt:
                                   (0238) _CHILD_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1B05: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1B07: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_4_DisableInt:
                                   (0267) _CHILD_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1B08: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1B0A: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_4_Start:
                                   (0297) _CHILD_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1B0B: 49 2B 08 TST   REG[43],8     (0311) ;
1B0E: AF FC    JZ    0x1B0B        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1B10: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1B12: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_4_Stop:
                                   (0326) _CHILD_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1B13: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1B15: 08       PUSH  A             (0347) ;
1B16: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1B18: B0 04    JNZ   0x1B1D        (0349) ;    The A and X registers may be modified by this or future implementations
1B1A: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1B1B: 80 0B    JMP   0x1B27        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1B1D: 5D 2A    MOV   A,REG[42]     (0354) ;
1B1F: 4B       SWAP  A,X           (0355)  CHILD_4_bReadRxData:
                                   (0356) _CHILD_4_bReadRxData:
1B20: 18       POP   A             (0357)  bCHILD_4_ReadRxData:
1B21: 21 A0    AND   A,160         (0358) _bCHILD_4_ReadRxData:
1B23: B0 03    JNZ   0x1B27        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1B25: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1B26: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1B27: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_4_bReadRxStatus
                                   (0368) ;
1B29: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_4_bReadRxStatus:
                                   (0388) _CHILD_4_bReadRxStatus:
                                   (0389)  bCHILD_4_ReadRxStatus:
                                   (0390) _bCHILD_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1B2A: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1B2C: 21 E8    AND   A,232         (0408) ;
1B2E: 08       PUSH  A             (0409) ;  ARGUMENTS:
1B2F: 21 08    AND   A,8           (0410) ;      none
1B31: B0 07    JNZ   0x1B39        (0411) ;
1B33: 18       POP   A             (0412) ;  RETURNS:
1B34: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1B36: 4B       SWAP  A,X           (0414) ;
1B37: 80 07    JMP   0x1B3F        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1B39: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1B3A: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1B3C: 4B       SWAP  A,X           (0420) ;    functions.
1B3D: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1B3F: 7F       RET                 (0426)  CHILD_4_cGetChar:
                                   (0427) _CHILD_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_4_CONTROL_REG],CHILD_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_4_cReadChar:
                                   (0463) _CHILD_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
1B40: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1B43: 55 98 00 MOV   [152],0       (0470)    pop  A
1B46: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1B49: 55 D6 00 MOV   [214],0       (0472) 
1B4C: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1B4F: 55 11 00 MOV   [17],0        (0474)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
1B52: 26 10 00 AND   [16],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1B55: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_4_RX_PARITY_ERROR | CHILD_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1B56: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1B59: 51 10    MOV   A,[16]        (0511) ;        0x40CC    Overrun Error
1B5B: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1B5D: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_4_iReadChar:
                                   (0523) _CHILD_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_4_RX_ERROR|CHILD_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_4_RXBUF_ENABLE)
                                   (0552) .SECTION
1B5E: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1B61: 51 10    MOV   A,[16]        (0554) ;-----------------------------------------------------------------------------
1B63: 21 F0    AND   A,240         (0555) ;
1B65: 26 10 0F AND   [16],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1B68: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_4_CmdReset:
1B69: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_4_CmdReset:
1B6C: 51 11    MOV   A,[17]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_4_aRxBuffer
1B6E: 7F       RET                 (0590)    mov [CHILD_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
                                   (0594)    mov [CHILD_4_bRxCnt], 0x00
                                   (0595)    and [CHILD_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_4_bCmdCheck:
                                   (0628) _CHILD_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0631)    mov A,  [CHILD_4_fStatus]
                                   (0632)    and A, CHILD_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1B6F: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1B71: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1B74: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1B77: 50 98    MOV   A,152         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1B79: 02 D6    ADD   A,[214]       (0649) ;                     Returns non-zero value in A if command is valid.
1B7B: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1B7C: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1B7E: B0 04    JNZ   0x1B83        (0653) ;           0x10 => Software Buffer OverRun
1B80: 10       PUSH  X             (0654) ;
1B81: 80 33    JMP   0x1BB5        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1B83: 39 00    CMP   A,0           (0660) ;    functions.
1B85: B0 11    JNZ   0x1B97        (0661) ;          
1B87: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1B88: 76 D6    INC   [214]         (0663) ;          CUR_PP
1B8A: 52 00    MOV   A,[X+0]       (0664) ;
1B8C: 3C D6 0F CMP   [214],15      (0665) ;     Error Status is clear when read.
1B8F: BF F3    JNZ   0x1B83        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1B91: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_4_bErrCheck:
1B92: 56 00 00 MOV   [X+0],0       (0671) _CHILD_4_bErrCheck:
1B95: 80 1F    JMP   0x1BB5        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0674)    mov A,  [CHILD_4_fStatus]
1B97: 10       PUSH  X             (0675)    and A, CHILD_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_4_fStatus], ~CHILD_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1B98: 75       INC   X             (0679) .ENDSECTION
1B99: 76 D6    INC   [214]         (0680) 
1B9B: 3C D6 0F CMP   [214],15      (0681) .SECTION
1B9E: AF F3    JZ    0x1B92        (0682) ;-----------------------------------------------------------------------------
1BA0: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_4_bCmdLength
1BA2: A0 12    JZ    0x1BB5        (0684) ;
1BA4: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1BA6: BF F1    JNZ   0x1B98        (0686) ;     Get length of command string
                                   (0687) ;
1BA8: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1BAB: 76 D6    INC   [214]         (0689) ;     none.
1BAD: 3C D6 0F CMP   [214],15      (0690) ;
1BB0: B0 04    JNZ   0x1BB5        (0691) ;  RETURNS:
1BB2: 55 D6 0F MOV   [214],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1BB5: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1BB6: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1BB7: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1BBA: B0 0B    JNZ   0x1BC6        (0699) ;    functions.
1BBC: 20       POP   X             (0700) ;          
1BBD: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1BBF: 50 00    MOV   A,0           (0702) ;          CUR_PP
1BC1: 70 3F    AND   F,63
1BC3: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_4_bCmdLength:
1BC5: 7F       RET                 (0705) _CHILD_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
1BC6: 20       POP   X             (0708)    mov A,  [CHILD_4_bRxCnt]
1BC7: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1BC9: 70 3F    AND   F,63
1BCB: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1BCD: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1BCE: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1BD1: 50 98    MOV   A,152         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1BD3: 02 D6    ADD   A,[214]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1BD5: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1BD6: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_4_szGetParam, is
1BD9: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_3int.asm
1BDA: 10       PUSH  X             (0104) ;;*****************************************************************************
1BDB: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_3INT.asm
1BDD: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1BDE: 58 13    MOV   X,[19]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1BE0: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1BE2: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1BE3: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1BE5: B0 04    JNZ   0x1BEA        (0115) 
1BE7: 18       POP   A             (0116) include "m8c.inc"
1BE8: 80 5E    JMP   0x1C47        (0117) include "memory.inc"
                                   (0118) include "CHILD_3.inc"
                                   (0119) 
                                   (0120) 
1BEA: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1BEB: 21 E0    AND   A,224         (0124) export  _CHILD_3_ISR
1BED: A0 12    JZ    0x1C00        (0125) 
                                   (0126) 
1BEF: 2C 12    OR    [18],A        (0127) IF (CHILD_3_RXBUF_ENABLE)
                                   (0128) export  CHILD_3_aRxBuffer
1BF1: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_3_aRxBuffer
                                   (0130) export  CHILD_3_bRxCnt
1BF4: 21 20    AND   A,32          (0131) export _CHILD_3_bRxCnt
1BF6: A0 50    JZ    0x1C47        (0132) export  CHILD_3_fStatus
                                   (0133) export _CHILD_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1BF8: 41 2B FE AND   REG[43],254   (0136) 
1BFB: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1BFE: 80 48    JMP   0x1C47        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_3_RXBUF_ENABLE)
1C00: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_3_fStatus:
                                   (0144) _CHILD_3_fStatus:      BLK  1
1C02: 47 12 01 TST   [18],1        (0145)  CHILD_3_bRxCnt:
1C05: B0 41    JNZ   0x1C47        (0146) _CHILD_3_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_3_RAM(RAM,REL,CON)
1C07: 39 00    CMP   A,0           (0148)  CHILD_3_aRxBuffer:    
1C09: B0 14    JNZ   0x1C1E        (0149) _CHILD_3_aRxBuffer:    BLK CHILD_3_RX_BUFFER_SIZE
1C0B: 2E 12 01 OR    [18],1        (0150) ENDIF
                                   (0151) 
1C0E: 62 D3 00 MOV   REG[211],0    (0152) 
1C11: 70 3F    AND   F,63
1C13: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1C15: 56 48 00 MOV   [X+72],0      (0154) 
1C18: 70 3F    AND   F,63
1C1A: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1C1C: 80 2A    JMP   0x1C47        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1C1E: 3C 13 0F CMP   [19],15       (0167) ;------------------------
1C21: C0 14    JC    0x1C36        (0168) 
1C23: 2E 12 10 OR    [18],16       (0169) 
                                   (0170) ;------------------------
1C26: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1C29: 70 3F    AND   F,63
1C2B: 71 80    OR    F,128         (0172) ;------------------------
1C2D: 56 48 00 MOV   [X+72],0      (0173) 
1C30: 70 3F    AND   F,63
1C32: 71 00    OR    F,0           (0174) 
1C34: 80 12    JMP   0x1C47        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1C36: 75       INC   X             (0179) 
1C37: 5A 13    MOV   [19],X        (0180) 
1C39: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1C3A: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1C3D: 70 3F    AND   F,63
1C3F: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_3_ISR
1C41: 54 48    MOV   [X+72],A      (0185) ;
1C43: 70 3F    AND   F,63
1C45: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1C47: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1C48: 60 D3    MOV   REG[211],A    (0191) _CHILD_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1C4A: 20       POP   X             (0195)    ; Insert your custom code below this banner
1C4B: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1C4D: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_3_timeout.asm
                                   (0102) ;;*****************************************************************************
1C50: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_3_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_3_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1C51: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1C54: 7F       RET                 (0131) export  CHILD_3_TIMEOUT_EnableInt
                                   (0132) export _CHILD_3_TIMEOUT_EnableInt
                                   (0133) export  CHILD_3_TIMEOUT_DisableInt
                                   (0134) export _CHILD_3_TIMEOUT_DisableInt
                                   (0135) export  CHILD_3_TIMEOUT_Start
                                   (0136) export _CHILD_3_TIMEOUT_Start
                                   (0137) export  CHILD_3_TIMEOUT_Stop
                                   (0138) export _CHILD_3_TIMEOUT_Stop
                                   (0139) export  CHILD_3_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_3_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_3_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_3_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_3_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_3_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_3_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_3_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
1C55: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1C58: 7F       RET                 (0159) export  wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response3_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_3_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1C59: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1C5C: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_3_TIMEOUT_EnableInt:
                                   (0200) _CHILD_3_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_3_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_3_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1C5D: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1C5F: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1C60: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1C62: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_3_TIMEOUT_DisableInt:
                                   (0228) _CHILD_3_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_3_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1C63: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1C65: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1C66: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1C68: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_3_TIMEOUT_Start:
                                   (0256) _CHILD_3_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_3_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1C69: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1C6B: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1C6C: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1C6E: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_3_TIMEOUT_Stop:
                                   (0284) _CHILD_3_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_3_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_3_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_3_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_3_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_3_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_3_TIMEOUT_Stop to disable).
1C6F: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1C70: 38 03    ADD   SP,3          (0334) ;
1C72: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1C74: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1C75: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1C77: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1C78: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1C7A: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1C7B: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1C7D: 5D 26    MOV   A,REG[38]     (0343) ;
1C7F: 54 01    MOV   [X+1],A       (0344)  CHILD_3_TIMEOUT_WriteCompareValue:
1C81: 5D 22    MOV   A,REG[34]     (0345) _CHILD_3_TIMEOUT_WriteCompareValue:
1C83: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1C85: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG], A
1C87: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1C8A: A0 03    JZ    0x1C8E        (0349)    mov   reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG], A
1C8C: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1C8E: 54 00    MOV   [X+0],A       (0352) 
1C90: 70 FE    AND   F,254         (0353) .ENDSECTION
1C92: 41 23 FE AND   REG[35],254   (0354) 
1C95: 18       POP   A             (0355) 
1C96: 60 26    MOV   REG[38],A     (0356) .SECTION
1C98: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1C99: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadCompareValue
1C9B: 18       POP   A             (0359) ;
1C9C: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1C9E: 18       POP   A             (0361) ;     Reads the Compare registers.
1C9F: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1CA0: 70 3F    AND   F,63
1CA2: 71 C0    OR    F,192         (0363) ;
1CA4: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1CA5: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1CA7: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1CA9: 5C       MOV   X,A           (0409) ;
1CAA: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1CAD: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_3.asm
                                   (0121) ;;*****************************************************************************
1CB0: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_3.inc"
1CB1: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1CB4: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_3_EnableInt
                                   (0155) export  _CHILD_3_EnableInt
                                   (0156) export   CHILD_3_DisableInt
                                   (0157) export  _CHILD_3_DisableInt
                                   (0158) export   CHILD_3_Start
                                   (0159) export  _CHILD_3_Start
                                   (0160) export   CHILD_3_Stop
                                   (0161) export  _CHILD_3_Stop
                                   (0162) export   CHILD_3_bReadRxData
                                   (0163) export  _CHILD_3_bReadRxData
                                   (0164) export   CHILD_3_bReadRxStatus
                                   (0165) export  _CHILD_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_3_ReadRxData
                                   (0170) export _bCHILD_3_ReadRxData
                                   (0171) export  bCHILD_3_ReadRxStatus
                                   (0172) export _bCHILD_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_3_cGetChar
1CB5: 29 01    OR    A,1           (0179) export _CHILD_3_cGetChar
1CB7: 60 2B    MOV   REG[43],A     (0180) export  CHILD_3_cReadChar
                                   (0181) export _CHILD_3_cReadChar
1CB9: 7F       RET                 (0182) export  CHILD_3_iReadChar
                                   (0183) export _CHILD_3_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_3_RXBUF_ENABLE)
                                   (0186) export  CHILD_3_CmdReset
                                   (0187) export _CHILD_3_CmdReset
                                   (0188) export  CHILD_3_bCmdCheck
                                   (0189) export _CHILD_3_bCmdCheck
                                   (0190) export  CHILD_3_bCmdLength
                                   (0191) export _CHILD_3_bCmdLength
                                   (0192) export  CHILD_3_bErrCheck
                                   (0193) export _CHILD_3_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_3_szGetParam
                                   (0196) export _CHILD_3_szGetParam
                                   (0197) export  CHILD_3_szGetRestOfParams
                                   (0198) export _CHILD_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1CBA: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1CBD: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_3_EnableInt:
                                   (0238) _CHILD_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1CBE: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1CC0: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_3_DisableInt:
                                   (0267) _CHILD_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1CC1: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1CC3: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_3_Start:
                                   (0297) _CHILD_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1CC4: 49 2B 08 TST   REG[43],8     (0311) ;
1CC7: AF FC    JZ    0x1CC4        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1CC9: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1CCB: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_3_Stop:
                                   (0326) _CHILD_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1CCC: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1CCE: 08       PUSH  A             (0347) ;
1CCF: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1CD1: B0 04    JNZ   0x1CD6        (0349) ;    The A and X registers may be modified by this or future implementations
1CD3: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1CD4: 80 0B    JMP   0x1CE0        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1CD6: 5D 2A    MOV   A,REG[42]     (0354) ;
1CD8: 4B       SWAP  A,X           (0355)  CHILD_3_bReadRxData:
                                   (0356) _CHILD_3_bReadRxData:
1CD9: 18       POP   A             (0357)  bCHILD_3_ReadRxData:
1CDA: 21 A0    AND   A,160         (0358) _bCHILD_3_ReadRxData:
1CDC: B0 03    JNZ   0x1CE0        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1CDE: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1CDF: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1CE0: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_3_bReadRxStatus
                                   (0368) ;
1CE2: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_3_bReadRxStatus:
                                   (0388) _CHILD_3_bReadRxStatus:
                                   (0389)  bCHILD_3_ReadRxStatus:
                                   (0390) _bCHILD_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1CE3: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1CE5: 21 E8    AND   A,232         (0408) ;
1CE7: 08       PUSH  A             (0409) ;  ARGUMENTS:
1CE8: 21 08    AND   A,8           (0410) ;      none
1CEA: B0 07    JNZ   0x1CF2        (0411) ;
1CEC: 18       POP   A             (0412) ;  RETURNS:
1CED: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1CEF: 4B       SWAP  A,X           (0414) ;
1CF0: 80 07    JMP   0x1CF8        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1CF2: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1CF3: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1CF5: 4B       SWAP  A,X           (0420) ;    functions.
1CF6: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1CF8: 7F       RET                 (0426)  CHILD_3_cGetChar:
                                   (0427) _CHILD_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_3_CONTROL_REG],CHILD_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_3_cReadChar:
                                   (0463) _CHILD_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
1CF9: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1CFC: 55 48 00 MOV   [72],0        (0470)    pop  A
1CFF: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1D02: 55 D5 00 MOV   [213],0       (0472) 
1D05: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1D08: 55 13 00 MOV   [19],0        (0474)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
1D0B: 26 12 00 AND   [18],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1D0E: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_3_RX_PARITY_ERROR | CHILD_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1D0F: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1D12: 51 12    MOV   A,[18]        (0511) ;        0x40CC    Overrun Error
1D14: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1D16: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_3_iReadChar:
                                   (0523) _CHILD_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_3_RX_ERROR|CHILD_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_3_RXBUF_ENABLE)
                                   (0552) .SECTION
1D17: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1D1A: 51 12    MOV   A,[18]        (0554) ;-----------------------------------------------------------------------------
1D1C: 21 F0    AND   A,240         (0555) ;
1D1E: 26 12 0F AND   [18],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1D21: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_3_CmdReset:
1D22: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_3_CmdReset:
1D25: 51 13    MOV   A,[19]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_3_aRxBuffer
1D27: 7F       RET                 (0590)    mov [CHILD_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
                                   (0594)    mov [CHILD_3_bRxCnt], 0x00
                                   (0595)    and [CHILD_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_3_bCmdCheck:
                                   (0628) _CHILD_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0631)    mov A,  [CHILD_3_fStatus]
                                   (0632)    and A, CHILD_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1D28: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1D2A: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1D2D: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1D30: 50 48    MOV   A,72          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1D32: 02 D5    ADD   A,[213]       (0649) ;                     Returns non-zero value in A if command is valid.
1D34: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1D35: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1D37: B0 04    JNZ   0x1D3C        (0653) ;           0x10 => Software Buffer OverRun
1D39: 10       PUSH  X             (0654) ;
1D3A: 80 33    JMP   0x1D6E        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1D3C: 39 00    CMP   A,0           (0660) ;    functions.
1D3E: B0 11    JNZ   0x1D50        (0661) ;          
1D40: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1D41: 76 D5    INC   [213]         (0663) ;          CUR_PP
1D43: 52 00    MOV   A,[X+0]       (0664) ;
1D45: 3C D5 0F CMP   [213],15      (0665) ;     Error Status is clear when read.
1D48: BF F3    JNZ   0x1D3C        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1D4A: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_3_bErrCheck:
1D4B: 56 00 00 MOV   [X+0],0       (0671) _CHILD_3_bErrCheck:
1D4E: 80 1F    JMP   0x1D6E        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0674)    mov A,  [CHILD_3_fStatus]
1D50: 10       PUSH  X             (0675)    and A, CHILD_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_3_fStatus], ~CHILD_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1D51: 75       INC   X             (0679) .ENDSECTION
1D52: 76 D5    INC   [213]         (0680) 
1D54: 3C D5 0F CMP   [213],15      (0681) .SECTION
1D57: AF F3    JZ    0x1D4B        (0682) ;-----------------------------------------------------------------------------
1D59: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_3_bCmdLength
1D5B: A0 12    JZ    0x1D6E        (0684) ;
1D5D: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1D5F: BF F1    JNZ   0x1D51        (0686) ;     Get length of command string
                                   (0687) ;
1D61: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1D64: 76 D5    INC   [213]         (0689) ;     none.
1D66: 3C D5 0F CMP   [213],15      (0690) ;
1D69: B0 04    JNZ   0x1D6E        (0691) ;  RETURNS:
1D6B: 55 D5 0F MOV   [213],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1D6E: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1D6F: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1D70: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1D73: B0 0B    JNZ   0x1D7F        (0699) ;    functions.
1D75: 20       POP   X             (0700) ;          
1D76: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1D78: 50 00    MOV   A,0           (0702) ;          CUR_PP
1D7A: 70 3F    AND   F,63
1D7C: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_3_bCmdLength:
1D7E: 7F       RET                 (0705) _CHILD_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
1D7F: 20       POP   X             (0708)    mov A,  [CHILD_3_bRxCnt]
1D80: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1D82: 70 3F    AND   F,63
1D84: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1D86: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1D87: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1D8A: 50 48    MOV   A,72          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1D8C: 02 D5    ADD   A,[213]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1D8E: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1D8F: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_3_szGetParam, is
1D92: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_2int.asm
1D93: 10       PUSH  X             (0104) ;;*****************************************************************************
1D94: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_2INT.asm
1D96: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1D97: 58 15    MOV   X,[21]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1D99: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1D9B: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1D9C: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1D9E: B0 04    JNZ   0x1DA3        (0115) 
1DA0: 18       POP   A             (0116) include "m8c.inc"
1DA1: 80 5E    JMP   0x1E00        (0117) include "memory.inc"
                                   (0118) include "CHILD_2.inc"
                                   (0119) 
                                   (0120) 
1DA3: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1DA4: 21 E0    AND   A,224         (0124) export  _CHILD_2_ISR
1DA6: A0 12    JZ    0x1DB9        (0125) 
                                   (0126) 
1DA8: 2C 14    OR    [20],A        (0127) IF (CHILD_2_RXBUF_ENABLE)
                                   (0128) export  CHILD_2_aRxBuffer
1DAA: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_2_aRxBuffer
                                   (0130) export  CHILD_2_bRxCnt
1DAD: 21 20    AND   A,32          (0131) export _CHILD_2_bRxCnt
1DAF: A0 50    JZ    0x1E00        (0132) export  CHILD_2_fStatus
                                   (0133) export _CHILD_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
1DB1: 41 2B FE AND   REG[43],254   (0136) 
1DB4: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1DB7: 80 48    JMP   0x1E00        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_2_RXBUF_ENABLE)
1DB9: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_2_fStatus:
                                   (0144) _CHILD_2_fStatus:      BLK  1
1DBB: 47 14 01 TST   [20],1        (0145)  CHILD_2_bRxCnt:
1DBE: B0 41    JNZ   0x1E00        (0146) _CHILD_2_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_2_RAM(RAM,REL,CON)
1DC0: 39 00    CMP   A,0           (0148)  CHILD_2_aRxBuffer:    
1DC2: B0 14    JNZ   0x1DD7        (0149) _CHILD_2_aRxBuffer:    BLK CHILD_2_RX_BUFFER_SIZE
1DC4: 2E 14 01 OR    [20],1        (0150) ENDIF
                                   (0151) 
1DC7: 62 D3 00 MOV   REG[211],0    (0152) 
1DCA: 70 3F    AND   F,63
1DCC: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1DCE: 56 A8 00 MOV   [X-88],0      (0154) 
1DD1: 70 3F    AND   F,63
1DD3: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1DD5: 80 2A    JMP   0x1E00        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1DD7: 3C 15 0F CMP   [21],15       (0167) ;------------------------
1DDA: C0 14    JC    0x1DEF        (0168) 
1DDC: 2E 14 10 OR    [20],16       (0169) 
                                   (0170) ;------------------------
1DDF: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1DE2: 70 3F    AND   F,63
1DE4: 71 80    OR    F,128         (0172) ;------------------------
1DE6: 56 A8 00 MOV   [X-88],0      (0173) 
1DE9: 70 3F    AND   F,63
1DEB: 71 00    OR    F,0           (0174) 
1DED: 80 12    JMP   0x1E00        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1DEF: 75       INC   X             (0179) 
1DF0: 5A 15    MOV   [21],X        (0180) 
1DF2: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1DF3: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1DF6: 70 3F    AND   F,63
1DF8: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_2_ISR
1DFA: 54 A8    MOV   [X-88],A      (0185) ;
1DFC: 70 3F    AND   F,63
1DFE: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1E00: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1E01: 60 D3    MOV   REG[211],A    (0191) _CHILD_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1E03: 20       POP   X             (0195)    ; Insert your custom code below this banner
1E04: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1E06: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_2_timeout.asm
                                   (0102) ;;*****************************************************************************
1E09: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_2_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_2_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1E0A: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1E0D: 7F       RET                 (0131) export  CHILD_2_TIMEOUT_EnableInt
                                   (0132) export _CHILD_2_TIMEOUT_EnableInt
                                   (0133) export  CHILD_2_TIMEOUT_DisableInt
                                   (0134) export _CHILD_2_TIMEOUT_DisableInt
                                   (0135) export  CHILD_2_TIMEOUT_Start
                                   (0136) export _CHILD_2_TIMEOUT_Start
                                   (0137) export  CHILD_2_TIMEOUT_Stop
                                   (0138) export _CHILD_2_TIMEOUT_Stop
                                   (0139) export  CHILD_2_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_2_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_2_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_2_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_2_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_2_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_2_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_2_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
1E0E: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1E11: 7F       RET                 (0159) export  wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response2_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_2_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1E12: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1E15: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_2_TIMEOUT_EnableInt:
                                   (0200) _CHILD_2_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_2_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_2_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1E16: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1E18: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1E19: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1E1B: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_2_TIMEOUT_DisableInt:
                                   (0228) _CHILD_2_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_2_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1E1C: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1E1E: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1E1F: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1E21: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_2_TIMEOUT_Start:
                                   (0256) _CHILD_2_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_2_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1E22: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1E24: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1E25: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1E27: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_2_TIMEOUT_Stop:
                                   (0284) _CHILD_2_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_2_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_2_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_2_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_2_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_2_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_2_TIMEOUT_Stop to disable).
1E28: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1E29: 38 03    ADD   SP,3          (0334) ;
1E2B: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1E2D: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1E2E: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1E30: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1E31: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1E33: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1E34: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1E36: 5D 26    MOV   A,REG[38]     (0343) ;
1E38: 54 01    MOV   [X+1],A       (0344)  CHILD_2_TIMEOUT_WriteCompareValue:
1E3A: 5D 22    MOV   A,REG[34]     (0345) _CHILD_2_TIMEOUT_WriteCompareValue:
1E3C: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1E3E: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG], A
1E40: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1E43: A0 03    JZ    0x1E47        (0349)    mov   reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG], A
1E45: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1E47: 54 00    MOV   [X+0],A       (0352) 
1E49: 70 FE    AND   F,254         (0353) .ENDSECTION
1E4B: 41 23 FE AND   REG[35],254   (0354) 
1E4E: 18       POP   A             (0355) 
1E4F: 60 26    MOV   REG[38],A     (0356) .SECTION
1E51: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1E52: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadCompareValue
1E54: 18       POP   A             (0359) ;
1E55: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1E57: 18       POP   A             (0361) ;     Reads the Compare registers.
1E58: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1E59: 70 3F    AND   F,63
1E5B: 71 C0    OR    F,192         (0363) ;
1E5D: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1E5E: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1E60: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1E62: 5C       MOV   X,A           (0409) ;
1E63: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1E66: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_2.asm
                                   (0121) ;;*****************************************************************************
1E69: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_2.inc"
1E6A: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1E6D: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_2_EnableInt
                                   (0155) export  _CHILD_2_EnableInt
                                   (0156) export   CHILD_2_DisableInt
                                   (0157) export  _CHILD_2_DisableInt
                                   (0158) export   CHILD_2_Start
                                   (0159) export  _CHILD_2_Start
                                   (0160) export   CHILD_2_Stop
                                   (0161) export  _CHILD_2_Stop
                                   (0162) export   CHILD_2_bReadRxData
                                   (0163) export  _CHILD_2_bReadRxData
                                   (0164) export   CHILD_2_bReadRxStatus
                                   (0165) export  _CHILD_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_2_ReadRxData
                                   (0170) export _bCHILD_2_ReadRxData
                                   (0171) export  bCHILD_2_ReadRxStatus
                                   (0172) export _bCHILD_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_2_cGetChar
1E6E: 29 01    OR    A,1           (0179) export _CHILD_2_cGetChar
1E70: 60 2B    MOV   REG[43],A     (0180) export  CHILD_2_cReadChar
                                   (0181) export _CHILD_2_cReadChar
1E72: 7F       RET                 (0182) export  CHILD_2_iReadChar
                                   (0183) export _CHILD_2_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_2_RXBUF_ENABLE)
                                   (0186) export  CHILD_2_CmdReset
                                   (0187) export _CHILD_2_CmdReset
                                   (0188) export  CHILD_2_bCmdCheck
                                   (0189) export _CHILD_2_bCmdCheck
                                   (0190) export  CHILD_2_bCmdLength
                                   (0191) export _CHILD_2_bCmdLength
                                   (0192) export  CHILD_2_bErrCheck
                                   (0193) export _CHILD_2_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_2_szGetParam
                                   (0196) export _CHILD_2_szGetParam
                                   (0197) export  CHILD_2_szGetRestOfParams
                                   (0198) export _CHILD_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1E73: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1E76: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_2_EnableInt:
                                   (0238) _CHILD_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1E77: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1E79: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_2_DisableInt:
                                   (0267) _CHILD_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1E7A: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1E7C: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_2_Start:
                                   (0297) _CHILD_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1E7D: 49 2B 08 TST   REG[43],8     (0311) ;
1E80: AF FC    JZ    0x1E7D        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1E82: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1E84: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_2_Stop:
                                   (0326) _CHILD_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1E85: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1E87: 08       PUSH  A             (0347) ;
1E88: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1E8A: B0 04    JNZ   0x1E8F        (0349) ;    The A and X registers may be modified by this or future implementations
1E8C: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1E8D: 80 0B    JMP   0x1E99        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1E8F: 5D 2A    MOV   A,REG[42]     (0354) ;
1E91: 4B       SWAP  A,X           (0355)  CHILD_2_bReadRxData:
                                   (0356) _CHILD_2_bReadRxData:
1E92: 18       POP   A             (0357)  bCHILD_2_ReadRxData:
1E93: 21 A0    AND   A,160         (0358) _bCHILD_2_ReadRxData:
1E95: B0 03    JNZ   0x1E99        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1E97: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1E98: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1E99: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_2_bReadRxStatus
                                   (0368) ;
1E9B: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_2_bReadRxStatus:
                                   (0388) _CHILD_2_bReadRxStatus:
                                   (0389)  bCHILD_2_ReadRxStatus:
                                   (0390) _bCHILD_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1E9C: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1E9E: 21 E8    AND   A,232         (0408) ;
1EA0: 08       PUSH  A             (0409) ;  ARGUMENTS:
1EA1: 21 08    AND   A,8           (0410) ;      none
1EA3: B0 07    JNZ   0x1EAB        (0411) ;
1EA5: 18       POP   A             (0412) ;  RETURNS:
1EA6: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1EA8: 4B       SWAP  A,X           (0414) ;
1EA9: 80 07    JMP   0x1EB1        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1EAB: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1EAC: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1EAE: 4B       SWAP  A,X           (0420) ;    functions.
1EAF: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1EB1: 7F       RET                 (0426)  CHILD_2_cGetChar:
                                   (0427) _CHILD_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_2_CONTROL_REG],CHILD_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_2_cReadChar:
                                   (0463) _CHILD_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
1EB2: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1EB5: 55 A8 00 MOV   [168],0       (0470)    pop  A
1EB8: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1EBB: 55 D3 00 MOV   [TIMEOUT+2],0 (0472) 
1EBE: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1EC1: 55 15 00 MOV   [21],0        (0474)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
1EC4: 26 14 00 AND   [20],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1EC7: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_2_RX_PARITY_ERROR | CHILD_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1EC8: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1ECB: 51 14    MOV   A,[20]        (0511) ;        0x40CC    Overrun Error
1ECD: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1ECF: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_2_iReadChar:
                                   (0523) _CHILD_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_2_RX_ERROR|CHILD_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1ED0: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1ED3: 51 14    MOV   A,[20]        (0554) ;-----------------------------------------------------------------------------
1ED5: 21 F0    AND   A,240         (0555) ;
1ED7: 26 14 0F AND   [20],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1EDA: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_2_CmdReset:
1EDB: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_2_CmdReset:
1EDE: 51 15    MOV   A,[21]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_2_aRxBuffer
1EE0: 7F       RET                 (0590)    mov [CHILD_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
                                   (0594)    mov [CHILD_2_bRxCnt], 0x00
                                   (0595)    and [CHILD_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_2_bCmdCheck:
                                   (0628) _CHILD_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0631)    mov A,  [CHILD_2_fStatus]
                                   (0632)    and A, CHILD_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1EE1: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1EE3: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1EE6: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1EE9: 50 A8    MOV   A,168         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1EEB: 02 D3    ADD   A,[TIMEOUT+2] (0649) ;                     Returns non-zero value in A if command is valid.
1EED: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1EEE: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1EF0: B0 04    JNZ   0x1EF5        (0653) ;           0x10 => Software Buffer OverRun
1EF2: 10       PUSH  X             (0654) ;
1EF3: 80 33    JMP   0x1F27        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1EF5: 39 00    CMP   A,0           (0660) ;    functions.
1EF7: B0 11    JNZ   0x1F09        (0661) ;          
1EF9: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1EFA: 76 D3    INC   [TIMEOUT+2]   (0663) ;          CUR_PP
1EFC: 52 00    MOV   A,[X+0]       (0664) ;
1EFE: 3C D3 0F CMP   [TIMEOUT+2],15(0665) ;     Error Status is clear when read.
1F01: BF F3    JNZ   0x1EF5        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1F03: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_2_bErrCheck:
1F04: 56 00 00 MOV   [X+0],0       (0671) _CHILD_2_bErrCheck:
1F07: 80 1F    JMP   0x1F27        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0674)    mov A,  [CHILD_2_fStatus]
1F09: 10       PUSH  X             (0675)    and A, CHILD_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_2_fStatus], ~CHILD_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1F0A: 75       INC   X             (0679) .ENDSECTION
1F0B: 76 D3    INC   [TIMEOUT+2]   (0680) 
1F0D: 3C D3 0F CMP   [TIMEOUT+2],15(0681) .SECTION
1F10: AF F3    JZ    0x1F04        (0682) ;-----------------------------------------------------------------------------
1F12: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_2_bCmdLength
1F14: A0 12    JZ    0x1F27        (0684) ;
1F16: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1F18: BF F1    JNZ   0x1F0A        (0686) ;     Get length of command string
                                   (0687) ;
1F1A: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1F1D: 76 D3    INC   [TIMEOUT+2]   (0689) ;     none.
1F1F: 3C D3 0F CMP   [TIMEOUT+2],15(0690) ;
1F22: B0 04    JNZ   0x1F27        (0691) ;  RETURNS:
1F24: 55 D3 0F MOV   [TIMEOUT+2],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1F27: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1F28: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1F29: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1F2C: B0 0B    JNZ   0x1F38        (0699) ;    functions.
1F2E: 20       POP   X             (0700) ;          
1F2F: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1F31: 50 00    MOV   A,0           (0702) ;          CUR_PP
1F33: 70 3F    AND   F,63
1F35: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_2_bCmdLength:
1F37: 7F       RET                 (0705) _CHILD_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
1F38: 20       POP   X             (0708)    mov A,  [CHILD_2_bRxCnt]
1F39: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1F3B: 70 3F    AND   F,63
1F3D: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1F3F: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1F40: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1F43: 50 A8    MOV   A,168         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1F45: 02 D3    ADD   A,[TIMEOUT+2] (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1F47: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1F48: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_2_szGetParam, is
1F4B: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_1int.asm
1F4C: 10       PUSH  X             (0104) ;;*****************************************************************************
1F4D: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_1INT.asm
1F4F: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1F50: 58 17    MOV   X,[23]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1F52: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1F54: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1F55: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1F57: B0 04    JNZ   0x1F5C        (0115) 
1F59: 18       POP   A             (0116) include "m8c.inc"
1F5A: 80 5E    JMP   0x1FB9        (0117) include "memory.inc"
                                   (0118) include "CHILD_1.inc"
                                   (0119) 
                                   (0120) 
1F5C: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1F5D: 21 E0    AND   A,224         (0124) export  _CHILD_1_ISR
1F5F: A0 12    JZ    0x1F72        (0125) 
                                   (0126) 
1F61: 2C 16    OR    [22],A        (0127) IF (CHILD_1_RXBUF_ENABLE)
                                   (0128) export  CHILD_1_aRxBuffer
1F63: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_1_aRxBuffer
                                   (0130) export  CHILD_1_bRxCnt
1F66: 21 20    AND   A,32          (0131) export _CHILD_1_bRxCnt
1F68: A0 50    JZ    0x1FB9        (0132) export  CHILD_1_fStatus
                                   (0133) export _CHILD_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
1F6A: 41 2B FE AND   REG[43],254   (0136) 
1F6D: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1F70: 80 48    JMP   0x1FB9        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_1_RXBUF_ENABLE)
1F72: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_1_fStatus:
                                   (0144) _CHILD_1_fStatus:      BLK  1
1F74: 47 16 01 TST   [22],1        (0145)  CHILD_1_bRxCnt:
1F77: B0 41    JNZ   0x1FB9        (0146) _CHILD_1_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_1_RAM(RAM,REL,CON)
1F79: 39 00    CMP   A,0           (0148)  CHILD_1_aRxBuffer:    
1F7B: B0 14    JNZ   0x1F90        (0149) _CHILD_1_aRxBuffer:    BLK CHILD_1_RX_BUFFER_SIZE
1F7D: 2E 16 01 OR    [22],1        (0150) ENDIF
                                   (0151) 
1F80: 62 D3 00 MOV   REG[211],0    (0152) 
1F83: 70 3F    AND   F,63
1F85: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1F87: 56 78 00 MOV   [X+120],0     (0154) 
1F8A: 70 3F    AND   F,63
1F8C: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1F8E: 80 2A    JMP   0x1FB9        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1F90: 3C 17 0F CMP   [23],15       (0167) ;------------------------
1F93: C0 14    JC    0x1FA8        (0168) 
1F95: 2E 16 10 OR    [22],16       (0169) 
                                   (0170) ;------------------------
1F98: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1F9B: 70 3F    AND   F,63
1F9D: 71 80    OR    F,128         (0172) ;------------------------
1F9F: 56 78 00 MOV   [X+120],0     (0173) 
1FA2: 70 3F    AND   F,63
1FA4: 71 00    OR    F,0           (0174) 
1FA6: 80 12    JMP   0x1FB9        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1FA8: 75       INC   X             (0179) 
1FA9: 5A 17    MOV   [23],X        (0180) 
1FAB: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1FAC: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1FAF: 70 3F    AND   F,63
1FB1: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_1_ISR
1FB3: 54 78    MOV   [X+120],A     (0185) ;
1FB5: 70 3F    AND   F,63
1FB7: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1FB9: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1FBA: 60 D3    MOV   REG[211],A    (0191) _CHILD_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1FBC: 20       POP   X             (0195)    ; Insert your custom code below this banner
1FBD: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1FBF: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_1_timeout.asm
                                   (0102) ;;*****************************************************************************
1FC2: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_1_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_1_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1FC3: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1FC6: 7F       RET                 (0131) export  CHILD_1_TIMEOUT_EnableInt
                                   (0132) export _CHILD_1_TIMEOUT_EnableInt
                                   (0133) export  CHILD_1_TIMEOUT_DisableInt
                                   (0134) export _CHILD_1_TIMEOUT_DisableInt
                                   (0135) export  CHILD_1_TIMEOUT_Start
                                   (0136) export _CHILD_1_TIMEOUT_Start
                                   (0137) export  CHILD_1_TIMEOUT_Stop
                                   (0138) export _CHILD_1_TIMEOUT_Stop
                                   (0139) export  CHILD_1_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_1_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_1_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_1_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_1_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_1_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_1_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_1_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
1FC7: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1FCA: 7F       RET                 (0159) export  wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response1_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_1_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1FCB: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1FCE: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_1_TIMEOUT_EnableInt:
                                   (0200) _CHILD_1_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_1_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_1_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1FCF: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1FD1: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1FD2: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1FD4: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_1_TIMEOUT_DisableInt:
                                   (0228) _CHILD_1_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_1_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1FD5: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1FD7: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1FD8: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1FDA: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_1_TIMEOUT_Start:
                                   (0256) _CHILD_1_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_1_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1FDB: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1FDD: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1FDE: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1FE0: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_1_TIMEOUT_Stop:
                                   (0284) _CHILD_1_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_1_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_1_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_1_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_1_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_1_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_1_TIMEOUT_Stop to disable).
1FE1: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1FE2: 38 03    ADD   SP,3          (0334) ;
1FE4: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1FE6: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1FE7: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1FE9: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1FEA: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1FEC: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1FED: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1FEF: 5D 26    MOV   A,REG[38]     (0343) ;
1FF1: 54 01    MOV   [X+1],A       (0344)  CHILD_1_TIMEOUT_WriteCompareValue:
1FF3: 5D 22    MOV   A,REG[34]     (0345) _CHILD_1_TIMEOUT_WriteCompareValue:
1FF5: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1FF7: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG], A
1FF9: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1FFC: A0 03    JZ    0x2000        (0349)    mov   reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG], A
1FFE: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
2000: 54 00    MOV   [X+0],A       (0352) 
2002: 70 FE    AND   F,254         (0353) .ENDSECTION
2004: 41 23 FE AND   REG[35],254   (0354) 
2007: 18       POP   A             (0355) 
2008: 60 26    MOV   REG[38],A     (0356) .SECTION
200A: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
200B: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadCompareValue
200D: 18       POP   A             (0359) ;
200E: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
2010: 18       POP   A             (0361) ;     Reads the Compare registers.
2011: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
2012: 70 3F    AND   F,63
2014: 71 C0    OR    F,192         (0363) ;
2016: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
2017: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
2019: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
201B: 5C       MOV   X,A           (0409) ;
201C: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
201F: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_1.asm
                                   (0121) ;;*****************************************************************************
2022: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_1.inc"
2023: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
2026: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_1_EnableInt
                                   (0155) export  _CHILD_1_EnableInt
                                   (0156) export   CHILD_1_DisableInt
                                   (0157) export  _CHILD_1_DisableInt
                                   (0158) export   CHILD_1_Start
                                   (0159) export  _CHILD_1_Start
                                   (0160) export   CHILD_1_Stop
                                   (0161) export  _CHILD_1_Stop
                                   (0162) export   CHILD_1_bReadRxData
                                   (0163) export  _CHILD_1_bReadRxData
                                   (0164) export   CHILD_1_bReadRxStatus
                                   (0165) export  _CHILD_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_1_ReadRxData
                                   (0170) export _bCHILD_1_ReadRxData
                                   (0171) export  bCHILD_1_ReadRxStatus
                                   (0172) export _bCHILD_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_1_cGetChar
2027: 29 01    OR    A,1           (0179) export _CHILD_1_cGetChar
2029: 60 2B    MOV   REG[43],A     (0180) export  CHILD_1_cReadChar
                                   (0181) export _CHILD_1_cReadChar
202B: 7F       RET                 (0182) export  CHILD_1_iReadChar
                                   (0183) export _CHILD_1_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_1_RXBUF_ENABLE)
                                   (0186) export  CHILD_1_CmdReset
                                   (0187) export _CHILD_1_CmdReset
                                   (0188) export  CHILD_1_bCmdCheck
                                   (0189) export _CHILD_1_bCmdCheck
                                   (0190) export  CHILD_1_bCmdLength
                                   (0191) export _CHILD_1_bCmdLength
                                   (0192) export  CHILD_1_bErrCheck
                                   (0193) export _CHILD_1_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_1_szGetParam
                                   (0196) export _CHILD_1_szGetParam
                                   (0197) export  CHILD_1_szGetRestOfParams
                                   (0198) export _CHILD_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
202C: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
202F: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_1_EnableInt:
                                   (0238) _CHILD_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
2030: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
2032: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_1_DisableInt:
                                   (0267) _CHILD_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
2033: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
2035: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_1_Start:
                                   (0297) _CHILD_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
2036: 49 2B 08 TST   REG[43],8     (0311) ;
2039: AF FC    JZ    0x2036        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
203B: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
203D: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_1_Stop:
                                   (0326) _CHILD_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
203E: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
2040: 08       PUSH  A             (0347) ;
2041: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
2043: B0 04    JNZ   0x2048        (0349) ;    The A and X registers may be modified by this or future implementations
2045: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
2046: 80 0B    JMP   0x2052        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
2048: 5D 2A    MOV   A,REG[42]     (0354) ;
204A: 4B       SWAP  A,X           (0355)  CHILD_1_bReadRxData:
                                   (0356) _CHILD_1_bReadRxData:
204B: 18       POP   A             (0357)  bCHILD_1_ReadRxData:
204C: 21 A0    AND   A,160         (0358) _bCHILD_1_ReadRxData:
204E: B0 03    JNZ   0x2052        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
2050: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
2051: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
2052: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_1_bReadRxStatus
                                   (0368) ;
2054: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_1_bReadRxStatus:
                                   (0388) _CHILD_1_bReadRxStatus:
                                   (0389)  bCHILD_1_ReadRxStatus:
                                   (0390) _bCHILD_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
2055: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
2057: 21 E8    AND   A,232         (0408) ;
2059: 08       PUSH  A             (0409) ;  ARGUMENTS:
205A: 21 08    AND   A,8           (0410) ;      none
205C: B0 07    JNZ   0x2064        (0411) ;
205E: 18       POP   A             (0412) ;  RETURNS:
205F: 29 01    OR    A,1           (0413) ;     char that is returned from UART
2061: 4B       SWAP  A,X           (0414) ;
2062: 80 07    JMP   0x206A        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
2064: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
2065: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
2067: 4B       SWAP  A,X           (0420) ;    functions.
2068: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
206A: 7F       RET                 (0426)  CHILD_1_cGetChar:
                                   (0427) _CHILD_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_1_CONTROL_REG],CHILD_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_1_cReadChar:
                                   (0463) _CHILD_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
206B: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
206E: 55 78 00 MOV   [120],0       (0470)    pop  A
2071: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
2074: 55 D4 00 MOV   [TIMEOUT+3],0 (0472) 
2077: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
207A: 55 17 00 MOV   [23],0        (0474)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
207D: 26 16 00 AND   [22],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
2080: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_1_RX_PARITY_ERROR | CHILD_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
2081: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
2084: 51 16    MOV   A,[22]        (0511) ;        0x40CC    Overrun Error
2086: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
2088: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_1_iReadChar:
                                   (0523) _CHILD_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_1_RX_ERROR|CHILD_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_1_RXBUF_ENABLE)
                                   (0552) .SECTION
2089: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
208C: 51 16    MOV   A,[22]        (0554) ;-----------------------------------------------------------------------------
208E: 21 F0    AND   A,240         (0555) ;
2090: 26 16 0F AND   [22],15       (0556) ;     Command Buffer commands
                                   (0557) ;
2093: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_1_CmdReset:
2094: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_1_CmdReset:
2097: 51 17    MOV   A,[23]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_1_aRxBuffer
2099: 7F       RET                 (0590)    mov [CHILD_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
                                   (0594)    mov [CHILD_1_bRxCnt], 0x00
                                   (0595)    and [CHILD_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_1_bCmdCheck:
                                   (0628) _CHILD_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0631)    mov A,  [CHILD_1_fStatus]
                                   (0632)    and A, CHILD_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
209A: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
209C: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
209F: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
20A2: 50 78    MOV   A,120         (0648) ;     BYTE  fStatus - Status of command receive buffer.
20A4: 02 D4    ADD   A,[TIMEOUT+3] (0649) ;                     Returns non-zero value in A if command is valid.
20A6: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
20A7: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
20A9: B0 04    JNZ   0x20AE        (0653) ;           0x10 => Software Buffer OverRun
20AB: 10       PUSH  X             (0654) ;
20AC: 80 33    JMP   0x20E0        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
20AE: 39 00    CMP   A,0           (0660) ;    functions.
20B0: B0 11    JNZ   0x20C2        (0661) ;          
20B2: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
20B3: 76 D4    INC   [TIMEOUT+3]   (0663) ;          CUR_PP
20B5: 52 00    MOV   A,[X+0]       (0664) ;
20B7: 3C D4 0F CMP   [TIMEOUT+3],15(0665) ;     Error Status is clear when read.
20BA: BF F3    JNZ   0x20AE        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
20BC: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_1_bErrCheck:
20BD: 56 00 00 MOV   [X+0],0       (0671) _CHILD_1_bErrCheck:
20C0: 80 1F    JMP   0x20E0        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0674)    mov A,  [CHILD_1_fStatus]
20C2: 10       PUSH  X             (0675)    and A, CHILD_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_1_fStatus], ~CHILD_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
20C3: 75       INC   X             (0679) .ENDSECTION
20C4: 76 D4    INC   [TIMEOUT+3]   (0680) 
20C6: 3C D4 0F CMP   [TIMEOUT+3],15(0681) .SECTION
20C9: AF F3    JZ    0x20BD        (0682) ;-----------------------------------------------------------------------------
20CB: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_1_bCmdLength
20CD: A0 12    JZ    0x20E0        (0684) ;
20CF: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
20D1: BF F1    JNZ   0x20C3        (0686) ;     Get length of command string
                                   (0687) ;
20D3: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
20D6: 76 D4    INC   [TIMEOUT+3]   (0689) ;     none.
20D8: 3C D4 0F CMP   [TIMEOUT+3],15(0690) ;
20DB: B0 04    JNZ   0x20E0        (0691) ;  RETURNS:
20DD: 55 D4 0F MOV   [TIMEOUT+3],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
20E0: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
20E1: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
20E2: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
20E5: B0 0B    JNZ   0x20F1        (0699) ;    functions.
20E7: 20       POP   X             (0700) ;          
20E8: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
20EA: 50 00    MOV   A,0           (0702) ;          CUR_PP
20EC: 70 3F    AND   F,63
20EE: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_1_bCmdLength:
20F0: 7F       RET                 (0705) _CHILD_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
20F1: 20       POP   X             (0708)    mov A,  [CHILD_1_bRxCnt]
20F2: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
20F4: 70 3F    AND   F,63
20F6: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
20F8: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
20F9: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
20FC: 50 78    MOV   A,120         (0744) ;     each lexically distinct element into a null-terminated string by replacing
20FE: 02 D4    ADD   A,[TIMEOUT+3] (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
2100: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
2101: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_1_szGetParam, is
_main:
__text_start:
2104: 62 D0 00 MOV   REG[208],0    (0750) ;     not called until the buffer has been loaded with an entire command
2107: 55 E3 00 MOV   [CHILD],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~3\THESIS~1\main.c
(0158) // Author: Jason Tennyson
210A: 62 D0 00 MOV   REG[208],0
210D: 55 D0 00 MOV   [CONFIGURED+1],0
2110: 55 CF 00 MOV   [CONFIGURED],0
(0159) // Date: 1-25-11
2113: 62 D0 00 MOV   REG[208],0
2116: 55 D2 00 MOV   [TIMEOUT+1],0
2119: 55 D1 00 MOV   [TIMEOUT],0
(0160) // File: main.c
211C: 62 D0 00 MOV   REG[208],0
211F: 55 DE 00 MOV   [COMMAND_PARAM],0
(0161) //
2122: 62 D0 00 MOV   REG[208],0
2125: 55 CE 00 MOV   [STATE+1],0
2128: 55 CD 00 MOV   [STATE],0
(0162) // This is the design for the revolute modules for Jason Tennyson's Thesis.
212B: 62 D0 00 MOV   REG[208],0
212E: 55 E2 FB MOV   [ID],251
(0163) // This design is made for a PSoC CY8C28433-24PVXI.
(0164) //
2131: 71 01    OR    F,1
(0165) // Packet Structure
(0166) // ----------------
2133: 43 E0 20 OR    REG[224],32
(0167) // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0168) 
(0169) #include <m8c.h>        	// Part-specific constants and macros.
2136: 7C 31 4F LCALL _servoBootWait
(0170) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
(0171) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
(0172) 
2139: 7C 2E 84 LCALL _servoFinder
213C: 80 12    JMP   0x214F
(0173) // These are declarations of all of the timer interrupts that are used for all configurations.
(0174) #pragma interrupt_handler TX_01234_TIMEOUT_ISR
(0175) #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
(0176) #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
(0177) #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
213E: 92 8E    CALL  _commandReady
2140: 62 D0 00 MOV   REG[208],0
2143: 3C CC 00 CMP   [__r0],0
2146: B0 06    JNZ   0x214D
2148: 3C CB 00 CMP   [__r1],0
214B: A0 03    JZ    0x214F
(0178) #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
(0179) #pragma interrupt_handler HELLO_TIMEOUT_ISR
(0180) #pragma interrupt_handler INIT_TIMEOUT_ISR
214D: 97 09    CALL  _takeAction
214F: 8F EE    JMP   0x213E
2151: 8F FF    JMP   0x2151
(0181) #pragma interrupt_handler WAIT_RECV_TIMEOUT_ISR
(0182) 
(0183) // These defines are used as parameters of the configToggle function.  Passing one of
(0184) // these identifiers to configToggle will put the chip in that device configuration.
(0185) #define		WAIT						(1)
(0186) #define		MY_RESPONSE					(2)
(0187) #define 	RESPONSE_1					(3)
(0188) #define 	RESPONSE_2					(4)
_sayHello:
2153: 50 00    MOV   A,0
2155: 08       PUSH  A
2156: 50 02    MOV   A,2
2158: 08       PUSH  A
2159: 90 5D    CALL  _configToggle
215B: 38 FE    ADD   SP,254
(0189) #define 	RESPONSE_3					(5)
(0190) #define 	RESPONSE_4					(6)
(0191) #define		HELLO_MODE					(7)
215D: 10       PUSH  X
215E: 50 FC    MOV   A,252
2160: 7C 0F 8C LCALL 0x0F8C
2163: 20       POP   X
(0192) #define		INITIALIZE					(8)
2164: 10       PUSH  X
2165: 50 FC    MOV   A,252
2167: 7C 0F 8C LCALL 0x0F8C
216A: 20       POP   X
(0193) #define		SERVO_COMM					(9)
216B: 10       PUSH  X
216C: 62 D0 00 MOV   REG[208],0
216F: 51 E2    MOV   A,[ID]
2171: 7C 0F 8C LCALL 0x0F8C
2174: 20       POP   X
(0194) 
2175: 10       PUSH  X
2176: 50 00    MOV   A,0
2178: 7C 0F 8C LCALL 0x0F8C
217B: 20       POP   X
(0195) // These defines are used as comparisons to find what port the next module connected to.
217C: 10       PUSH  X
217D: 50 C8    MOV   A,200
217F: 7C 0F 8C LCALL 0x0F8C
2182: 20       POP   X
(0196) #define		PORT_A						('A')
2183: 10       PUSH  X
2184: 62 D0 00 MOV   REG[208],0
2187: 51 E3    MOV   A,[CHILD]
2189: 7C 0F 8C LCALL 0x0F8C
218C: 20       POP   X
(0197) #define		PORT_B						('B')
218D: 10       PUSH  X
218E: 50 FD    MOV   A,253
2190: 7C 0F 8C LCALL 0x0F8C
2193: 20       POP   X
(0198) #define		PORT_C						('C')
2194: 10       PUSH  X
2195: 50 FD    MOV   A,253
2197: 7C 0F 8C LCALL 0x0F8C
219A: 20       POP   X
(0199) #define		PORT_D						('D')
(0200) 
(0201) // These defines are used as transmission indicators for transmissions between PSoC controllers.
219B: 10       PUSH  X
219C: 7C 0F 5F LCALL 0x0F5F
219F: 62 D0 00 MOV   REG[208],0
21A2: 20       POP   X
21A3: 53 CC    MOV   [__r0],A
21A5: 47 CC 20 TST   [__r0],32
21A8: AF F2    JZ    0x219B
(0202) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0203) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0204) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
21AA: 7C 31 30 LCALL _xmitWait
(0205) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
(0206) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is complete.
21AD: 50 00    MOV   A,0
21AF: 08       PUSH  A
21B0: 50 01    MOV   A,1
21B2: 08       PUSH  A
21B3: 90 03    CALL  _configToggle
21B5: 38 FE    ADD   SP,254
21B7: 7F       RET   
(0207) #define		PING						(203)	// Indicates a ping message to or from the master.
(0208) #define		CLEAR_CONFIG				(204)	// Indicates that the master is asking for a config clear.
(0209) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
(0210) #define		MASTER_ID					(0)		// The master node's ID.
(0211) #define		DEFAULT_ID					(251)	// The ID that all modules start with.
(0212) #define		BROADCAST					(254)	// The broadcast ID for all controllers and servos.
_configToggle:
  mode                 --> X-5
21B8: 10       PUSH  X
21B9: 4F       MOV   X,SP
(0213) 
(0214) // SERVO DEFINES
(0215) // These numbers can all be found in the AX-12+ datasheet.
21BA: 43 00 1F OR    REG[0],31
(0216) // These defines cover the range of IDs these servos are capable of.
21BD: 41 02 E0 AND   REG[2],224
(0217) #define		SERVO_ID_MIN				(0)		// This is the lowest servo ID possible.
(0218) #define		SERVO_ID_MAX				(253)	// This is the highest servo ID possible.
(0219) // These defines are servo transmission indicators.
(0220) #define		SERVO_START					(255)	// This is the start byte for a servo transmission.
21C0: 62 D0 00 MOV   REG[208],0
21C3: 3C CD 00 CMP   [STATE],0
21C6: B0 06    JNZ   0x21CD
21C8: 3C CE 00 CMP   [STATE+1],0
21CB: A0 11    JZ    0x21DD
(0221) // These defines are used to fill in the length parameter for a given command type.  These are the only
(0222) // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
21CD: 62 D0 00 MOV   REG[208],0
21D0: 51 CD    MOV   A,[STATE]
21D2: 08       PUSH  A
21D3: 51 CE    MOV   A,[STATE+1]
21D5: 08       PUSH  A
21D6: 7C 2C 1C LCALL _unloadConfig
21D9: 38 FE    ADD   SP,254
(0223) // and length of command can be issued from the master after configuration is complete.
21DB: 80 04    JMP   0x21E0
(0224) #define		READ_LENGTH					(4)		// This is the length value for all reads.
(0225) #define		WRITE_LENGTH				(4)		// This is the length value for all writes.
(0226) #define		PING_LENGTH					(2)		// This is the length value for a ping.
21DD: 7C 2C 00 LCALL _unloadAllConfigs
(0227) #define		RESET_LENGTH				(2)		// This is the length value for a reset.
(0228) // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
(0229) #define		ID_ADDRESS					(3)		// This is the address where servo ID is stored.
(0230) #define		STATUS_RET_ADDRESS			(16)	// This is where the status return level is stored.
(0231) // These defines are used to fill in the instruction we are using on the servo.
21E0: 3D FB 00 CMP   [X-5],0
21E3: B0 2E    JNZ   0x2212
21E5: 3D FC 01 CMP   [X-4],1
21E8: B0 29    JNZ   0x2212
(0232) #define		PING_SERVO					(1)		// This is the instruction number for ping.
(0233) #define		READ_SERVO					(2)		// This is the instruction number for a read.
(0234) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0235) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
21EA: 7C 06 A6 LCALL 0x06A6
(0236) // These defines cover all of the status return level possibilities.
(0237) #define		STATUS_RET_NEVER			(0)		// Only respond to ping commands.
(0238) #define		STATUS_RET_READ				(1)		// Only respond to read data commands (recommended).
21ED: 62 D0 00 MOV   REG[208],0
21F0: 55 D2 00 MOV   [TIMEOUT+1],0
21F3: 55 D1 00 MOV   [TIMEOUT],0
(0239) #define		STATUS_RET_ALL				(2)		// Respond to every command.
(0240) 
(0241) // This is the number of attempts we make to contact the servo per sweep of attempts before
21F6: 10       PUSH  X
21F7: 50 00    MOV   A,0
21F9: 7C 0D 82 LCALL 0x0D82
21FC: 20       POP   X
(0242) // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
21FD: 10       PUSH  X
21FE: 50 00    MOV   A,0
2200: 7C 11 C6 LCALL 0x11C6
(0243) #define		SERVO_COMM_ATTEMPTS			(10)
(0244) // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
2203: 7C 0D 1A LCALL 0x0D1A
2206: 20       POP   X
(0245) // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
(0246) // If we don't then do at least one more loop, the EEPROM write was done for no reason.
(0247) #define		SERVO_COMM_LOOPS			(2)
2207: 62 D0 00 MOV   REG[208],0
220A: 55 CE 01 MOV   [STATE+1],1
220D: 55 CD 00 MOV   [STATE],0
(0248) // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
2210: 81 A0    JMP   0x23B1
(0249) #define		SERVO_BOOT_TIMEOUTS			(75)
2212: 3D FB 00 CMP   [X-5],0
2215: B0 4C    JNZ   0x2262
2217: 3D FC 02 CMP   [X-4],2
221A: B0 47    JNZ   0x2262
(0250) 
(0251) // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
(0252) // This will be the amount of iterations we do after the last byte has been received as well.
221C: 7C 08 68 LCALL 0x0868
(0253) #define		RESPONSE_ITERATIONS			(10)
(0254) 
(0255) // This is the status return level, which is set to one of the possible status return values above.
221F: 62 D0 00 MOV   REG[208],0
2222: 55 D2 00 MOV   [TIMEOUT+1],0
2225: 55 D1 00 MOV   [TIMEOUT],0
(0256) // We want the status return level to be return on read commands only so that we don't have garbage
(0257) // return packets flying around every time we tell the servo to move.
(0258) #define		STATUS_RET_LEVEL			(STATUS_RET_READ)
2228: 10       PUSH  X
2229: 50 00    MOV   A,0
222B: 7C 0F 53 LCALL 0x0F53
222E: 20       POP   X
(0259) 
222F: 10       PUSH  X
2230: 50 00    MOV   A,0
2232: 7C 0E 7A LCALL 0x0E7A
(0260) // This function receives a mode identifier as a parameter and toggles the system configuration.
(0261) void configToggle(int mode);
2235: 7C 10 11 LCALL 0x1011
(0262) // This function unloads all configurations.  This should only be needed at startup.
2238: 7C 10 19 LCALL 0x1019
223B: 20       POP   X
(0263) void unloadAllConfigs(void);
(0264) // This function unloads the configuration corresponding to the number passed to it.
(0265) void unloadConfig(int config_num);
(0266) // This function is a response to the master sending out a hello message.
223C: 62 D0 00 MOV   REG[208],0
223F: 3C D1 00 CMP   [TIMEOUT],0
2242: B0 06    JNZ   0x2249
2244: 3C D2 00 CMP   [TIMEOUT+1],0
2247: AF F4    JZ    0x223C
(0267) void sayHello(void);
(0268) // This function looks for commands and returns 1 if a command has been read, 0 if not.
2249: 10       PUSH  X
224A: 7C 10 1D LCALL 0x101D
224D: 20       POP   X
(0269) int commandReady(void);
224E: 62 D0 00 MOV   REG[208],0
2251: 55 D2 00 MOV   [TIMEOUT+1],0
2254: 55 D1 00 MOV   [TIMEOUT],0
(0270) // This function interprets the command that has just been read and performs an action accordingly.
(0271) void takeAction(void);
(0272) // This function responds to a ping.
2257: 62 D0 00 MOV   REG[208],0
225A: 55 CE 02 MOV   [STATE+1],2
225D: 55 CD 00 MOV   [STATE],0
(0273) void pingResponse(void);
2260: 81 50    JMP   0x23B1
(0274) // This function tells the master node that an ID assignment was completed on this module.
2262: 3D FB 00 CMP   [X-5],0
2265: B0 2A    JNZ   0x2290
2267: 3D FC 03 CMP   [X-4],3
226A: B0 25    JNZ   0x2290
(0275) void assignedID(void);
(0276) // This function sends out an acknowledgement of a configuration reset.
(0277) void configCleared(void);
226C: 7C 08 D8 LCALL 0x08D8
(0278) // This function listens for children and registers the port that they talk to.
(0279) int childListen(void);
(0280) // This function waits for a known child's response to a command to that child from the master.
226F: 62 D0 00 MOV   REG[208],0
2272: 55 D2 00 MOV   [TIMEOUT+1],0
2275: 55 D1 00 MOV   [TIMEOUT],0
(0281) int childResponse(void);
(0282) // This function does everything it can to find the servo attached to this controller.
(0283) void servoFinder(void);
2278: 10       PUSH  X
2279: 50 00    MOV   A,0
227B: 7C 20 27 LCALL 0x2027
(0284) // This function carries out the passed servo instruction.
(0285) void servoInstruction(char id, char length, char instruction, char address, char value);
227E: 7C 1F BF LCALL 0x1FBF
(0286) // This function does a simple for loop to stall and make doubly sure that the transmission finished.
2281: 7C 1F C7 LCALL 0x1FC7
2284: 20       POP   X
(0287) // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
(0288) void xmitWait(void);
(0289) // This function is called to do nothing while we wait for the servo to boot up.
2285: 62 D0 00 MOV   REG[208],0
2288: 55 CE 03 MOV   [STATE+1],3
228B: 55 CD 00 MOV   [STATE],0
(0290) void servoBootWait(void);
228E: 81 22    JMP   0x23B1
(0291) // This function is used to wait for other controllers to find their servos while not
2290: 3D FB 00 CMP   [X-5],0
2293: B0 2A    JNZ   0x22BE
2295: 3D FC 04 CMP   [X-4],4
2298: B0 25    JNZ   0x22BE
(0292) // driving any pins (which would keep a child from talking to its servo).
(0293) void servoConfigWait(void);
(0294) 
229A: 7C 09 84 LCALL 0x0984
(0295) char CHILD;		// Keeps track of where the child is connected.
(0296) char ID;		// Stores the ID that the master gives this module.
(0297) 
229D: 62 D0 00 MOV   REG[208],0
22A0: 55 D2 00 MOV   [TIMEOUT+1],0
22A3: 55 D1 00 MOV   [TIMEOUT],0
(0298) int CONFIGURED;	// Keeps track of whether or not this module has been configured by the master.
(0299) int TIMEOUT;	// This flag is set if a timeout occurs.
(0300) int STATE;		// This stores the ID of the currently-loaded configuration.
22A6: 10       PUSH  X
22A7: 50 00    MOV   A,0
22A9: 7C 1E 6E LCALL 0x1E6E
(0301) 
(0302) char COMMAND_SOURCE;		// Stores who the current command is from.
22AC: 7C 1E 06 LCALL 0x1E06
(0303) char COMMAND_DESTINATION;	// Stores who the current command is for.
22AF: 7C 1E 0E LCALL 0x1E0E
22B2: 20       POP   X
(0304) char COMMAND_TYPE;			// Stores the type of command that was just read.
(0305) char COMMAND_PARAM;			// Stores a parameter that accompanies the command (if any).
(0306) char COMMAND_LENGTH;		// Stores the length parameter of a servo command.
22B3: 62 D0 00 MOV   REG[208],0
22B6: 55 CE 04 MOV   [STATE+1],4
22B9: 55 CD 00 MOV   [STATE],0
(0307) char COMMAND_ERROR;			// Stores the error code of a servo command.
22BC: 80 F4    JMP   0x23B1
(0308) 
22BE: 3D FB 00 CMP   [X-5],0
22C1: B0 2A    JNZ   0x22EC
22C3: 3D FC 05 CMP   [X-4],5
22C6: B0 25    JNZ   0x22EC
(0309) char SERVO_ID;				// Stores the ID of the servo inside of this module.
(0310) 
(0311) void main()
22C8: 7C 0A 30 LCALL 0x0A30
(0312) {	
(0313) 	// Initial value assignment for variables of importance.
(0314) 	CHILD = 0;				// There is no child yet.
22CB: 62 D0 00 MOV   REG[208],0
22CE: 55 D2 00 MOV   [TIMEOUT+1],0
22D1: 55 D1 00 MOV   [TIMEOUT],0
(0315) 	CONFIGURED = 0;			// This module is not configured yet.
(0316) 	TIMEOUT = 0;			// Set the timeout flag low to start.
(0317) 	COMMAND_PARAM = 0;		// There is no parameter yet.
22D4: 10       PUSH  X
22D5: 50 00    MOV   A,0
22D7: 7C 1C B5 LCALL 0x1CB5
(0318) 	STATE = 0;				// There is no state yet.
(0319) 	ID = DEFAULT_ID;		// Set the ID of this controller to the default to start with.
22DA: 7C 1C 4D LCALL 0x1C4D
(0320) 
22DD: 7C 1C 55 LCALL 0x1C55
22E0: 20       POP   X
(0321) 	M8C_EnableGInt;			// Turn on global interrupts for the transmission timeout timer.
(0322) 	
(0323) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
22E1: 62 D0 00 MOV   REG[208],0
22E4: 55 CE 05 MOV   [STATE+1],5
22E7: 55 CD 00 MOV   [STATE],0
(0324) 	
22EA: 80 C6    JMP   0x23B1
(0325) 	// We have to wait for the servo to power up and get ready for communications.
22EC: 3D FB 00 CMP   [X-5],0
22EF: B0 2A    JNZ   0x231A
22F1: 3D FC 06 CMP   [X-4],6
22F4: B0 25    JNZ   0x231A
(0326) 	servoBootWait();
(0327) 	
(0328) 	// Find the servo that is inside of this module.
22F6: 7C 0A DC LCALL 0x0ADC
(0329) 	servoFinder();
(0330) 	
(0331) 	// Loop and wait for commands.
22F9: 62 D0 00 MOV   REG[208],0
22FC: 55 D2 00 MOV   [TIMEOUT+1],0
22FF: 55 D1 00 MOV   [TIMEOUT],0
(0332) 	while(1)
(0333) 	{	
(0334) 		if(commandReady())
2302: 10       PUSH  X
2303: 50 00    MOV   A,0
2305: 7C 1A FC LCALL 0x1AFC
(0335) 		{
(0336) 			// If the command is ready, take action.
2308: 7C 1A 94 LCALL 0x1A94
(0337) 			takeAction();
230B: 7C 1A 9C LCALL 0x1A9C
230E: 20       POP   X
(0338) 		}
(0339) 	}
(0340) }
230F: 62 D0 00 MOV   REG[208],0
2312: 55 CE 06 MOV   [STATE+1],6
2315: 55 CD 00 MOV   [STATE],0
(0341) 
2318: 80 98    JMP   0x23B1
(0342) // This function transmits a response to a hello command from the master.
231A: 3D FB 00 CMP   [X-5],0
231D: B0 3F    JNZ   0x235D
231F: 3D FC 07 CMP   [X-4],7
2322: B0 3A    JNZ   0x235D
(0343) void sayHello(void)
(0344) {	
(0345) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2324: 7C 07 0D LCALL 0x070D
(0346) 	
(0347) 	// Transmit a hello response to the master node.
(0348) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
2327: 62 D0 00 MOV   REG[208],0
232A: 55 D2 00 MOV   [TIMEOUT+1],0
232D: 55 D1 00 MOV   [TIMEOUT],0
(0349) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(0350) 	TX_014_PutChar(ID);				// My ID (source)
(0351) 	TX_014_PutChar(MASTER_ID);		// Master ID (destination)
(0352) 	TX_014_PutChar(HELLO_BYTE);		// This is a hello command.
(0353) 	TX_014_PutChar(CHILD);			// Sends child port value, default 0.
(0354) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
2330: 10       PUSH  X
2331: 50 00    MOV   A,0
2333: 7C 19 43 LCALL 0x1943
2336: 20       POP   X
(0355) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
(0356) 	
(0357) 	// Wait for the transmission to finish.
(0358) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(0359) 	
2337: 10       PUSH  X
2338: 50 00    MOV   A,0
233A: 7C 17 EA LCALL 0x17EA
233D: 20       POP   X
(0360) 	// Make completely sure we're done.
(0361) 	xmitWait();
(0362) 
(0363) 	configToggle(WAIT);				// Switch back to wait mode.
(0364) }
233E: 10       PUSH  X
233F: 50 00    MOV   A,0
2341: 7C 16 91 LCALL 0x1691
2344: 20       POP   X
(0365) 
(0366) // This function receives a mode flag and switches the microcontroller to the
(0367) // desired hardware configuration.
(0368) void configToggle(int mode)
(0369) {	
2345: 10       PUSH  X
2346: 50 00    MOV   A,0
2348: 7C 15 38 LCALL 0x1538
(0370) 	// Set the pins high and disconnect from the global bus.
(0371) 	// This keeps false start bits from happening while we swap configs.
(0372) 	PRT0DR |= 0b00011111;	// Set pins P00 through P04 high.
234B: 7C 14 5C LCALL 0x145C
(0373) 	PRT0GS &= 0b11100000;	// Disconnect pins P00 through P04 from the global bus.
234E: 7C 14 64 LCALL 0x1464
2351: 20       POP   X
(0374) 	
(0375) 	// Unload the configuration of the current state.
(0376) 	// If there is no state, blindly wipe all configurations.
2352: 62 D0 00 MOV   REG[208],0
2355: 55 CE 07 MOV   [STATE+1],7
2358: 55 CD 00 MOV   [STATE],0
(0377) 	if(STATE)
235B: 80 55    JMP   0x23B1
(0378) 	{
235D: 3D FB 00 CMP   [X-5],0
2360: B0 2A    JNZ   0x238B
2362: 3D FC 08 CMP   [X-4],8
2365: B0 25    JNZ   0x238B
(0379) 		unloadConfig(STATE);
(0380) 	}
(0381) 	else
2367: 7C 07 B3 LCALL 0x07B3
(0382) 	{
(0383) 		unloadAllConfigs();
(0384) 	}
236A: 62 D0 00 MOV   REG[208],0
236D: 55 D2 00 MOV   [TIMEOUT+1],0
2370: 55 D1 00 MOV   [TIMEOUT],0
(0385) 	
(0386) 	// Go through the list of possible modes until we find the one that was passed in to us.
(0387) 	// Then, load that configuration and initialize whatever needs to be initialized.
2373: 10       PUSH  X
2374: 50 00    MOV   A,0
2376: 7C 13 7F LCALL 0x137F
(0388) 	if(mode == WAIT)
(0389) 	{
2379: 7C 12 A3 LCALL 0x12A3
(0390) 		// Load the wait receiver configuration.  This is the receiver configuration used after
237C: 7C 12 AB LCALL 0x12AB
237F: 20       POP   X
(0391) 		// initialization is complete.  It listens and forwards everything it hears.
(0392) 		LoadConfig_waiting();
(0393) 		
2380: 62 D0 00 MOV   REG[208],0
2383: 55 CE 08 MOV   [STATE+1],8
2386: 55 CD 00 MOV   [STATE],0
(0394) 		// Clear the timeout flag.
2389: 80 27    JMP   0x23B1
(0395) 		TIMEOUT = 0;
238B: 3D FB 00 CMP   [X-5],0
238E: B0 22    JNZ   0x23B1
2390: 3D FC 09 CMP   [X-4],9
2393: B0 1D    JNZ   0x23B1
(0396) 		
(0397) 		// Start the receivers.
(0398) 		WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
2395: 7C 0B 91 LCALL 0x0B91
(0399) 		RX8_2_Start(RX8_2_PARITY_NONE);
(0400) 		
(0401) 		WAIT_RECV_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
2398: 62 D0 00 MOV   REG[208],0
239B: 55 D2 00 MOV   [TIMEOUT+1],0
239E: 55 D1 00 MOV   [TIMEOUT],0
(0402) 		
(0403) 		// Set the current state.
(0404) 		STATE = WAIT;
23A1: 10       PUSH  X
23A2: 50 00    MOV   A,0
23A4: 7C 10 8C LCALL 0x108C
23A7: 20       POP   X
(0405) 	}
(0406) 	else if(mode == MY_RESPONSE)
(0407) 	{
23A8: 62 D0 00 MOV   REG[208],0
23AB: 55 CE 09 MOV   [STATE+1],9
23AE: 55 CD 00 MOV   [STATE],0
(0408) 		// Load the transmitter configuration.  This is for transmitting messages on all ports.
(0409) 		LoadConfig_my_response();
(0410) 		
(0411) 		// Clear the timeout flag.
23B1: 62 D0 00 MOV   REG[208],0
23B4: 3C CF 00 CMP   [CONFIGURED],0
23B7: B0 06    JNZ   0x23BE
23B9: 3C D0 00 CMP   [CONFIGURED+1],0
23BC: A0 09    JZ    0x23C6
(0412) 		TIMEOUT = 0;
(0413) 		
23BE: 43 02 1F OR    REG[2],31
(0414) 		// Start the transmitters.
23C1: 41 08 FE AND   REG[8],254
(0415) 		TX_014_Start(TX_014_PARITY_NONE);	// Transmits on P00, P01, and P04.
23C4: 80 07    JMP   0x23CC
(0416) 		TX_23_Start(TX_23_PARITY_NONE);		// Transmits on P02 and P03.
(0417) 		
(0418) 		TX_01234_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
23C6: 43 02 01 OR    REG[2],1
(0419) 		TX_01234_TIMEOUT_Start();			// Start the timer.
23C9: 43 08 01 OR    REG[8],1
(0420) 		
23CC: 20       POP   X
23CD: 7F       RET   
(0421) 		// Do nothing while we wait for one timeout period (1 ms).
(0422) 		// This is to allow everyone to get in the right configuration before talking.
(0423) 		while(!TIMEOUT) { }
(0424) 		
(0425) 		TX_01234_TIMEOUT_Stop();			// Stop the timer.
(0426) 		TIMEOUT = 0;						// Reset the timeout flag.
(0427) 	
_commandReady:
  i                    --> X+1
  tempByte             --> X+0
23CE: 10       PUSH  X
23CF: 4F       MOV   X,SP
23D0: 38 03    ADD   SP,3
(0428) 		// Set the current state.
23D2: 56 02 00 MOV   [X+2],0
23D5: 56 01 00 MOV   [X+1],0
(0429) 		STATE = MY_RESPONSE;
23D8: 56 00 00 MOV   [X+0],0
(0430) 	}
(0431) 	else if(mode == RESPONSE_1)
(0432) 	{
(0433) 		// Load the response wait on port 1.
23DB: 62 D0 00 MOV   REG[208],0
23DE: 3C CD 00 CMP   [STATE],0
23E1: B0 D4    JNZ   0x24B6
23E3: 3C CE 01 CMP   [STATE+1],1
23E6: B0 CF    JNZ   0x24B6
(0434) 		LoadConfig_response1();
(0435) 		
(0436) 		// Clear the timeout flag.
(0437) 		TIMEOUT = 0;
23E8: 10       PUSH  X
23E9: 7C 0D 91 LCALL 0x0D91
23EC: 62 D0 00 MOV   REG[208],0
23EF: 20       POP   X
23F0: 54 00    MOV   [X+0],A
(0438) 		
(0439) 		// Start listening for a response through child port 1.
(0440) 		CHILD_1_Start(CHILD_1_PARITY_NONE);
23F2: 3D 00 FC CMP   [X+0],252
23F5: B0 47    JNZ   0x243D
(0441) 		
23F7: 80 0B    JMP   0x2403
(0442) 		CHILD_1_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0443) 		CHILD_1_TIMEOUT_Start();			// Start the timer.
(0444) 		
(0445) 		// Set the current state.
23F9: 10       PUSH  X
23FA: 7C 0D 91 LCALL 0x0D91
23FD: 62 D0 00 MOV   REG[208],0
2400: 20       POP   X
2401: 54 00    MOV   [X+0],A
2403: 3D 00 FC CMP   [X+0],252
2406: AF F2    JZ    0x23F9
(0446) 		STATE = RESPONSE_1;
(0447) 	}
(0448) 	else if(mode == RESPONSE_2)
(0449) 	{
2408: 3D 00 00 CMP   [X+0],0
240B: B4 3F    JNZ   0x284B
(0450) 		// Load the response wait on port 2.
(0451) 		LoadConfig_response2();
240D: 52 00    MOV   A,[X+0]
240F: 62 D0 00 MOV   REG[208],0
2412: 53 E1    MOV   [COMMAND_SOURCE],A
(0452) 		
2414: 10       PUSH  X
2415: 7C 0D 91 LCALL 0x0D91
2418: 20       POP   X
2419: 62 D0 00 MOV   REG[208],0
241C: 53 E0    MOV   [COMMAND_DESTINATION],A
(0453) 		// Clear the timeout flag.
241E: 10       PUSH  X
241F: 7C 0D 91 LCALL 0x0D91
2422: 20       POP   X
2423: 62 D0 00 MOV   REG[208],0
2426: 53 DF    MOV   [COMMAND_TYPE],A
(0454) 		TIMEOUT = 0;
2428: 10       PUSH  X
2429: 7C 0D 91 LCALL 0x0D91
242C: 20       POP   X
242D: 62 D0 00 MOV   REG[208],0
2430: 53 DE    MOV   [COMMAND_PARAM],A
(0455) 		
(0456) 		// Start listening for a response through child port 2.
2432: 62 D0 00 MOV   REG[208],0
2435: 55 CB 01 MOV   [__r1],1
2438: 55 CC 00 MOV   [__r0],0
243B: 84 18    JMP   0x2854
(0457) 		CHILD_2_Start(CHILD_2_PARITY_NONE);
(0458) 		
(0459) 		CHILD_2_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
243D: 3D 00 FF CMP   [X+0],255
2440: B4 0A    JNZ   0x284B
(0460) 		CHILD_2_TIMEOUT_Start();			// Start the timer.
2442: 80 0B    JMP   0x244E
(0461) 		
(0462) 		// Set the current state.
(0463) 		STATE = RESPONSE_2;
(0464) 	}
2444: 10       PUSH  X
2445: 7C 0D 91 LCALL 0x0D91
2448: 62 D0 00 MOV   REG[208],0
244B: 20       POP   X
244C: 54 00    MOV   [X+0],A
244E: 3D 00 FF CMP   [X+0],255
2451: AF F2    JZ    0x2444
(0465) 	else if(mode == RESPONSE_3)
(0466) 	{
(0467) 		// Load the response wait on port 3.
(0468) 		LoadConfig_response3();
2453: 62 D0 00 MOV   REG[208],0
2456: 55 E1 00 MOV   [COMMAND_SOURCE],0
(0469) 		
(0470) 		// Clear the timeout flag.
2459: 52 00    MOV   A,[X+0]
245B: 62 D0 00 MOV   REG[208],0
245E: 53 E0    MOV   [COMMAND_DESTINATION],A
(0471) 		TIMEOUT = 0;
(0472) 		
2460: 10       PUSH  X
2461: 7C 0D 91 LCALL 0x0D91
2464: 62 D0 00 MOV   REG[208],0
2467: 20       POP   X
2468: 54 00    MOV   [X+0],A
(0473) 		// Start listening for a response through child port 3.
(0474) 		CHILD_3_Start(CHILD_3_PARITY_NONE);
(0475) 		
246A: 10       PUSH  X
246B: 7C 0D 91 LCALL 0x0D91
246E: 20       POP   X
246F: 62 D0 00 MOV   REG[208],0
2472: 53 DF    MOV   [COMMAND_TYPE],A
(0476) 		CHILD_3_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0477) 		CHILD_3_TIMEOUT_Start();			// Start the timer.
(0478) 		
2474: 56 02 00 MOV   [X+2],0
2477: 56 01 00 MOV   [X+1],0
247A: 80 0E    JMP   0x2489
(0479) 		// Set the current state.
(0480) 		STATE = RESPONSE_3;
247C: 10       PUSH  X
247D: 7C 0D 91 LCALL 0x0D91
2480: 62 D0 00 MOV   REG[208],0
2483: 20       POP   X
2484: 77 02    INC   [X+2]
2486: 0F 01 00 ADC   [X+1],0
2489: 62 D0 00 MOV   REG[208],0
248C: 52 00    MOV   A,[X+0]
248E: 53 CB    MOV   [__r1],A
2490: 55 CC 00 MOV   [__r0],0
2493: 16 CB 01 SUB   [__r1],1
2496: 1E CC 00 SBB   [__r0],0
2499: 52 02    MOV   A,[X+2]
249B: 12 CB    SUB   A,[__r1]
249D: 51 CC    MOV   A,[__r0]
249F: 31 80    XOR   A,128
24A1: 53 CA    MOV   [__rX],A
24A3: 52 01    MOV   A,[X+1]
24A5: 31 80    XOR   A,128
24A7: 1A CA    SBB   A,[__rX]
24A9: CF D2    JC    0x247C
(0481) 	}
(0482) 	else if(mode == RESPONSE_4)
(0483) 	{
24AB: 62 D0 00 MOV   REG[208],0
24AE: 55 CB 01 MOV   [__r1],1
24B1: 55 CC 00 MOV   [__r0],0
24B4: 83 9F    JMP   0x2854
(0484) 		// Load the response wait on port 4.
(0485) 		LoadConfig_response4();
(0486) 		
24B6: 62 D0 00 MOV   REG[208],0
24B9: 3C CD 00 CMP   [STATE],0
24BC: B0 6E    JNZ   0x252B
24BE: 3C CE 07 CMP   [STATE+1],7
24C1: B0 69    JNZ   0x252B
(0487) 		// Clear the timeout flag.
(0488) 		TIMEOUT = 0;
(0489) 		
24C3: 10       PUSH  X
24C4: 7C 19 5A LCALL 0x195A
24C7: 20       POP   X
24C8: 39 FC    CMP   A,252
24CA: B0 12    JNZ   0x24DD
(0490) 		// Start listening for a response through child port 4.
(0491) 		CHILD_4_Start(CHILD_4_PARITY_NONE);
24CC: 62 D0 00 MOV   REG[208],0
24CF: 55 E3 41 MOV   [CHILD],65
(0492) 		
(0493) 		CHILD_4_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
24D2: 62 D0 00 MOV   REG[208],0
24D5: 55 CB 01 MOV   [__r1],1
24D8: 55 CC 00 MOV   [__r0],0
24DB: 83 78    JMP   0x2854
(0494) 		CHILD_4_TIMEOUT_Start();			// Start the timer.
(0495) 		
24DD: 10       PUSH  X
24DE: 7C 18 01 LCALL 0x1801
24E1: 20       POP   X
24E2: 39 FC    CMP   A,252
24E4: B0 12    JNZ   0x24F7
(0496) 		// Set the current state.
(0497) 		STATE = RESPONSE_4;
24E6: 62 D0 00 MOV   REG[208],0
24E9: 55 E3 42 MOV   [CHILD],66
(0498) 	}
(0499) 	else if(mode == HELLO_MODE)
24EC: 62 D0 00 MOV   REG[208],0
24EF: 55 CB 01 MOV   [__r1],1
24F2: 55 CC 00 MOV   [__r0],0
24F5: 83 5E    JMP   0x2854
(0500) 	{
(0501) 		// Load the hello wait mode.  This is for listening on all ports for a hello response.
24F7: 10       PUSH  X
24F8: 7C 16 A8 LCALL 0x16A8
24FB: 20       POP   X
24FC: 39 FC    CMP   A,252
24FE: B0 12    JNZ   0x2511
(0502) 		LoadConfig_hello();
(0503) 		
2500: 62 D0 00 MOV   REG[208],0
2503: 55 E3 43 MOV   [CHILD],67
(0504) 		// Clear the timeout flag.
(0505) 		TIMEOUT = 0;
2506: 62 D0 00 MOV   REG[208],0
2509: 55 CB 01 MOV   [__r1],1
250C: 55 CC 00 MOV   [__r0],0
250F: 83 44    JMP   0x2854
(0506) 		
(0507) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
2511: 10       PUSH  X
2512: 7C 15 4F LCALL 0x154F
2515: 20       POP   X
2516: 39 FC    CMP   A,252
2518: B3 32    JNZ   0x284B
(0508) 	
(0509) 		{
251A: 62 D0 00 MOV   REG[208],0
251D: 55 E3 44 MOV   [CHILD],68
(0510) 		// Start listening for a response through child port 1.
(0511) 		HELLO_1_Start(HELLO_1_PARITY_NONE);
2520: 62 D0 00 MOV   REG[208],0
2523: 55 CB 01 MOV   [__r1],1
2526: 55 CC 00 MOV   [__r0],0
2529: 83 2A    JMP   0x2854
(0512) 		}
(0513) 		
(0514) 		{
252B: 62 D0 00 MOV   REG[208],0
252E: 3C CD 00 CMP   [STATE],0
2531: B0 AB    JNZ   0x25DD
2533: 3C CE 03 CMP   [STATE+1],3
2536: B0 A6    JNZ   0x25DD
(0515) 		// Start listening for a response through child port 2.
(0516) 		HELLO_2_Start(HELLO_2_PARITY_NONE);
2538: 10       PUSH  X
2539: 7C 20 3E LCALL 0x203E
253C: 62 D0 00 MOV   REG[208],0
253F: 20       POP   X
2540: 54 00    MOV   [X+0],A
2542: 39 00    CMP   A,0
2544: A3 06    JZ    0x284B
(0517) 		}
(0518) 		
2546: 3D 00 FF CMP   [X+0],255
2549: B0 69    JNZ   0x25B3
(0519) 		{
254B: 80 58    JMP   0x25A4
(0520) 		// Start listening for a response through child port 3.
(0521) 		HELLO_3_Start(HELLO_3_PARITY_NONE);
(0522) 		}
(0523) 		
254D: 10       PUSH  X
254E: 7C 20 3E LCALL 0x203E
2551: 62 D0 00 MOV   REG[208],0
2554: 20       POP   X
2555: 39 FF    CMP   A,255
2557: B0 4C    JNZ   0x25A4
(0524) 		{
(0525) 		// Start listening for a response through child port 4.
(0526) 		HELLO_4_Start(HELLO_4_PARITY_NONE);
2559: 10       PUSH  X
255A: 7C 20 36 LCALL 0x2036
255D: 62 D0 00 MOV   REG[208],0
2560: 20       POP   X
(0527) 		}
(0528) 		
(0529) 		HELLO_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
2561: 10       PUSH  X
2562: 7C 20 36 LCALL 0x2036
2565: 62 D0 00 MOV   REG[208],0
2568: 20       POP   X
2569: 54 00    MOV   [X+0],A
(0530) 		HELLO_TIMEOUT_Start();		// Start the timer.
(0531) 		
(0532) 		// Set the current state.
256B: 56 02 00 MOV   [X+2],0
256E: 56 01 00 MOV   [X+1],0
2571: 80 0E    JMP   0x2580
(0533) 		STATE = HELLO_MODE;
(0534) 	}
2573: 10       PUSH  X
2574: 7C 20 36 LCALL 0x2036
2577: 62 D0 00 MOV   REG[208],0
257A: 20       POP   X
257B: 77 02    INC   [X+2]
257D: 0F 01 00 ADC   [X+1],0
2580: 62 D0 00 MOV   REG[208],0
2583: 52 00    MOV   A,[X+0]
2585: 53 CB    MOV   [__r1],A
2587: 52 02    MOV   A,[X+2]
2589: 12 CB    SUB   A,[__r1]
258B: 50 00    MOV   A,0
258D: 31 80    XOR   A,128
258F: 53 CA    MOV   [__rX],A
2591: 52 01    MOV   A,[X+1]
2593: 31 80    XOR   A,128
2595: 1A CA    SBB   A,[__rX]
2597: CF DB    JC    0x2573
(0535) 	else if(mode == INITIALIZE)
(0536) 	{
(0537) 		// Load the configuration for initialization.  This config listens but does not forward.
2599: 62 D0 00 MOV   REG[208],0
259C: 55 CB 01 MOV   [__r1],1
259F: 55 CC 00 MOV   [__r0],0
25A2: 82 B1    JMP   0x2854
25A4: 62 D0 00 MOV   REG[208],0
25A7: 3C D1 00 CMP   [TIMEOUT],0
25AA: B0 06    JNZ   0x25B1
25AC: 3C D2 00 CMP   [TIMEOUT+1],0
25AF: AF 9D    JZ    0x254D
(0538) 		LoadConfig_initial();
(0539) 		
(0540) 		// Clear the timeout flag.
25B1: 82 99    JMP   0x284B
(0541) 		TIMEOUT = 0;
25B3: 3D 00 FC CMP   [X+0],252
25B6: B2 94    JNZ   0x284B
(0542) 		
25B8: 80 15    JMP   0x25CE
(0543) 		// Start the receiver.
(0544) 		INIT_RX_Start(INIT_RX_PARITY_NONE);
(0545) 		
(0546) 		INIT_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
25BA: 10       PUSH  X
25BB: 7C 20 3E LCALL 0x203E
25BE: 62 D0 00 MOV   REG[208],0
25C1: 20       POP   X
25C2: 39 FD    CMP   A,253
25C4: B0 09    JNZ   0x25CE
(0547) 		INIT_TIMEOUT_Start();		// Start the timer.
(0548) 		
25C6: 55 CB 01 MOV   [__r1],1
25C9: 55 CC 00 MOV   [__r0],0
25CC: 82 87    JMP   0x2854
25CE: 62 D0 00 MOV   REG[208],0
25D1: 3C D1 00 CMP   [TIMEOUT],0
25D4: B0 06    JNZ   0x25DB
25D6: 3C D2 00 CMP   [TIMEOUT+1],0
25D9: AF E0    JZ    0x25BA
(0549) 		// Set the current state.
(0550) 		STATE = INITIALIZE;
(0551) 	}
(0552) 	else if(mode == SERVO_COMM)
(0553) 	{
25DB: 82 6F    JMP   0x284B
(0554) 		// Load the configuration for servo communication.  This config only transmits on P00.
25DD: 62 D0 00 MOV   REG[208],0
25E0: 3C CD 00 CMP   [STATE],0
25E3: B0 AB    JNZ   0x268F
25E5: 3C CE 04 CMP   [STATE+1],4
25E8: B0 A6    JNZ   0x268F
(0555) 		LoadConfig_servo_transmit();
(0556) 		
25EA: 10       PUSH  X
25EB: 7C 1E 85 LCALL 0x1E85
25EE: 62 D0 00 MOV   REG[208],0
25F1: 20       POP   X
25F2: 54 00    MOV   [X+0],A
25F4: 39 00    CMP   A,0
25F6: A2 54    JZ    0x284B
(0557) 		// Clear the timeout flag.
(0558) 		TIMEOUT = 0;
25F8: 3D 00 FF CMP   [X+0],255
25FB: B0 69    JNZ   0x2665
(0559) 		
25FD: 80 58    JMP   0x2656
(0560) 		// Start the transmitter.
(0561) 		SERVO_TX_Start(SERVO_TX_PARITY_NONE);
(0562) 	
(0563) 		// Set the current state.
25FF: 10       PUSH  X
2600: 7C 1E 85 LCALL 0x1E85
2603: 62 D0 00 MOV   REG[208],0
2606: 20       POP   X
2607: 39 FF    CMP   A,255
2609: B0 4C    JNZ   0x2656
(0564) 		STATE = SERVO_COMM;
(0565) 	}
(0566) 	
260B: 10       PUSH  X
260C: 7C 1E 7D LCALL 0x1E7D
260F: 62 D0 00 MOV   REG[208],0
2612: 20       POP   X
(0567) 	// If this module is configured, talk on all pins for potential children.
(0568) 	if(CONFIGURED)
(0569) 	{
2613: 10       PUSH  X
2614: 7C 1E 7D LCALL 0x1E7D
2617: 62 D0 00 MOV   REG[208],0
261A: 20       POP   X
261B: 54 00    MOV   [X+0],A
(0570) 		PRT0GS |= 0b00011111;	// Connect all pins to the global bus.
(0571) 		PRT2DR &= 0b11111110;	// Turn on the LED (active low).
(0572) 	}
261D: 56 02 00 MOV   [X+2],0
2620: 56 01 00 MOV   [X+1],0
2623: 80 0E    JMP   0x2632
(0573) 	else
(0574) 	{
2625: 10       PUSH  X
2626: 7C 1E 7D LCALL 0x1E7D
2629: 62 D0 00 MOV   REG[208],0
262C: 20       POP   X
262D: 77 02    INC   [X+2]
262F: 0F 01 00 ADC   [X+1],0
2632: 62 D0 00 MOV   REG[208],0
2635: 52 00    MOV   A,[X+0]
2637: 53 CB    MOV   [__r1],A
2639: 52 02    MOV   A,[X+2]
263B: 12 CB    SUB   A,[__r1]
263D: 50 00    MOV   A,0
263F: 31 80    XOR   A,128
2641: 53 CA    MOV   [__rX],A
2643: 52 01    MOV   A,[X+1]
2645: 31 80    XOR   A,128
2647: 1A CA    SBB   A,[__rX]
2649: CF DB    JC    0x2625
(0575) 		PRT0GS |= 0b00000001;	// Just connect pin 0;
(0576) 		PRT2DR |= 0b00000001;	// Turn off the LED (active low).
(0577) 	}
264B: 62 D0 00 MOV   REG[208],0
264E: 55 CB 01 MOV   [__r1],1
2651: 55 CC 00 MOV   [__r0],0
2654: 81 FF    JMP   0x2854
2656: 62 D0 00 MOV   REG[208],0
2659: 3C D1 00 CMP   [TIMEOUT],0
265C: B0 06    JNZ   0x2663
265E: 3C D2 00 CMP   [TIMEOUT+1],0
2661: AF 9D    JZ    0x25FF
(0578) }
(0579) 
(0580) // This function tries to peek and see if a start byte has been written to the bus.
2663: 81 E7    JMP   0x284B
(0581) // If there is no start byte, the function exits.  If a start byte is detected, the function
2665: 3D 00 FC CMP   [X+0],252
2668: B1 E2    JNZ   0x284B
(0582) // blocks and waits for the transmission to finish.
266A: 80 15    JMP   0x2680
(0583) int commandReady(void)
(0584) {
(0585) 	int i = 0;			// This integer is used for looping through the remaining bytes of commands.
(0586) 	char tempByte = 0;	// This byte is used to store each byte for comparison as it comes in.
266C: 10       PUSH  X
266D: 7C 1E 85 LCALL 0x1E85
2670: 62 D0 00 MOV   REG[208],0
2673: 20       POP   X
2674: 39 FD    CMP   A,253
2676: B0 09    JNZ   0x2680
(0587) 	
(0588) 	// This conditional checks which configuration is loaded and uses the proper devices to
2678: 55 CB 01 MOV   [__r1],1
267B: 55 CC 00 MOV   [__r0],0
267E: 81 D5    JMP   0x2854
2680: 62 D0 00 MOV   REG[208],0
2683: 3C D1 00 CMP   [TIMEOUT],0
2686: B0 06    JNZ   0x268D
2688: 3C D2 00 CMP   [TIMEOUT+1],0
268B: AF E0    JZ    0x266C
(0589) 	// read a transmission and store the important information from that transmission.
(0590) 	if(STATE == WAIT)
(0591) 	{	
(0592) 		// In wait mode, the only thing that progresses things forward is a master node transmission.
(0593) 		// With this being the case, we use a blocking operation to sit and wait for a byte.
268D: 81 BD    JMP   0x284B
(0594) 		tempByte = WAIT_RECV_cGetChar();
268F: 62 D0 00 MOV   REG[208],0
2692: 3C CD 00 CMP   [STATE],0
2695: B0 AB    JNZ   0x2741
2697: 3C CE 05 CMP   [STATE+1],5
269A: B0 A6    JNZ   0x2741
(0595) 		
(0596) 		// If a transmission has started for either a controller or a servo...
269C: 10       PUSH  X
269D: 7C 1C CC LCALL 0x1CCC
26A0: 62 D0 00 MOV   REG[208],0
26A3: 20       POP   X
26A4: 54 00    MOV   [X+0],A
26A6: 39 00    CMP   A,0
26A8: A1 A2    JZ    0x284B
(0597) 		if(tempByte == START_TRANSMIT)
(0598) 		{
26AA: 3D 00 FF CMP   [X+0],255
26AD: B0 69    JNZ   0x2717
(0599) 			// While we keep reading start bytes, sit and spin.
26AF: 80 58    JMP   0x2708
(0600) 			while(tempByte == START_TRANSMIT)
(0601) 			{
(0602) 				tempByte = WAIT_RECV_cGetChar();
(0603) 			}
26B1: 10       PUSH  X
26B2: 7C 1C CC LCALL 0x1CCC
26B5: 62 D0 00 MOV   REG[208],0
26B8: 20       POP   X
26B9: 39 FF    CMP   A,255
26BB: B0 4C    JNZ   0x2708
(0604) 			
(0605) 			// The tempByte variable contains the source ID.  If the source is good, store all bytes.
(0606) 			if(tempByte == MASTER_ID)
26BD: 10       PUSH  X
26BE: 7C 1C C4 LCALL 0x1CC4
26C1: 62 D0 00 MOV   REG[208],0
26C4: 20       POP   X
(0607) 			{
(0608) 				COMMAND_SOURCE = tempByte;
(0609) 				COMMAND_DESTINATION = WAIT_RECV_cGetChar();
26C5: 10       PUSH  X
26C6: 7C 1C C4 LCALL 0x1CC4
26C9: 62 D0 00 MOV   REG[208],0
26CC: 20       POP   X
26CD: 54 00    MOV   [X+0],A
(0610) 				COMMAND_TYPE = WAIT_RECV_cGetChar();
(0611) 				COMMAND_PARAM = WAIT_RECV_cGetChar();
(0612) 				
26CF: 56 02 00 MOV   [X+2],0
26D2: 56 01 00 MOV   [X+1],0
26D5: 80 0E    JMP   0x26E4
(0613) 				return 1;
(0614) 			}
26D7: 10       PUSH  X
26D8: 7C 1C C4 LCALL 0x1CC4
26DB: 62 D0 00 MOV   REG[208],0
26DE: 20       POP   X
26DF: 77 02    INC   [X+2]
26E1: 0F 01 00 ADC   [X+1],0
26E4: 62 D0 00 MOV   REG[208],0
26E7: 52 00    MOV   A,[X+0]
26E9: 53 CB    MOV   [__r1],A
26EB: 52 02    MOV   A,[X+2]
26ED: 12 CB    SUB   A,[__r1]
26EF: 50 00    MOV   A,0
26F1: 31 80    XOR   A,128
26F3: 53 CA    MOV   [__rX],A
26F5: 52 01    MOV   A,[X+1]
26F7: 31 80    XOR   A,128
26F9: 1A CA    SBB   A,[__rX]
26FB: CF DB    JC    0x26D7
(0615) 		}
(0616) 		else if(tempByte == SERVO_START)
(0617) 		{
26FD: 62 D0 00 MOV   REG[208],0
2700: 55 CB 01 MOV   [__r1],1
2703: 55 CC 00 MOV   [__r0],0
2706: 81 4D    JMP   0x2854
2708: 62 D0 00 MOV   REG[208],0
270B: 3C D1 00 CMP   [TIMEOUT],0
270E: B0 06    JNZ   0x2715
2710: 3C D2 00 CMP   [TIMEOUT+1],0
2713: AF 9D    JZ    0x26B1
(0618) 			// While we keep reading start bytes, sit and spin.
(0619) 			while(tempByte == SERVO_START)
(0620) 			{
2715: 81 35    JMP   0x284B
(0621) 				tempByte = WAIT_RECV_cGetChar();
2717: 3D 00 FC CMP   [X+0],252
271A: B1 30    JNZ   0x284B
(0622) 			}
271C: 80 15    JMP   0x2732
(0623) 			
(0624) 			// We assume (and hopefully rightly so) that this is a command from master.
(0625) 			COMMAND_SOURCE = MASTER_ID;
(0626) 			// The first parameter after the servo start is the destination.
271E: 10       PUSH  X
271F: 7C 1C CC LCALL 0x1CCC
2722: 62 D0 00 MOV   REG[208],0
2725: 20       POP   X
2726: 39 FD    CMP   A,253
2728: B0 09    JNZ   0x2732
(0627) 			COMMAND_DESTINATION = tempByte;
(0628) 			// The second parameter after the servo start is the command length.
272A: 55 CB 01 MOV   [__r1],1
272D: 55 CC 00 MOV   [__r0],0
2730: 81 23    JMP   0x2854
2732: 62 D0 00 MOV   REG[208],0
2735: 3C D1 00 CMP   [TIMEOUT],0
2738: B0 06    JNZ   0x273F
273A: 3C D2 00 CMP   [TIMEOUT+1],0
273D: AF E0    JZ    0x271E
(0629) 			tempByte = WAIT_RECV_cGetChar();
(0630) 			// Now we store the command type.  Depending on what the status return level
(0631) 			// is, we have special duties.
(0632) 			COMMAND_TYPE = WAIT_RECV_cGetChar();
(0633) 			
273F: 81 0B    JMP   0x284B
(0634) 			// This basically waits for the rest of the command to pass through.
2741: 62 D0 00 MOV   REG[208],0
2744: 3C CD 00 CMP   [STATE],0
2747: B0 AB    JNZ   0x27F3
2749: 3C CE 06 CMP   [STATE+1],6
274C: B0 A6    JNZ   0x27F3
(0635) 			for(i = 0; i < (tempByte - 1); i++)
(0636) 			{
274E: 10       PUSH  X
274F: 7C 1B 13 LCALL 0x1B13
2752: 62 D0 00 MOV   REG[208],0
2755: 20       POP   X
2756: 54 00    MOV   [X+0],A
2758: 39 00    CMP   A,0
275A: A0 F0    JZ    0x284B
(0637) 				WAIT_RECV_cGetChar();
(0638) 			}
275C: 3D 00 FF CMP   [X+0],255
275F: B0 69    JNZ   0x27C9
(0639) 				
2761: 80 58    JMP   0x27BA
(0640) 			return 1;
(0641) 		}
(0642) 	}
(0643) 	else if(STATE == HELLO_MODE)
2763: 10       PUSH  X
2764: 7C 1B 13 LCALL 0x1B13
2767: 62 D0 00 MOV   REG[208],0
276A: 20       POP   X
276B: 39 FF    CMP   A,255
276D: B0 4C    JNZ   0x27BA
(0644) 	{
(0645) 		// Check all of the ports for a start byte.  Only one port will produce one.
(0646) 		if(HELLO_1_cReadChar() == START_TRANSMIT)
276F: 10       PUSH  X
2770: 7C 1B 0B LCALL 0x1B0B
2773: 62 D0 00 MOV   REG[208],0
2776: 20       POP   X
(0647) 		{		
(0648) 			CHILD = PORT_A;
(0649) 			
2777: 10       PUSH  X
2778: 7C 1B 0B LCALL 0x1B0B
277B: 62 D0 00 MOV   REG[208],0
277E: 20       POP   X
277F: 54 00    MOV   [X+0],A
(0650) 			return 1;
(0651) 		}
(0652) 		else if(HELLO_2_cReadChar() == START_TRANSMIT)
2781: 56 02 00 MOV   [X+2],0
2784: 56 01 00 MOV   [X+1],0
2787: 80 0E    JMP   0x2796
(0653) 		{		
(0654) 			CHILD = PORT_B;
2789: 10       PUSH  X
278A: 7C 1B 0B LCALL 0x1B0B
278D: 62 D0 00 MOV   REG[208],0
2790: 20       POP   X
2791: 77 02    INC   [X+2]
2793: 0F 01 00 ADC   [X+1],0
2796: 62 D0 00 MOV   REG[208],0
2799: 52 00    MOV   A,[X+0]
279B: 53 CB    MOV   [__r1],A
279D: 52 02    MOV   A,[X+2]
279F: 12 CB    SUB   A,[__r1]
27A1: 50 00    MOV   A,0
27A3: 31 80    XOR   A,128
27A5: 53 CA    MOV   [__rX],A
27A7: 52 01    MOV   A,[X+1]
27A9: 31 80    XOR   A,128
27AB: 1A CA    SBB   A,[__rX]
27AD: CF DB    JC    0x2789
(0655) 			
(0656) 			return 1;
(0657) 		}
27AF: 62 D0 00 MOV   REG[208],0
27B2: 55 CB 01 MOV   [__r1],1
27B5: 55 CC 00 MOV   [__r0],0
27B8: 80 9B    JMP   0x2854
27BA: 62 D0 00 MOV   REG[208],0
27BD: 3C D1 00 CMP   [TIMEOUT],0
27C0: B0 06    JNZ   0x27C7
27C2: 3C D2 00 CMP   [TIMEOUT+1],0
27C5: AF 9D    JZ    0x2763
(0658) 		else if(HELLO_3_cReadChar() == START_TRANSMIT)
(0659) 		{
(0660) 			CHILD = PORT_C;
27C7: 80 83    JMP   0x284B
(0661) 			
27C9: 3D 00 FC CMP   [X+0],252
27CC: B0 7E    JNZ   0x284B
(0662) 			return 1;
27CE: 80 15    JMP   0x27E4
(0663) 		}
(0664) 		else if(HELLO_4_cReadChar() == START_TRANSMIT)
(0665) 		{
(0666) 			CHILD = PORT_D;
27D0: 10       PUSH  X
27D1: 7C 1B 13 LCALL 0x1B13
27D4: 62 D0 00 MOV   REG[208],0
27D7: 20       POP   X
27D8: 39 FD    CMP   A,253
27DA: B0 09    JNZ   0x27E4
(0667) 			
(0668) 			return 1;
27DC: 55 CB 01 MOV   [__r1],1
27DF: 55 CC 00 MOV   [__r0],0
27E2: 80 71    JMP   0x2854
27E4: 62 D0 00 MOV   REG[208],0
27E7: 3C D1 00 CMP   [TIMEOUT],0
27EA: B0 06    JNZ   0x27F1
27EC: 3C D2 00 CMP   [TIMEOUT+1],0
27EF: AF E0    JZ    0x27D0
(0669) 		}
(0670) 	}
(0671) 	else if(STATE == RESPONSE_1)
(0672) 	{
(0673) 		if(tempByte = CHILD_1_cReadChar())
27F1: 80 59    JMP   0x284B
(0674) 		{
27F3: 62 D0 00 MOV   REG[208],0
27F6: 3C CD 00 CMP   [STATE],0
27F9: B0 51    JNZ   0x284B
27FB: 3C CE 08 CMP   [STATE+1],8
27FE: B0 4C    JNZ   0x284B
(0675) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0676) 			{
2800: 10       PUSH  X
2801: 7C 13 96 LCALL 0x1396
2804: 62 D0 00 MOV   REG[208],0
2807: 20       POP   X
2808: 39 FF    CMP   A,255
280A: B0 40    JNZ   0x284B
(0677) 				while(!TIMEOUT)
(0678) 				{
(0679) 					// Check for the second start byte.
280C: 10       PUSH  X
280D: 7C 13 8E LCALL 0x138E
2810: 62 D0 00 MOV   REG[208],0
2813: 20       POP   X
2814: 39 FF    CMP   A,255
2816: B0 34    JNZ   0x284B
(0680) 					if(CHILD_1_cReadChar() == SERVO_START)
(0681) 					{
(0682) 						// Burn the ID, since we don't care what it is.
(0683) 						CHILD_1_cGetChar();
2818: 10       PUSH  X
2819: 7C 13 8E LCALL 0x138E
281C: 20       POP   X
281D: 62 D0 00 MOV   REG[208],0
2820: 53 E1    MOV   [COMMAND_SOURCE],A
(0684) 						
2822: 10       PUSH  X
2823: 7C 13 8E LCALL 0x138E
2826: 20       POP   X
2827: 62 D0 00 MOV   REG[208],0
282A: 53 DD    MOV   [COMMAND_LENGTH],A
(0685) 						// We store the length, since it is the next byte from the servo.
282C: 10       PUSH  X
282D: 7C 13 8E LCALL 0x138E
2830: 20       POP   X
2831: 62 D0 00 MOV   REG[208],0
2834: 53 DC    MOV   [COMMAND_ERROR],A
(0686) 						tempByte = CHILD_1_cGetChar();
2836: 10       PUSH  X
2837: 7C 13 8E LCALL 0x138E
283A: 20       POP   X
283B: 62 D0 00 MOV   REG[208],0
283E: 53 DE    MOV   [COMMAND_PARAM],A
(0687) 						
(0688) 						// This basically waits for the rest of the command to pass through.
2840: 62 D0 00 MOV   REG[208],0
2843: 55 CB 01 MOV   [__r1],1
2846: 55 CC 00 MOV   [__r0],0
2849: 80 0A    JMP   0x2854
(0689) 						for(i = 0; i < tempByte; i++)
(0690) 						{
(0691) 							CHILD_1_cGetChar();
(0692) 						}
(0693) 						
284B: 62 D0 00 MOV   REG[208],0
284E: 55 CB 00 MOV   [__r1],0
2851: 55 CC 00 MOV   [__r0],0
2854: 38 FD    ADD   SP,253
2856: 20       POP   X
2857: 7F       RET   
(0694) 						return 1;
(0695) 					}
(0696) 				}
(0697) 			}
(0698) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
(0699) 			{
_takeAction:
  j                    --> X+5
  i                    --> X+3
  tempByte             --> X+2
  i                    --> X+0
2858: 10       PUSH  X
2859: 4F       MOV   X,SP
285A: 38 07    ADD   SP,7
(0700) 				while(!TIMEOUT)
285C: 56 01 00 MOV   [X+1],0
285F: 56 00 00 MOV   [X+0],0
(0701) 				{
2862: 56 02 00 MOV   [X+2],0
(0702) 					// We simply wait for the end transmit indicator.
(0703) 					if(CHILD_1_cReadChar() == END_TRANSMIT)
2865: 62 D0 00 MOV   REG[208],0
2868: 3C DF C8 CMP   [COMMAND_TYPE],200
286B: B0 39    JNZ   0x28A5
(0704) 					{
(0705) 						return 1;
286D: 62 D0 00 MOV   REG[208],0
2870: 3C CF 00 CMP   [CONFIGURED],0
2873: B0 0A    JNZ   0x287E
2875: 3C D0 00 CMP   [CONFIGURED+1],0
2878: B0 05    JNZ   0x287E
(0706) 					}
(0707) 				}
(0708) 			}
287A: 98 D7    CALL  _sayHello
(0709) 		}
287C: 82 41    JMP   0x2ABE
(0710) 	}
287E: 62 D0 00 MOV   REG[208],0
2881: 3C E3 00 CMP   [CHILD],0
2884: B0 14    JNZ   0x2899
(0711) 	else if(STATE == RESPONSE_2)
(0712) 	{
(0713) 		if(tempByte = CHILD_2_cReadChar())
2886: 94 BC    CALL  _childListen
2888: 62 D0 00 MOV   REG[208],0
288B: 3C CC 00 CMP   [__r0],0
288E: B0 06    JNZ   0x2895
2890: 3C CB 00 CMP   [__r1],0
2893: A2 2A    JZ    0x2ABE
(0714) 		{
(0715) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0716) 			{
2895: 98 BC    CALL  _sayHello
(0717) 				while(!TIMEOUT)
(0718) 				{
2897: 82 26    JMP   0x2ABE
(0719) 					// Check for the second start byte.
2899: 62 D0 00 MOV   REG[208],0
289C: 3C E3 00 CMP   [CHILD],0
289F: A2 1E    JZ    0x2ABE
(0720) 					if(CHILD_2_cReadChar() == SERVO_START)
(0721) 					{
(0722) 						// Burn the ID, since we don't care what it is.
28A1: 94 F9    CALL  _childResponse
(0723) 						CHILD_2_cGetChar();
(0724) 						
28A3: 82 1A    JMP   0x2ABE
(0725) 						// We store the length, since it is the next byte from the servo.
28A5: 62 D0 00 MOV   REG[208],0
28A8: 3C DF CB CMP   [COMMAND_TYPE],203
28AB: B0 21    JNZ   0x28CD
(0726) 						tempByte = CHILD_2_cGetChar();
(0727) 						
(0728) 						// This basically waits for the rest of the command to pass through.
28AD: 62 D0 00 MOV   REG[208],0
28B0: 51 E0    MOV   A,[COMMAND_DESTINATION]
28B2: 62 D0 00 MOV   REG[208],0
28B5: 3A E2    CMP   A,[ID]
28B7: B0 05    JNZ   0x28BD
(0729) 						for(i = 0; i < tempByte; i++)
(0730) 						{
(0731) 							CHILD_2_cGetChar();
28B9: 92 A6    CALL  _pingResponse
(0732) 						}
28BB: 82 02    JMP   0x2ABE
(0733) 						
28BD: 62 D0 00 MOV   REG[208],0
28C0: 51 E2    MOV   A,[ID]
28C2: 62 D0 00 MOV   REG[208],0
28C5: 3A E0    CMP   A,[COMMAND_DESTINATION]
28C7: D1 F6    JNC   0x2ABE
(0734) 						return 1;
(0735) 					}
(0736) 				}
28C9: 94 D1    CALL  _childResponse
(0737) 			}
(0738) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
28CB: 81 F2    JMP   0x2ABE
(0739) 			{
28CD: 62 D0 00 MOV   REG[208],0
28D0: 3C DF C9 CMP   [COMMAND_TYPE],201
28D3: B1 11    JNZ   0x29E5
(0740) 				while(!TIMEOUT)
(0741) 				{
(0742) 					// We simply wait for the end transmit indicator.
28D5: 62 D0 00 MOV   REG[208],0
28D8: 51 E0    MOV   A,[COMMAND_DESTINATION]
28DA: 62 D0 00 MOV   REG[208],0
28DD: 3A E2    CMP   A,[ID]
28DF: B0 F5    JNZ   0x29D5
(0743) 					if(CHILD_2_cReadChar() == END_TRANSMIT)
(0744) 					{
28E1: 62 D0 00 MOV   REG[208],0
28E4: 50 00    MOV   A,0
28E6: 3A DE    CMP   A,[COMMAND_PARAM]
28E8: D1 D5    JNC   0x2ABE
28EA: 62 D0 00 MOV   REG[208],0
28ED: 3C DE FB CMP   [COMMAND_PARAM],251
28F0: D1 CD    JNC   0x2ABE
(0745) 						return 1;
(0746) 					}
(0747) 				}
28F2: 62 D0 00 MOV   REG[208],0
28F5: 51 DE    MOV   A,[COMMAND_PARAM]
28F7: 62 D0 00 MOV   REG[208],0
28FA: 53 E2    MOV   [ID],A
(0748) 			}
(0749) 		}
(0750) 	}
28FC: 62 D0 00 MOV   REG[208],0
28FF: 55 D0 01 MOV   [CONFIGURED+1],1
2902: 55 CF 00 MOV   [CONFIGURED],0
(0751) 	else if(STATE == RESPONSE_3)
(0752) 	{
(0753) 		if(tempByte = CHILD_3_cReadChar())
2905: 62 D0 00 MOV   REG[208],0
2908: 51 E2    MOV   A,[ID]
290A: 62 D0 00 MOV   REG[208],0
290D: 3A E6    CMP   A,[SERVO_ID]
290F: A0 A8    JZ    0x29B8
(0754) 		{
(0755) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0756) 			{
(0757) 				while(!TIMEOUT)
(0758) 				{
(0759) 					// Check for the second start byte.
(0760) 					if(CHILD_3_cReadChar() == SERVO_START)
(0761) 					{
2911: 56 06 00 MOV   [X+6],0
2914: 56 05 00 MOV   [X+5],0
(0762) 						// Burn the ID, since we don't care what it is.
(0763) 						CHILD_3_cGetChar();
(0764) 						
2917: 62 D0 00 MOV   REG[208],0
291A: 51 E2    MOV   A,[ID]
291C: 08       PUSH  A
291D: 50 03    MOV   A,3
291F: 08       PUSH  A
2920: 08       PUSH  A
2921: 50 04    MOV   A,4
2923: 08       PUSH  A
2924: 62 D0 00 MOV   REG[208],0
2927: 51 E6    MOV   A,[SERVO_ID]
2929: 08       PUSH  A
292A: 97 26    CALL  _servoInstruction
292C: 38 FB    ADD   SP,251
(0765) 						// We store the length, since it is the next byte from the servo.
(0766) 						tempByte = CHILD_3_cGetChar();
(0767) 						
292E: 56 04 00 MOV   [X+4],0
2931: 56 03 00 MOV   [X+3],0
(0768) 						// This basically waits for the rest of the command to pass through.
(0769) 						for(i = 0; i < tempByte; i++)
(0770) 						{
2934: 50 00    MOV   A,0
2936: 08       PUSH  A
2937: 08       PUSH  A
2938: 50 01    MOV   A,1
293A: 08       PUSH  A
293B: 50 02    MOV   A,2
293D: 08       PUSH  A
293E: 50 FE    MOV   A,254
2940: 08       PUSH  A
2941: 97 0F    CALL  _servoInstruction
2943: 38 FB    ADD   SP,251
2945: 80 43    JMP   0x2989
(0771) 							CHILD_3_cGetChar();
(0772) 						}
(0773) 						
(0774) 						return 1;
(0775) 					}
(0776) 				}
2947: 9A 85    CALL  _commandReady
2949: 62 D0 00 MOV   REG[208],0
294C: 3C CC 00 CMP   [__r0],0
294F: B0 06    JNZ   0x2956
2951: 3C CB 00 CMP   [__r1],0
2954: A0 34    JZ    0x2989
(0777) 			}
(0778) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
2956: 62 D0 00 MOV   REG[208],0
2959: 3C DC 00 CMP   [COMMAND_ERROR],0
295C: B0 2C    JNZ   0x2989
(0779) 			{
(0780) 				while(!TIMEOUT)
(0781) 				{
295E: 62 D0 00 MOV   REG[208],0
2961: 51 E1    MOV   A,[COMMAND_SOURCE]
2963: 62 D0 00 MOV   REG[208],0
2966: 3A E2    CMP   A,[ID]
2968: B0 20    JNZ   0x2989
(0782) 					// We simply wait for the end transmit indicator.
(0783) 					if(CHILD_3_cReadChar() == END_TRANSMIT)
(0784) 					{
296A: 62 D0 00 MOV   REG[208],0
296D: 55 D2 01 MOV   [TIMEOUT+1],1
2970: 55 D1 00 MOV   [TIMEOUT],0
(0785) 						return 1;
(0786) 					}
2973: 56 04 0A MOV   [X+4],10
2976: 56 03 00 MOV   [X+3],0
(0787) 				}
(0788) 			}
2979: 56 06 02 MOV   [X+6],2
297C: 56 05 00 MOV   [X+5],0
(0789) 		}
(0790) 	}
297F: 62 D0 00 MOV   REG[208],0
2982: 51 E2    MOV   A,[ID]
2984: 62 D0 00 MOV   REG[208],0
2987: 53 E6    MOV   [SERVO_ID],A
2989: 62 D0 00 MOV   REG[208],0
298C: 3C D1 00 CMP   [TIMEOUT],0
298F: B0 06    JNZ   0x2996
2991: 3C D2 00 CMP   [TIMEOUT+1],0
2994: AF B2    JZ    0x2947
2996: 77 04    INC   [X+4]
2998: 0F 03 00 ADC   [X+3],0
299B: 52 04    MOV   A,[X+4]
299D: 11 0A    SUB   A,10
299F: 52 03    MOV   A,[X+3]
29A1: 31 80    XOR   A,128
29A3: 19 80    SBB   A,128
29A5: CF 8E    JC    0x2934
29A7: 77 06    INC   [X+6]
29A9: 0F 05 00 ADC   [X+5],0
29AC: 52 06    MOV   A,[X+6]
29AE: 11 02    SUB   A,2
29B0: 52 05    MOV   A,[X+5]
29B2: 31 80    XOR   A,128
29B4: 19 80    SBB   A,128
29B6: CF 60    JC    0x2917
(0791) 	else if(STATE == RESPONSE_4)
(0792) 	{
(0793) 		if(tempByte = CHILD_4_cReadChar())
(0794) 		{
(0795) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0796) 			{
(0797) 				while(!TIMEOUT)
(0798) 				{
(0799) 					// Check for the second start byte.
29B8: 62 D0 00 MOV   REG[208],0
29BB: 51 E2    MOV   A,[ID]
29BD: 62 D0 00 MOV   REG[208],0
29C0: 3A E6    CMP   A,[SERVO_ID]
29C2: A0 0E    JZ    0x29D1
(0800) 					if(CHILD_4_cReadChar() == SERVO_START)
(0801) 					{
(0802) 						// Burn the ID, since we don't care what it is.
29C4: 50 00    MOV   A,0
29C6: 08       PUSH  A
29C7: 50 01    MOV   A,1
29C9: 08       PUSH  A
29CA: 7C 21 B8 LCALL _configToggle
29CD: 38 FE    ADD   SP,254
(0803) 						CHILD_4_cGetChar();
29CF: 80 EE    JMP   0x2ABE
(0804) 						
(0805) 						// We store the length, since it is the next byte from the servo.
(0806) 						tempByte = CHILD_4_cGetChar();
(0807) 						
29D1: 92 D2    CALL  _assignedID
(0808) 						// This basically waits for the rest of the command to pass through.
(0809) 						for(i = 0; i < tempByte; i++)
(0810) 						{
29D3: 80 EA    JMP   0x2ABE
(0811) 							CHILD_4_cGetChar();
29D5: 62 D0 00 MOV   REG[208],0
29D8: 51 E2    MOV   A,[ID]
29DA: 62 D0 00 MOV   REG[208],0
29DD: 3A E0    CMP   A,[COMMAND_DESTINATION]
29DF: D0 DE    JNC   0x2ABE
(0812) 						}
(0813) 						
(0814) 						return 1;
29E1: 93 B9    CALL  _childResponse
(0815) 					}
(0816) 				}
29E3: 80 DA    JMP   0x2ABE
(0817) 			}
29E5: 62 D0 00 MOV   REG[208],0
29E8: 3C DF CC CMP   [COMMAND_TYPE],204
29EB: B0 3D    JNZ   0x2A29
(0818) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
(0819) 			{
(0820) 				while(!TIMEOUT)
29ED: 62 D0 00 MOV   REG[208],0
29F0: 51 E0    MOV   A,[COMMAND_DESTINATION]
29F2: 62 D0 00 MOV   REG[208],0
29F5: 3A E2    CMP   A,[ID]
29F7: B0 03    JNZ   0x29FB
(0821) 				{
(0822) 					// We simply wait for the end transmit indicator.
29F9: 90 C7    CALL  _configCleared
(0823) 					if(CHILD_4_cReadChar() == END_TRANSMIT)
(0824) 					{
(0825) 						return 1;
(0826) 					}
(0827) 				}
(0828) 			}
29FB: 62 D0 00 MOV   REG[208],0
29FE: 51 E2    MOV   A,[ID]
2A00: 62 D0 00 MOV   REG[208],0
2A03: 3A E0    CMP   A,[COMMAND_DESTINATION]
2A05: D0 09    JNC   0x2A0F
2A07: 62 D0 00 MOV   REG[208],0
2A0A: 3C E0 FE CMP   [COMMAND_DESTINATION],254
2A0D: B0 16    JNZ   0x2A24
(0829) 		}
(0830) 	}
2A0F: 62 D0 00 MOV   REG[208],0
2A12: 55 E2 FB MOV   [ID],251
(0831) 	else if(STATE == INITIALIZE)
2A15: 62 D0 00 MOV   REG[208],0
2A18: 55 D0 00 MOV   [CONFIGURED+1],0
2A1B: 55 CF 00 MOV   [CONFIGURED],0
(0832) 	{
2A1E: 62 D0 00 MOV   REG[208],0
2A21: 55 E3 00 MOV   [CHILD],0
(0833) 		if(INIT_RX_cReadChar() == SERVO_START)
(0834) 		{
(0835) 			// We officially have a transmission.
(0836) 			if(INIT_RX_cGetChar() == SERVO_START)
(0837) 			{
(0838) 				// If we definitely have a transmission starting, grab all bytes from the rx buffer
(0839) 				// and store them in the proper variables for actions to be taken later.
(0840) 				COMMAND_SOURCE = INIT_RX_cGetChar();
(0841) 				COMMAND_LENGTH = INIT_RX_cGetChar();
(0842) 				COMMAND_ERROR = INIT_RX_cGetChar();
(0843) 				COMMAND_PARAM = INIT_RX_cGetChar();
(0844) 				
2A24: 43 08 01 OR    REG[8],1
(0845) 				return 1;
2A27: 80 96    JMP   0x2ABE
(0846) 			}
2A29: 62 D0 00 MOV   REG[208],0
2A2C: 3C DF 01 CMP   [COMMAND_TYPE],1
2A2F: A0 06    JZ    0x2A36
2A31: 3C DF 02 CMP   [COMMAND_TYPE],2
2A34: B0 89    JNZ   0x2ABE
(0847) 		}
(0848) 	}
2A36: 62 D0 00 MOV   REG[208],0
2A39: 51 E2    MOV   A,[ID]
2A3B: 62 D0 00 MOV   REG[208],0
2A3E: 3A E0    CMP   A,[COMMAND_DESTINATION]
2A40: D0 05    JNC   0x2A46
(0849) 	
(0850) 	return 0;
(0851) }
2A42: 93 58    CALL  _childResponse
(0852) 
2A44: 80 79    JMP   0x2ABE
(0853) // This function interprets what has been read by the command ready function
2A46: 62 D0 00 MOV   REG[208],0
2A49: 51 E2    MOV   A,[ID]
2A4B: 62 D0 00 MOV   REG[208],0
2A4E: 3A E0    CMP   A,[COMMAND_DESTINATION]
2A50: C0 6D    JC    0x2ABE
(0854) // and performs the appropriate action.
(0855) void takeAction(void)
2A52: 10       PUSH  X
2A53: 7C 0D 22 LCALL 0x0D22
2A56: 20       POP   X
2A57: 80 59    JMP   0x2AB1
(0856) {
(0857) 	int i = 0;							// An index variable for looping.
(0858) 	char tempByte = 0;					// Empty character for storing data temporarily.
(0859) 	
(0860) 	if(COMMAND_TYPE == HELLO_BYTE)		// The master is probing for new modules.
2A59: 10       PUSH  X
2A5A: 7C 0D 99 LCALL 0x0D99
2A5D: 62 D0 00 MOV   REG[208],0
2A60: 20       POP   X
2A61: 39 FF    CMP   A,255
2A63: B0 4D    JNZ   0x2AB1
(0861) 	{
(0862) 		if(!CONFIGURED)
(0863) 		{
2A65: 10       PUSH  X
2A66: 7C 0D 91 LCALL 0x0D91
2A69: 62 D0 00 MOV   REG[208],0
2A6C: 20       POP   X
2A6D: 39 FF    CMP   A,255
2A6F: B0 41    JNZ   0x2AB1
(0864) 			// Announce this module's presence if not configured.
(0865) 			sayHello();
(0866) 		}
2A71: 10       PUSH  X
2A72: 7C 0D 91 LCALL 0x0D91
2A75: 62 D0 00 MOV   REG[208],0
2A78: 20       POP   X
(0867) 		else if(!CHILD)
(0868) 		{
(0869) 			// Listen for children if we have none.
2A79: 10       PUSH  X
2A7A: 7C 0D 91 LCALL 0x0D91
2A7D: 62 D0 00 MOV   REG[208],0
2A80: 20       POP   X
2A81: 54 02    MOV   [X+2],A
(0870) 			if(childListen())
(0871) 			{
(0872) 				// If a child was heard saying hello, forward the command with the port number added.
2A83: 56 01 00 MOV   [X+1],0
2A86: 56 00 00 MOV   [X+0],0
2A89: 80 0E    JMP   0x2A98
(0873) 				sayHello();
(0874) 			}
2A8B: 10       PUSH  X
2A8C: 7C 0D 91 LCALL 0x0D91
2A8F: 62 D0 00 MOV   REG[208],0
2A92: 20       POP   X
2A93: 77 01    INC   [X+1]
2A95: 0F 00 00 ADC   [X+0],0
2A98: 62 D0 00 MOV   REG[208],0
2A9B: 52 02    MOV   A,[X+2]
2A9D: 53 CB    MOV   [__r1],A
2A9F: 52 01    MOV   A,[X+1]
2AA1: 12 CB    SUB   A,[__r1]
2AA3: 50 00    MOV   A,0
2AA5: 31 80    XOR   A,128
2AA7: 53 CA    MOV   [__rX],A
2AA9: 52 00    MOV   A,[X+0]
2AAB: 31 80    XOR   A,128
2AAD: 1A CA    SBB   A,[__rX]
2AAF: CF DB    JC    0x2A8B
2AB1: 62 D0 00 MOV   REG[208],0
2AB4: 3C D1 00 CMP   [TIMEOUT],0
2AB7: B0 06    JNZ   0x2ABE
2AB9: 3C D2 00 CMP   [TIMEOUT+1],0
2ABC: AF 9C    JZ    0x2A59
(0875) 		}
(0876) 		else if(CHILD)
(0877) 		{
(0878) 			// If you have a child established, listen to that child.
(0879) 			childResponse();
(0880) 		}
2ABE: 38 F9    ADD   SP,249
2AC0: 20       POP   X
2AC1: 7F       RET   
(0881) 	}
(0882) 	else if(COMMAND_TYPE == PING)		// The master is trying to find a module that is configured.
(0883) 	{
(0884) 		// If this is to me, act accordingly.
(0885) 		if(COMMAND_DESTINATION == ID)
(0886) 		{
_configCleared:
2AC2: 50 00    MOV   A,0
2AC4: 08       PUSH  A
2AC5: 50 02    MOV   A,2
2AC7: 08       PUSH  A
2AC8: 7C 21 B8 LCALL _configToggle
2ACB: 38 FE    ADD   SP,254
(0887) 			// Ping back to the master.
(0888) 			pingResponse();
(0889) 		}
2ACD: 10       PUSH  X
2ACE: 50 FC    MOV   A,252
2AD0: 7C 0F 8C LCALL 0x0F8C
2AD3: 20       POP   X
(0890) 		else if(COMMAND_DESTINATION > ID)
2AD4: 10       PUSH  X
2AD5: 50 FC    MOV   A,252
2AD7: 7C 0E B3 LCALL 0x0EB3
2ADA: 20       POP   X
(0891) 		{
2ADB: 10       PUSH  X
2ADC: 50 FC    MOV   A,252
2ADE: 7C 0F 8C LCALL 0x0F8C
2AE1: 20       POP   X
(0892) 			// If you have a child established, listen to that child.
2AE2: 10       PUSH  X
2AE3: 50 FC    MOV   A,252
2AE5: 7C 0E B3 LCALL 0x0EB3
2AE8: 20       POP   X
(0893) 			childResponse();
2AE9: 10       PUSH  X
2AEA: 62 D0 00 MOV   REG[208],0
2AED: 51 E2    MOV   A,[ID]
2AEF: 7C 0F 8C LCALL 0x0F8C
2AF2: 20       POP   X
(0894) 		}
2AF3: 10       PUSH  X
2AF4: 62 D0 00 MOV   REG[208],0
2AF7: 51 E2    MOV   A,[ID]
2AF9: 7C 0E B3 LCALL 0x0EB3
2AFC: 20       POP   X
(0895) 	}
2AFD: 10       PUSH  X
2AFE: 50 00    MOV   A,0
2B00: 7C 0F 8C LCALL 0x0F8C
2B03: 20       POP   X
(0896) 	else if(COMMAND_TYPE == ID_ASSIGNMENT)	// The master is assigning an ID to someone.
2B04: 10       PUSH  X
2B05: 50 00    MOV   A,0
2B07: 7C 0E B3 LCALL 0x0EB3
2B0A: 20       POP   X
(0897) 	{
2B0B: 10       PUSH  X
2B0C: 50 CD    MOV   A,205
2B0E: 7C 0F 8C LCALL 0x0F8C
2B11: 20       POP   X
(0898) 		// If this is meant for me, change my ID.
2B12: 10       PUSH  X
2B13: 50 CD    MOV   A,205
2B15: 7C 0E B3 LCALL 0x0EB3
2B18: 20       POP   X
(0899) 		if(COMMAND_DESTINATION == ID)
2B19: 10       PUSH  X
2B1A: 50 FD    MOV   A,253
2B1C: 7C 0F 8C LCALL 0x0F8C
2B1F: 20       POP   X
(0900) 		{
2B20: 10       PUSH  X
2B21: 50 FD    MOV   A,253
2B23: 7C 0E B3 LCALL 0x0EB3
2B26: 20       POP   X
(0901) 			if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
2B27: 10       PUSH  X
2B28: 50 FD    MOV   A,253
2B2A: 7C 0F 8C LCALL 0x0F8C
2B2D: 20       POP   X
(0902) 			{
2B2E: 10       PUSH  X
2B2F: 50 FD    MOV   A,253
2B31: 7C 0E B3 LCALL 0x0EB3
2B34: 20       POP   X
(0903) 				// Assign this module the ID that has been passed by the master.
(0904) 				ID = COMMAND_PARAM;
(0905) 				
2B35: 10       PUSH  X
2B36: 7C 0F 5F LCALL 0x0F5F
2B39: 62 D0 00 MOV   REG[208],0
2B3C: 20       POP   X
2B3D: 53 CC    MOV   [__r0],A
2B3F: 47 CC 20 TST   [__r0],32
2B42: AF F2    JZ    0x2B35
(0906) 				// This module is now configured.
2B44: 10       PUSH  X
2B45: 7C 0E 86 LCALL 0x0E86
2B48: 62 D0 00 MOV   REG[208],0
2B4B: 20       POP   X
2B4C: 53 CC    MOV   [__r0],A
2B4E: 47 CC 20 TST   [__r0],32
2B51: AF F2    JZ    0x2B44
(0907) 				CONFIGURED = 1;
(0908) 				
(0909) 				// If the servo ID doesn't match what we want, change it to match.
2B53: 95 DB    CALL  _xmitWait
(0910) 				if(ID != SERVO_ID)
(0911) 				{
2B55: 50 00    MOV   A,0
2B57: 08       PUSH  A
2B58: 50 01    MOV   A,1
2B5A: 08       PUSH  A
2B5B: 7C 21 B8 LCALL _configToggle
2B5E: 38 FE    ADD   SP,254
2B60: 7F       RET   
(0912) 					// These are our index variables for communication attempt timeouts.
(0913) 					int i;
(0914) 					int j;
(0915) 					
(0916) 					//while(ID != SERVO_ID)
(0917) 					
_pingResponse:
2B61: 50 00    MOV   A,0
2B63: 08       PUSH  A
2B64: 50 02    MOV   A,2
2B66: 08       PUSH  A
2B67: 7C 21 B8 LCALL _configToggle
2B6A: 38 FE    ADD   SP,254
(0918) 					for(j = 0; j < SERVO_COMM_LOOPS; j++)
(0919) 					{	
(0920) 						// Send a request to change the servo ID to match the controller ID.
2B6C: 10       PUSH  X
2B6D: 50 FC    MOV   A,252
2B6F: 7C 0F 8C LCALL 0x0F8C
2B72: 20       POP   X
(0921) 						servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
2B73: 10       PUSH  X
2B74: 50 FC    MOV   A,252
2B76: 7C 0E B3 LCALL 0x0EB3
2B79: 20       POP   X
(0922) 					
2B7A: 10       PUSH  X
2B7B: 50 FC    MOV   A,252
2B7D: 7C 0F 8C LCALL 0x0F8C
2B80: 20       POP   X
(0923) 						// Try to read the servo's ID several times.
2B81: 10       PUSH  X
2B82: 50 FC    MOV   A,252
2B84: 7C 0E B3 LCALL 0x0EB3
2B87: 20       POP   X
(0924) 						for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
2B88: 10       PUSH  X
2B89: 62 D0 00 MOV   REG[208],0
2B8C: 51 E2    MOV   A,[ID]
2B8E: 7C 0F 8C LCALL 0x0F8C
2B91: 20       POP   X
(0925) 						{
2B92: 10       PUSH  X
2B93: 62 D0 00 MOV   REG[208],0
2B96: 51 E2    MOV   A,[ID]
2B98: 7C 0E B3 LCALL 0x0EB3
2B9B: 20       POP   X
(0926) 							// Send a request for the servo ID, which is presumably now equal to ID.
2B9C: 10       PUSH  X
2B9D: 50 00    MOV   A,0
2B9F: 7C 0F 8C LCALL 0x0F8C
2BA2: 20       POP   X
(0927) 							servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
2BA3: 10       PUSH  X
2BA4: 50 00    MOV   A,0
2BA6: 7C 0E B3 LCALL 0x0EB3
2BA9: 20       POP   X
(0928) 							
2BAA: 10       PUSH  X
2BAB: 50 CB    MOV   A,203
2BAD: 7C 0F 8C LCALL 0x0F8C
2BB0: 20       POP   X
(0929) 							// Wait for either a timeout or an indication that we want to exit the loop.
2BB1: 10       PUSH  X
2BB2: 50 CB    MOV   A,203
2BB4: 7C 0E B3 LCALL 0x0EB3
2BB7: 20       POP   X
(0930) 							while(!TIMEOUT)
2BB8: 10       PUSH  X
2BB9: 50 FD    MOV   A,253
2BBB: 7C 0F 8C LCALL 0x0F8C
2BBE: 20       POP   X
(0931) 							{
2BBF: 10       PUSH  X
2BC0: 50 FD    MOV   A,253
2BC2: 7C 0E B3 LCALL 0x0EB3
2BC5: 20       POP   X
(0932) 								// If we have a command to interpret, read it.
2BC6: 10       PUSH  X
2BC7: 50 FD    MOV   A,253
2BC9: 7C 0F 8C LCALL 0x0F8C
2BCC: 20       POP   X
(0933) 								if(commandReady())
2BCD: 10       PUSH  X
2BCE: 50 FD    MOV   A,253
2BD0: 7C 0E B3 LCALL 0x0EB3
2BD3: 20       POP   X
(0934) 								{
(0935) 									if(!COMMAND_ERROR)
(0936) 									{
2BD4: 10       PUSH  X
2BD5: 7C 0F 5F LCALL 0x0F5F
2BD8: 62 D0 00 MOV   REG[208],0
2BDB: 20       POP   X
2BDC: 53 CC    MOV   [__r0],A
2BDE: 47 CC 20 TST   [__r0],32
2BE1: AF F2    JZ    0x2BD4
(0937) 										// If we have a valid servo ID, exit the loop.
2BE3: 10       PUSH  X
2BE4: 7C 0E 86 LCALL 0x0E86
2BE7: 62 D0 00 MOV   REG[208],0
2BEA: 20       POP   X
2BEB: 53 CC    MOV   [__r0],A
2BED: 47 CC 20 TST   [__r0],32
2BF0: AF F2    JZ    0x2BE3
(0938) 										if(COMMAND_SOURCE == ID)
(0939) 										{
(0940) 											// Set the timeout flag to exit the while loop.
2BF2: 95 3C    CALL  _xmitWait
(0941) 											TIMEOUT = 1;
(0942) 											// Set i such that the for loop is exited.
2BF4: 50 00    MOV   A,0
2BF6: 08       PUSH  A
2BF7: 50 01    MOV   A,1
2BF9: 08       PUSH  A
2BFA: 7C 21 B8 LCALL _configToggle
2BFD: 38 FE    ADD   SP,254
2BFF: 7F       RET   
(0943) 											i = SERVO_COMM_ATTEMPTS;
(0944) 											// Set j such that we exit the outer loop as well.
(0945) 											j = SERVO_COMM_LOOPS;
(0946) 											// Store the ID value.
(0947) 											SERVO_ID = ID;
(0948) 										}
(0949) 									}
_unloadAllConfigs:
2C00: 7C 06 EA LCALL 0x06EA
(0950) 								}
2C03: 7C 07 5C LCALL 0x075C
(0951) 							}
2C06: 7C 08 A2 LCALL 0x08A2
(0952) 						}
2C09: 7C 09 2D LCALL 0x092D
(0953) 					}	
2C0C: 7C 09 D9 LCALL 0x09D9
(0954) 				}
2C0F: 7C 0A 85 LCALL 0x0A85
(0955) 				
2C12: 7C 0B 37 LCALL 0x0B37
(0956) 				if(ID != SERVO_ID)
2C15: 7C 08 0A LCALL 0x080A
(0957) 				{
2C18: 7C 0B E6 LCALL 0x0BE6
2C1B: 7F       RET   
(0958) 					// Toggle back to normal wait mode.
(0959) 					configToggle(WAIT);
(0960) 				}
(0961) 				else
(0962) 				{
(0963) 					// Let the master node know that you got the ID assignment.
_unloadConfig:
  config_num           --> X-5
2C1C: 10       PUSH  X
2C1D: 4F       MOV   X,SP
(0964) 					assignedID();
2C1E: 3D FB 00 CMP   [X-5],0
2C21: B0 0B    JNZ   0x2C2D
2C23: 3D FC 01 CMP   [X-4],1
2C26: B0 06    JNZ   0x2C2D
(0965) 				}
(0966) 			}
2C28: 7C 06 EA LCALL 0x06EA
(0967) 		}
2C2B: 80 77    JMP   0x2CA3
(0968) 		else if(COMMAND_DESTINATION > ID)
2C2D: 3D FB 00 CMP   [X-5],0
2C30: B0 0B    JNZ   0x2C3C
2C32: 3D FC 07 CMP   [X-4],7
2C35: B0 06    JNZ   0x2C3C
(0969) 		{
(0970) 			// Switch to listen to your child.
2C37: 7C 07 5C LCALL 0x075C
(0971) 			childResponse();
2C3A: 80 68    JMP   0x2CA3
(0972) 		}
2C3C: 3D FB 00 CMP   [X-5],0
2C3F: B0 0B    JNZ   0x2C4B
2C41: 3D FC 02 CMP   [X-4],2
2C44: B0 06    JNZ   0x2C4B
(0973) 	}
(0974) 	else if(COMMAND_TYPE == CLEAR_CONFIG)	// The master wants to clear one or all configurations.
2C46: 7C 08 A2 LCALL 0x08A2
(0975) 	{
2C49: 80 59    JMP   0x2CA3
(0976) 		// Only respond if this is directly to me and not a mass config clear.
2C4B: 3D FB 00 CMP   [X-5],0
2C4E: B0 0B    JNZ   0x2C5A
2C50: 3D FC 03 CMP   [X-4],3
2C53: B0 06    JNZ   0x2C5A
(0977) 		if(COMMAND_DESTINATION == ID)
(0978) 		{
2C55: 7C 09 2D LCALL 0x092D
(0979) 			configCleared();	// Notify the master that I am clearing my config.
2C58: 80 4A    JMP   0x2CA3
(0980) 		}
2C5A: 3D FB 00 CMP   [X-5],0
2C5D: B0 0B    JNZ   0x2C69
2C5F: 3D FC 04 CMP   [X-4],4
2C62: B0 06    JNZ   0x2C69
(0981) 		
(0982) 		// If this is meant for me, deconfigure.  Also, if a module ahead of you is
2C64: 7C 09 D9 LCALL 0x09D9
(0983) 		// getting deconfigured, you have no choice but to deconfigure as well to
2C67: 80 3B    JMP   0x2CA3
(0984) 		// avoid errors on reconfiguration.
2C69: 3D FB 00 CMP   [X-5],0
2C6C: B0 0B    JNZ   0x2C78
2C6E: 3D FC 05 CMP   [X-4],5
2C71: B0 06    JNZ   0x2C78
(0985) 		if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
(0986) 		{
2C73: 7C 0A 85 LCALL 0x0A85
(0987) 			ID = DEFAULT_ID;	// Reset my ID to the default.
2C76: 80 2C    JMP   0x2CA3
(0988) 			CONFIGURED = 0;		// I am no longer configured.
2C78: 3D FB 00 CMP   [X-5],0
2C7B: B0 0B    JNZ   0x2C87
2C7D: 3D FC 06 CMP   [X-4],6
2C80: B0 06    JNZ   0x2C87
(0989) 			CHILD = 0;			// No one can depend on you anymore.
(0990) 		}
2C82: 7C 0B 37 LCALL 0x0B37
(0991) //		else if(COMMAND_DESTINATION > ID)
2C85: 80 1D    JMP   0x2CA3
(0992) //		{
2C87: 3D FB 00 CMP   [X-5],0
2C8A: B0 0B    JNZ   0x2C96
2C8C: 3D FC 08 CMP   [X-4],8
2C8F: B0 06    JNZ   0x2C96
(0993) //			// Switch to listen to your child.
(0994) //			childResponse();
2C91: 7C 08 0A LCALL 0x080A
(0995) //			// Switch back to wait for a master response.
2C94: 80 0E    JMP   0x2CA3
(0996) //			configToggle(WAIT);
2C96: 3D FB 00 CMP   [X-5],0
2C99: B0 09    JNZ   0x2CA3
2C9B: 3D FC 09 CMP   [X-4],9
2C9E: B0 04    JNZ   0x2CA3
(0997) //		}
(0998) //		Going to also have to take into account of this is my child.
2CA0: 7C 0B E6 LCALL 0x0BE6
(0999) 		
2CA3: 20       POP   X
2CA4: 7F       RET   
(1000) 		// Turn off the LED.
(1001) 		PRT2DR |= 0b00000001;
(1002) 	}
(1003) 	else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
(1004) 	{
(1005) 		if(COMMAND_DESTINATION > ID)
_assignedID:
2CA5: 50 00    MOV   A,0
2CA7: 08       PUSH  A
2CA8: 50 02    MOV   A,2
2CAA: 08       PUSH  A
2CAB: 7C 21 B8 LCALL _configToggle
2CAE: 38 FE    ADD   SP,254
(1006) 		{
(1007) 			// Allow the child response through.
(1008) 			childResponse();
2CB0: 10       PUSH  X
2CB1: 50 FC    MOV   A,252
2CB3: 7C 0F 8C LCALL 0x0F8C
2CB6: 20       POP   X
(1009) 		}
2CB7: 10       PUSH  X
2CB8: 50 FC    MOV   A,252
2CBA: 7C 0E B3 LCALL 0x0EB3
2CBD: 20       POP   X
(1010) 		else if(COMMAND_DESTINATION <= ID)
2CBE: 10       PUSH  X
2CBF: 50 FC    MOV   A,252
2CC1: 7C 0F 8C LCALL 0x0F8C
2CC4: 20       POP   X
(1011) 		{
2CC5: 10       PUSH  X
2CC6: 50 FC    MOV   A,252
2CC8: 7C 0E B3 LCALL 0x0EB3
2CCB: 20       POP   X
(1012) 			WAIT_RECV_TIMEOUT_Start();		// Start the timer.
2CCC: 10       PUSH  X
2CCD: 62 D0 00 MOV   REG[208],0
2CD0: 51 E2    MOV   A,[ID]
2CD2: 7C 0F 8C LCALL 0x0F8C
2CD5: 20       POP   X
(1013) 			
2CD6: 10       PUSH  X
2CD7: 62 D0 00 MOV   REG[208],0
2CDA: 51 E2    MOV   A,[ID]
2CDC: 7C 0E B3 LCALL 0x0EB3
2CDF: 20       POP   X
(1014) 			while(!TIMEOUT)
2CE0: 10       PUSH  X
2CE1: 50 00    MOV   A,0
2CE3: 7C 0F 8C LCALL 0x0F8C
2CE6: 20       POP   X
(1015) 			{
2CE7: 10       PUSH  X
2CE8: 50 00    MOV   A,0
2CEA: 7C 0E B3 LCALL 0x0EB3
2CED: 20       POP   X
(1016) 				// Sit and spin while we wait for the transmission to start.
2CEE: 10       PUSH  X
2CEF: 50 CA    MOV   A,202
2CF1: 7C 0F 8C LCALL 0x0F8C
2CF4: 20       POP   X
(1017) 				if(WAIT_RECV_cReadChar() == SERVO_START)
2CF5: 10       PUSH  X
2CF6: 50 CA    MOV   A,202
2CF8: 7C 0E B3 LCALL 0x0EB3
2CFB: 20       POP   X
(1018) 				{
2CFC: 10       PUSH  X
2CFD: 50 FD    MOV   A,253
2CFF: 7C 0F 8C LCALL 0x0F8C
2D02: 20       POP   X
(1019) 					// Find the second servo start byte.
2D03: 10       PUSH  X
2D04: 50 FD    MOV   A,253
2D06: 7C 0E B3 LCALL 0x0EB3
2D09: 20       POP   X
(1020) 					if(WAIT_RECV_cGetChar() == SERVO_START)
2D0A: 10       PUSH  X
2D0B: 50 FD    MOV   A,253
2D0D: 7C 0F 8C LCALL 0x0F8C
2D10: 20       POP   X
(1021) 					{
2D11: 10       PUSH  X
2D12: 50 FD    MOV   A,253
2D14: 7C 0E B3 LCALL 0x0EB3
2D17: 20       POP   X
(1022) 						// Burn the ID.
(1023) 						WAIT_RECV_cGetChar();
(1024) 						
2D18: 10       PUSH  X
2D19: 7C 0F 5F LCALL 0x0F5F
2D1C: 62 D0 00 MOV   REG[208],0
2D1F: 20       POP   X
2D20: 53 CC    MOV   [__r0],A
2D22: 47 CC 20 TST   [__r0],32
2D25: AF F2    JZ    0x2D18
(1025) 						// The second parameter after the servo start is the remaining command length.
2D27: 10       PUSH  X
2D28: 7C 0E 86 LCALL 0x0E86
2D2B: 62 D0 00 MOV   REG[208],0
2D2E: 20       POP   X
2D2F: 53 CC    MOV   [__r0],A
2D31: 47 CC 20 TST   [__r0],32
2D34: AF F2    JZ    0x2D27
(1026) 						tempByte = WAIT_RECV_cGetChar();
(1027) 						
(1028) 						// This basically waits for the rest of the command to pass through.
2D36: 93 F8    CALL  _xmitWait
(1029) 						for(i = 0; i < tempByte; i++)
(1030) 						{
2D38: 50 00    MOV   A,0
2D3A: 08       PUSH  A
2D3B: 50 01    MOV   A,1
2D3D: 08       PUSH  A
2D3E: 7C 21 B8 LCALL _configToggle
2D41: 38 FE    ADD   SP,254
2D43: 7F       RET   
(1031) 							WAIT_RECV_cGetChar();
(1032) 						}
(1033) 					}
(1034) 				}
(1035) 			}
(1036) 		}
_childListen:
2D44: 50 00    MOV   A,0
2D46: 08       PUSH  A
2D47: 50 07    MOV   A,7
2D49: 08       PUSH  A
2D4A: 7C 21 B8 LCALL _configToggle
2D4D: 38 FE    ADD   SP,254
2D4F: 80 1C    JMP   0x2D6C
(1037) 	}
(1038) }
(1039) 
(1040) // This function sends out an acknowledgement of a configuration reset.
(1041) void configCleared(void)
2D51: 7C 23 CE LCALL _commandReady
2D54: 62 D0 00 MOV   REG[208],0
2D57: 3C CC 00 CMP   [__r0],0
2D5A: B0 06    JNZ   0x2D61
2D5C: 3C CB 00 CMP   [__r1],0
2D5F: A0 0C    JZ    0x2D6C
(1042) {
(1043) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2D61: 62 D0 00 MOV   REG[208],0
2D64: 55 CB 01 MOV   [__r1],1
2D67: 55 CC 00 MOV   [__r0],0
2D6A: 80 30    JMP   0x2D9B
2D6C: 62 D0 00 MOV   REG[208],0
2D6F: 3C D1 00 CMP   [TIMEOUT],0
2D72: B0 06    JNZ   0x2D79
2D74: 3C D2 00 CMP   [TIMEOUT+1],0
2D77: AF D9    JZ    0x2D51
(1044) 	
(1045) 	// Transmit a ping to everyone.
(1046) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1047) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
2D79: 10       PUSH  X
2D7A: 7C 14 68 LCALL 0x1468
2D7D: 20       POP   X
(1048) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
2D7E: 62 D0 00 MOV   REG[208],0
2D81: 55 D2 00 MOV   [TIMEOUT+1],0
2D84: 55 D1 00 MOV   [TIMEOUT],0
(1049) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1050) 	TX_014_PutChar(ID);				// My ID
2D87: 50 00    MOV   A,0
2D89: 08       PUSH  A
2D8A: 50 01    MOV   A,1
2D8C: 08       PUSH  A
2D8D: 7C 21 B8 LCALL _configToggle
2D90: 38 FE    ADD   SP,254
(1051) 	TX_23_PutChar(ID);				// My ID
(1052) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
2D92: 62 D0 00 MOV   REG[208],0
2D95: 55 CB 00 MOV   [__r1],0
2D98: 55 CC 00 MOV   [__r0],0
2D9B: 7F       RET   
(1053) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1054) 	TX_014_PutChar(CONFIG_CLEARED);	// This is a ping response
(1055) 	TX_23_PutChar(CONFIG_CLEARED);	// This is a ping response
(1056) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1057) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
_childResponse:
  child_responded      --> X+0
2D9C: 10       PUSH  X
2D9D: 4F       MOV   X,SP
2D9E: 38 02    ADD   SP,2
(1058) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2DA0: 56 01 00 MOV   [X+1],0
2DA3: 56 00 00 MOV   [X+0],0
(1059) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1060) 	
(1061) 	// Wait for the transmission to finish.
2DA6: 62 D0 00 MOV   REG[208],0
2DA9: 3C E3 41 CMP   [CHILD],65
2DAC: B0 0E    JNZ   0x2DBB
(1062) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1063) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2DAE: 50 00    MOV   A,0
2DB0: 08       PUSH  A
2DB1: 50 03    MOV   A,3
2DB3: 08       PUSH  A
2DB4: 7C 21 B8 LCALL _configToggle
2DB7: 38 FE    ADD   SP,254
(1064) 	
2DB9: 80 56    JMP   0x2E10
(1065) 	// Make completely sure we're done.
2DBB: 62 D0 00 MOV   REG[208],0
2DBE: 3C E3 42 CMP   [CHILD],66
2DC1: B0 0E    JNZ   0x2DD0
(1066) 	xmitWait();
(1067) 	
2DC3: 50 00    MOV   A,0
2DC5: 08       PUSH  A
2DC6: 50 04    MOV   A,4
2DC8: 08       PUSH  A
2DC9: 7C 21 B8 LCALL _configToggle
2DCC: 38 FE    ADD   SP,254
(1068) 	configToggle(WAIT);				// Switch back to wait for a master response.
2DCE: 80 41    JMP   0x2E10
(1069) }
2DD0: 62 D0 00 MOV   REG[208],0
2DD3: 3C E3 43 CMP   [CHILD],67
2DD6: B0 0E    JNZ   0x2DE5
(1070) 
(1071) // This function sends out a ping response for everyone to hear.
2DD8: 50 00    MOV   A,0
2DDA: 08       PUSH  A
2DDB: 50 05    MOV   A,5
2DDD: 08       PUSH  A
2DDE: 7C 21 B8 LCALL _configToggle
2DE1: 38 FE    ADD   SP,254
(1072) void pingResponse(void)
2DE3: 80 2C    JMP   0x2E10
(1073) {
2DE5: 62 D0 00 MOV   REG[208],0
2DE8: 3C E3 44 CMP   [CHILD],68
2DEB: B0 24    JNZ   0x2E10
(1074) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(1075) 	
2DED: 50 00    MOV   A,0
2DEF: 08       PUSH  A
2DF0: 50 06    MOV   A,6
2DF2: 08       PUSH  A
2DF3: 7C 21 B8 LCALL _configToggle
2DF6: 38 FE    ADD   SP,254
(1076) 	// Transmit a ping to everyone.
2DF8: 80 17    JMP   0x2E10
(1077) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1078) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1079) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1080) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1081) 	TX_014_PutChar(ID);				// My ID
2DFA: 7C 23 CE LCALL _commandReady
2DFD: 62 D0 00 MOV   REG[208],0
2E00: 3C CC 00 CMP   [__r0],0
2E03: B0 06    JNZ   0x2E0A
2E05: 3C CB 00 CMP   [__r1],0
2E08: A0 07    JZ    0x2E10
(1082) 	TX_23_PutChar(ID);				// My ID
(1083) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
2E0A: 56 01 01 MOV   [X+1],1
2E0D: 56 00 00 MOV   [X+0],0
2E10: 3D 00 00 CMP   [X+0],0
2E13: B0 13    JNZ   0x2E27
2E15: 3D 01 00 CMP   [X+1],0
2E18: B0 0E    JNZ   0x2E27
2E1A: 62 D0 00 MOV   REG[208],0
2E1D: 3C D1 00 CMP   [TIMEOUT],0
2E20: B0 06    JNZ   0x2E27
2E22: 3C D2 00 CMP   [TIMEOUT+1],0
2E25: AF D4    JZ    0x2DFA
(1084) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1085) 	TX_014_PutChar(PING);			// This is a ping response
(1086) 	TX_23_PutChar(PING);			// This is a ping response
(1087) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1088) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2E27: 62 D0 00 MOV   REG[208],0
2E2A: 3C E3 41 CMP   [CHILD],65
2E2D: B0 08    JNZ   0x2E36
(1089) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1090) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2E2F: 10       PUSH  X
2E30: 7C 1F CB LCALL 0x1FCB
2E33: 20       POP   X
(1091) 	
2E34: 80 2C    JMP   0x2E61
(1092) 	// Wait for the transmission to finish.
2E36: 62 D0 00 MOV   REG[208],0
2E39: 3C E3 42 CMP   [CHILD],66
2E3C: B0 08    JNZ   0x2E45
(1093) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1094) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2E3E: 10       PUSH  X
2E3F: 7C 1E 12 LCALL 0x1E12
2E42: 20       POP   X
(1095) 	
2E43: 80 1D    JMP   0x2E61
(1096) 	// Make completely sure we're done.
2E45: 62 D0 00 MOV   REG[208],0
2E48: 3C E3 43 CMP   [CHILD],67
2E4B: B0 08    JNZ   0x2E54
(1097) 	xmitWait();
(1098) 	
2E4D: 10       PUSH  X
2E4E: 7C 1C 59 LCALL 0x1C59
2E51: 20       POP   X
(1099) 	configToggle(WAIT);				// Switch back to wait for a master response.
2E52: 80 0E    JMP   0x2E61
(1100) }
2E54: 62 D0 00 MOV   REG[208],0
2E57: 3C E3 44 CMP   [CHILD],68
2E5A: B0 06    JNZ   0x2E61
(1101) 
(1102) // This function blindly unloads all user configurations. This will be called once,
2E5C: 10       PUSH  X
2E5D: 7C 1A A0 LCALL 0x1AA0
2E60: 20       POP   X
(1103) // when the system initially has no known state.
(1104) void unloadAllConfigs(void)
(1105) {
2E61: 62 D0 00 MOV   REG[208],0
2E64: 55 D2 00 MOV   [TIMEOUT+1],0
2E67: 55 D1 00 MOV   [TIMEOUT],0
(1106) 	UnloadConfig_waiting();
(1107) 	UnloadConfig_hello();
2E6A: 50 00    MOV   A,0
2E6C: 08       PUSH  A
2E6D: 50 01    MOV   A,1
2E6F: 08       PUSH  A
2E70: 7C 21 B8 LCALL _configToggle
2E73: 38 FE    ADD   SP,254
(1108) 	UnloadConfig_my_response();
(1109) 	UnloadConfig_response1();
2E75: 62 D0 00 MOV   REG[208],0
2E78: 52 01    MOV   A,[X+1]
2E7A: 53 CB    MOV   [__r1],A
2E7C: 52 00    MOV   A,[X+0]
2E7E: 53 CC    MOV   [__r0],A
2E80: 38 FE    ADD   SP,254
2E82: 20       POP   X
2E83: 7F       RET   
(1110) 	UnloadConfig_response2();
(1111) 	UnloadConfig_response3();
(1112) 	UnloadConfig_response4();
(1113) 	UnloadConfig_initial();
(1114) 	UnloadConfig_servo_transmit();
(1115) }
(1116) 
_servoFinder:
  flashWrite           --> X+7
  status_return_level  --> X+6
  total_attempts       --> X+4
  j                    --> X+2
  i                    --> X+0
2E84: 10       PUSH  X
2E85: 4F       MOV   X,SP
2E86: 38 09    ADD   SP,9
(1117) // This function unloads the configuration corresponding to the config number passed to it.
(1118) // We do this instead of unloadAllConfigs to cut down on set up time.
2E88: 56 01 00 MOV   [X+1],0
2E8B: 56 00 00 MOV   [X+0],0
(1119) void unloadConfig(int config_num)
2E8E: 56 03 00 MOV   [X+3],0
2E91: 56 02 00 MOV   [X+2],0
(1120) {
(1121) 	if(config_num == WAIT)
2E94: 56 05 00 MOV   [X+5],0
2E97: 56 04 00 MOV   [X+4],0
(1122) 	{
(1123) 		UnloadConfig_waiting();
(1124) 	}
2E9A: 56 08 00 MOV   [X+8],0
2E9D: 56 07 00 MOV   [X+7],0
(1125) 	else if(config_num == HELLO_MODE)
(1126) 	{
(1127) 		UnloadConfig_hello();
2EA0: 56 06 03 MOV   [X+6],3
(1128) 	}
(1129) 	else if(config_num == MY_RESPONSE)
(1130) 	{
2EA3: 62 D0 00 MOV   REG[208],0
2EA6: 55 E6 FF MOV   [SERVO_ID],255
(1131) 		UnloadConfig_my_response();
(1132) 	}
(1133) 	else if(config_num == RESPONSE_1)
(1134) 	{
(1135) 		UnloadConfig_response1();
(1136) 	}
(1137) 	else if(config_num == RESPONSE_2)
(1138) 	{
(1139) 		UnloadConfig_response2();
2EA9: 56 03 00 MOV   [X+3],0
2EAC: 56 02 00 MOV   [X+2],0
(1140) 	}
(1141) 	else if(config_num == RESPONSE_3)
(1142) 	{
2EAF: 56 01 00 MOV   [X+1],0
2EB2: 56 00 00 MOV   [X+0],0
(1143) 		UnloadConfig_response3();
(1144) 	}
(1145) 	else if(config_num == RESPONSE_4)
2EB5: 50 00    MOV   A,0
2EB7: 08       PUSH  A
2EB8: 08       PUSH  A
2EB9: 50 01    MOV   A,1
2EBB: 08       PUSH  A
2EBC: 50 02    MOV   A,2
2EBE: 08       PUSH  A
2EBF: 50 FE    MOV   A,254
2EC1: 08       PUSH  A
2EC2: 91 8E    CALL  _servoInstruction
2EC4: 38 FB    ADD   SP,251
(1146) 	{
(1147) 		UnloadConfig_response4();
2EC6: 77 05    INC   [X+5]
2EC8: 0F 04 00 ADC   [X+4],0
2ECB: 80 4C    JMP   0x2F18
(1148) 	}
(1149) 	else if(config_num == INITIALIZE)
(1150) 	{
(1151) 		UnloadConfig_initial();
(1152) 	}
2ECD: 7C 23 CE LCALL _commandReady
2ED0: 62 D0 00 MOV   REG[208],0
2ED3: 3C CC 00 CMP   [__r0],0
2ED6: B0 06    JNZ   0x2EDD
2ED8: 3C CB 00 CMP   [__r1],0
2EDB: A0 3C    JZ    0x2F18
(1153) 	else if(config_num == SERVO_COMM)
(1154) 	{
(1155) 		UnloadConfig_servo_transmit();
2EDD: 62 D0 00 MOV   REG[208],0
2EE0: 3C E1 00 CMP   [COMMAND_SOURCE],0
2EE3: C0 2B    JC    0x2F0F
2EE5: 62 D0 00 MOV   REG[208],0
2EE8: 50 FD    MOV   A,253
2EEA: 3A E1    CMP   A,[COMMAND_SOURCE]
2EEC: C0 22    JC    0x2F0F
(1156) 	}
(1157) }
(1158) 
2EEE: 62 D0 00 MOV   REG[208],0
2EF1: 55 D2 01 MOV   [TIMEOUT+1],1
2EF4: 55 D1 00 MOV   [TIMEOUT],0
(1159) // This function responds that an ID has been assigned to it.
(1160) void assignedID(void)
2EF7: 62 D0 00 MOV   REG[208],0
2EFA: 51 E1    MOV   A,[COMMAND_SOURCE]
2EFC: 62 D0 00 MOV   REG[208],0
2EFF: 53 E6    MOV   [SERVO_ID],A
(1161) {
(1162) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2F01: 56 01 0A MOV   [X+1],10
2F04: 56 00 00 MOV   [X+0],0
(1163) 	
(1164) 	// Transmit a ping to everyone.
2F07: 56 03 02 MOV   [X+3],2
2F0A: 56 02 00 MOV   [X+2],0
(1165) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
2F0D: 80 0A    JMP   0x2F18
(1166) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1167) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1168) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1169) 	TX_014_PutChar(ID);				// My ID
2F0F: 62 D0 00 MOV   REG[208],0
2F12: 55 D2 01 MOV   [TIMEOUT+1],1
2F15: 55 D1 00 MOV   [TIMEOUT],0
2F18: 62 D0 00 MOV   REG[208],0
2F1B: 3C D1 00 CMP   [TIMEOUT],0
2F1E: B0 06    JNZ   0x2F25
2F20: 3C D2 00 CMP   [TIMEOUT+1],0
2F23: AF A9    JZ    0x2ECD
2F25: 77 01    INC   [X+1]
2F27: 0F 00 00 ADC   [X+0],0
2F2A: 52 01    MOV   A,[X+1]
2F2C: 11 0A    SUB   A,10
2F2E: 52 00    MOV   A,[X+0]
2F30: 31 80    XOR   A,128
2F32: 19 80    SBB   A,128
2F34: CF 80    JC    0x2EB5
(1170) 	TX_23_PutChar(ID);				// My ID
(1171) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
(1172) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1173) 	TX_014_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1174) 	TX_23_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1175) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1176) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1177) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2F36: 62 D0 00 MOV   REG[208],0
2F39: 3C E6 FF CMP   [SERVO_ID],255
2F3C: B0 22    JNZ   0x2F5F
2F3E: 3D 07 00 CMP   [X+7],0
2F41: B0 1D    JNZ   0x2F5F
2F43: 3D 08 00 CMP   [X+8],0
2F46: B0 18    JNZ   0x2F5F
(1178) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1179) 	
(1180) 	// Wait for the transmission to finish.
2F48: 56 08 01 MOV   [X+8],1
2F4B: 56 07 00 MOV   [X+7],0
(1181) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1182) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
(1183) 	
(1184) 	// Make completely sure we're done.
2F4E: 50 00    MOV   A,0
2F50: 08       PUSH  A
2F51: 08       PUSH  A
2F52: 50 06    MOV   A,6
2F54: 08       PUSH  A
2F55: 50 02    MOV   A,2
2F57: 08       PUSH  A
2F58: 50 FE    MOV   A,254
2F5A: 08       PUSH  A
2F5B: 90 F5    CALL  _servoInstruction
2F5D: 38 FB    ADD   SP,251
2F5F: 77 03    INC   [X+3]
2F61: 0F 02 00 ADC   [X+2],0
2F64: 52 03    MOV   A,[X+3]
2F66: 11 02    SUB   A,2
2F68: 52 02    MOV   A,[X+2]
2F6A: 31 80    XOR   A,128
2F6C: 19 80    SBB   A,128
2F6E: CF 40    JC    0x2EAF
(1185) 	xmitWait();
(1186) 	
(1187) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1188) }
(1189) 
2F70: 56 08 00 MOV   [X+8],0
2F73: 56 07 00 MOV   [X+7],0
(1190) // This function listens for children and registers the port that they talk to.
(1191) int childListen(void)
(1192) {
(1193) 	configToggle(HELLO_MODE);	// Switch to listen for hellos on every port.
2F76: 62 D0 00 MOV   REG[208],0
2F79: 3C E6 FE CMP   [SERVO_ID],254
2F7C: D0 CD    JNC   0x304A
(1194) 	
(1195) 	// Wait to either hear a child or time out.
(1196) 	while(!TIMEOUT)
(1197) 	{		
(1198) 		if(commandReady())
(1199) 		{
2F7E: 56 03 00 MOV   [X+3],0
2F81: 56 02 00 MOV   [X+2],0
(1200) 			return 1;
(1201) 		}
(1202) 	}
2F84: 56 01 00 MOV   [X+1],0
2F87: 56 00 00 MOV   [X+0],0
(1203) 	
(1204) 	HELLO_TIMEOUT_Stop();		// Stop the timer.
(1205) 	TIMEOUT = 0;				// Clear the timeout flag.
2F8A: 50 01    MOV   A,1
2F8C: 08       PUSH  A
2F8D: 50 10    MOV   A,16
2F8F: 08       PUSH  A
2F90: 50 02    MOV   A,2
2F92: 08       PUSH  A
2F93: 50 04    MOV   A,4
2F95: 08       PUSH  A
2F96: 62 D0 00 MOV   REG[208],0
2F99: 51 E6    MOV   A,[SERVO_ID]
2F9B: 08       PUSH  A
2F9C: 90 B4    CALL  _servoInstruction
2F9E: 38 FB    ADD   SP,251
2FA0: 80 48    JMP   0x2FE9
(1206) 	
(1207) 	configToggle(WAIT);			// Switch back to wait for a master response.
(1208) 	
(1209) 	return 0;					// Return the result of our listening session.
(1210) }
(1211) 
2FA2: 7C 23 CE LCALL _commandReady
2FA5: 62 D0 00 MOV   REG[208],0
2FA8: 3C CC 00 CMP   [__r0],0
2FAB: B0 06    JNZ   0x2FB2
2FAD: 3C CB 00 CMP   [__r1],0
2FB0: A0 38    JZ    0x2FE9
(1212) // This function waits for a child response.
(1213) int childResponse(void)
2FB2: 62 D0 00 MOV   REG[208],0
2FB5: 3C DC 00 CMP   [COMMAND_ERROR],0
2FB8: B0 30    JNZ   0x2FE9
(1214) {
(1215) 	int child_responded = 0;
(1216) 	
2FBA: 62 D0 00 MOV   REG[208],0
2FBD: 3C DE 01 CMP   [COMMAND_PARAM],1
2FC0: B0 1F    JNZ   0x2FE0
(1217) 	// Switch to the right port.
(1218) 	if(CHILD == PORT_A)
(1219) 	{
2FC2: 62 D0 00 MOV   REG[208],0
2FC5: 55 D2 01 MOV   [TIMEOUT+1],1
2FC8: 55 D1 00 MOV   [TIMEOUT],0
(1220) 		configToggle(RESPONSE_1);
(1221) 	}
2FCB: 62 D0 00 MOV   REG[208],0
2FCE: 51 DE    MOV   A,[COMMAND_PARAM]
2FD0: 54 06    MOV   [X+6],A
(1222) 	else if(CHILD == PORT_B)
(1223) 	{
2FD2: 56 01 0A MOV   [X+1],10
2FD5: 56 00 00 MOV   [X+0],0
(1224) 		configToggle(RESPONSE_2);
(1225) 	}
2FD8: 56 03 02 MOV   [X+3],2
2FDB: 56 02 00 MOV   [X+2],0
(1226) 	else if(CHILD == PORT_C)
2FDE: 80 0A    JMP   0x2FE9
(1227) 	{
(1228) 		configToggle(RESPONSE_3);
(1229) 	}
(1230) 	else if(CHILD == PORT_D)
2FE0: 62 D0 00 MOV   REG[208],0
2FE3: 55 D2 01 MOV   [TIMEOUT+1],1
2FE6: 55 D1 00 MOV   [TIMEOUT],0
2FE9: 62 D0 00 MOV   REG[208],0
2FEC: 3C D1 00 CMP   [TIMEOUT],0
2FEF: B0 06    JNZ   0x2FF6
2FF1: 3C D2 00 CMP   [TIMEOUT+1],0
2FF4: AF AD    JZ    0x2FA2
2FF6: 77 01    INC   [X+1]
2FF8: 0F 00 00 ADC   [X+0],0
2FFB: 52 01    MOV   A,[X+1]
2FFD: 11 0A    SUB   A,10
2FFF: 52 00    MOV   A,[X+0]
3001: 31 80    XOR   A,128
3003: 19 80    SBB   A,128
3005: CF 84    JC    0x2F8A
(1231) 	{
(1232) 		configToggle(RESPONSE_4);
(1233) 	}
(1234) 	
(1235) 	// Wait for a response or a timeout.
(1236) 	while((!child_responded) && (!TIMEOUT))
(1237) 	{
(1238) 		if(commandReady())
(1239) 		{
3007: 3D 06 01 CMP   [X+6],1
300A: A0 27    JZ    0x3032
300C: 3D 07 00 CMP   [X+7],0
300F: B0 22    JNZ   0x3032
3011: 3D 08 00 CMP   [X+8],0
3014: B0 1D    JNZ   0x3032
(1240) 			child_responded = 1;
(1241) 		}
3016: 56 08 01 MOV   [X+8],1
3019: 56 07 00 MOV   [X+7],0
(1242) 	}
(1243) 	
(1244) 	// Stop the right timer.
301C: 50 01    MOV   A,1
301E: 08       PUSH  A
301F: 50 10    MOV   A,16
3021: 08       PUSH  A
3022: 50 03    MOV   A,3
3024: 08       PUSH  A
3025: 50 04    MOV   A,4
3027: 08       PUSH  A
3028: 62 D0 00 MOV   REG[208],0
302B: 51 E6    MOV   A,[SERVO_ID]
302D: 08       PUSH  A
302E: 90 22    CALL  _servoInstruction
3030: 38 FB    ADD   SP,251
3032: 77 03    INC   [X+3]
3034: 0F 02 00 ADC   [X+2],0
3037: 52 03    MOV   A,[X+3]
3039: 11 02    SUB   A,2
303B: 52 02    MOV   A,[X+2]
303D: 31 80    XOR   A,128
303F: 19 80    SBB   A,128
3041: CF 42    JC    0x2F84
(1245) 	if(CHILD == PORT_A)
(1246) 	{
(1247) 		CHILD_1_TIMEOUT_Stop();
(1248) 	}
3043: 3D 06 01 CMP   [X+6],1
3046: A0 05    JZ    0x304C
(1249) 	else if(CHILD == PORT_B)
(1250) 	{
(1251) 		CHILD_2_TIMEOUT_Stop();
3048: 8F FF    JMP   0x3048
(1252) 	}
(1253) 	else if(CHILD == PORT_C)
(1254) 	{
(1255) 		CHILD_3_TIMEOUT_Stop();
(1256) 	}
(1257) 	else if(CHILD == PORT_D)
304A: 8F FF    JMP   0x304A
(1258) 	{
(1259) 		CHILD_4_TIMEOUT_Stop();
(1260) 	}
(1261) 	
304C: 91 55    CALL  _servoConfigWait
304E: 38 F7    ADD   SP,247
3050: 20       POP   X
3051: 7F       RET   
(1262) 	TIMEOUT = 0;					// Reset the timeout flag.
(1263) 	
(1264) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1265) 	
(1266) 	return child_responded;
(1267) }
_servoInstruction:
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
3052: 10       PUSH  X
3053: 4F       MOV   X,SP
3054: 38 01    ADD   SP,1
(1268) 
(1269) // This function is used to find the servo that is directly connected to this module's controller.
(1270) // After the servo ID is found, the status return level is changed so that packets are only
(1271) // returned for the desired status return level defined at the top of this file.
3056: 50 00    MOV   A,0
3058: 08       PUSH  A
3059: 50 09    MOV   A,9
305B: 08       PUSH  A
305C: 7C 21 B8 LCALL _configToggle
305F: 38 FE    ADD   SP,254
(1272) void servoFinder(void)
(1273) {				
(1274) 	// Index variables for incrementing and checking against the maximum servo comm attempts.
3061: 62 D0 00 MOV   REG[208],0
3064: 52 FB    MOV   A,[X-5]
3066: 53 CB    MOV   [__r1],A
3068: 55 CC 00 MOV   [__r0],0
306B: 52 FC    MOV   A,[X-4]
306D: 02 CB    ADD   A,[__r1]
306F: 53 CB    MOV   [__r1],A
3071: 50 00    MOV   A,0
3073: 0A CC    ADC   A,[__r0]
3075: 53 CC    MOV   [__r0],A
3077: 52 FA    MOV   A,[X-6]
3079: 04 CB    ADD   [__r1],A
307B: 0E CC 00 ADC   [__r0],0
307E: 52 F9    MOV   A,[X-7]
3080: 04 CB    ADD   [__r1],A
3082: 0E CC 00 ADC   [__r0],0
3085: 52 F8    MOV   A,[X-8]
3087: 04 CB    ADD   [__r1],A
3089: 0E CC 00 ADC   [__r0],0
308C: 50 01    MOV   A,1
308E: 08       PUSH  A
308F: 50 00    MOV   A,0
3091: 08       PUSH  A
3092: 51 CC    MOV   A,[__r0]
3094: 08       PUSH  A
3095: 51 CB    MOV   A,[__r1]
3097: 08       PUSH  A
3098: 7C 33 B1 LCALL __divmod_16X16_16
309B: 38 FE    ADD   SP,254
309D: 18       POP   A
309E: 53 CB    MOV   [__r1],A
30A0: 18       POP   A
30A1: 50 FF    MOV   A,255
30A3: 12 CB    SUB   A,[__r1]
30A5: 54 00    MOV   [X+0],A
(1275) 	int i = 0;
(1276) 	int j = 0;
(1277) 	
30A7: 3D FA 01 CMP   [X-6],1
30AA: B0 2D    JNZ   0x30D8
(1278) 	int total_attempts = 0;
(1279) 	
30AC: 10       PUSH  X
30AD: 50 FF    MOV   A,255
30AF: 7C 10 C5 LCALL 0x10C5
30B2: 20       POP   X
(1280) 	// Integer used as a flag so that EEPROM writes aren't done more than once.
30B3: 10       PUSH  X
30B4: 50 FF    MOV   A,255
30B6: 7C 10 C5 LCALL 0x10C5
30B9: 20       POP   X
(1281) 	int flashWrite = 0;
30BA: 10       PUSH  X
30BB: 52 FC    MOV   A,[X-4]
30BD: 7C 10 C5 LCALL 0x10C5
30C0: 20       POP   X
(1282) 	
30C1: 10       PUSH  X
30C2: 52 FB    MOV   A,[X-5]
30C4: 7C 10 C5 LCALL 0x10C5
30C7: 20       POP   X
(1283) 	// Create a status return level variable and set it to an out of range value initially.
30C8: 10       PUSH  X
30C9: 52 FA    MOV   A,[X-6]
30CB: 7C 10 C5 LCALL 0x10C5
30CE: 20       POP   X
(1284) 	char status_return_level = 3;
30CF: 10       PUSH  X
30D0: 52 00    MOV   A,[X+0]
30D2: 7C 10 C5 LCALL 0x10C5
30D5: 20       POP   X
(1285) 	
30D6: 80 39    JMP   0x3110
(1286) 	// Start with a servo ID of 255 (out of valid range).
(1287) 	SERVO_ID = SERVO_START;
(1288) 
30D8: 10       PUSH  X
30D9: 50 FF    MOV   A,255
30DB: 7C 10 C5 LCALL 0x10C5
30DE: 20       POP   X
(1289) 	// This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
30DF: 10       PUSH  X
30E0: 50 FF    MOV   A,255
30E2: 7C 10 C5 LCALL 0x10C5
30E5: 20       POP   X
(1290) 	// number of times in each loop (unless stopped short due to early success).  If this fails for the
30E6: 10       PUSH  X
30E7: 52 FC    MOV   A,[X-4]
30E9: 7C 10 C5 LCALL 0x10C5
30EC: 20       POP   X
(1291) 	// first round of pings, a broadcast reset will be performed to reset the servo.  This is done
30ED: 10       PUSH  X
30EE: 52 FB    MOV   A,[X-5]
30F0: 7C 10 C5 LCALL 0x10C5
30F3: 20       POP   X
(1292) 	// because we assume that the baud rate is matching up, but the servo's return delay time is too
30F4: 10       PUSH  X
30F5: 52 FA    MOV   A,[X-6]
30F7: 7C 10 C5 LCALL 0x10C5
30FA: 20       POP   X
(1293) 	// fast for the controller to switch into receive mode to read the response.  The default return
30FB: 10       PUSH  X
30FC: 52 F9    MOV   A,[X-7]
30FE: 7C 10 C5 LCALL 0x10C5
3101: 20       POP   X
(1294) 	// delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
3102: 10       PUSH  X
3103: 52 F8    MOV   A,[X-8]
3105: 7C 10 C5 LCALL 0x10C5
3108: 20       POP   X
(1295) 	// see anything, we assume that there is something is too wrong for us to fix.
3109: 10       PUSH  X
310A: 52 00    MOV   A,[X+0]
310C: 7C 10 C5 LCALL 0x10C5
310F: 20       POP   X
(1296) 	for(j = 0; j < SERVO_COMM_LOOPS; j++)
(1297) 	{	
(1298) 		// Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
(1299) 		for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
3110: 10       PUSH  X
3111: 7C 10 98 LCALL 0x1098
3114: 62 D0 00 MOV   REG[208],0
3117: 20       POP   X
3118: 53 CC    MOV   [__r0],A
311A: 47 CC 20 TST   [__r0],32
311D: AF F2    JZ    0x3110
(1300) 		{
(1301) 			// Send a ping out for any servo connected to me (will only be one).
(1302) 			servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
311F: 90 0F    CALL  _xmitWait
(1303) 			
(1304) 			total_attempts++;
(1305) 			
3121: 50 00    MOV   A,0
3123: 08       PUSH  A
3124: 50 08    MOV   A,8
3126: 08       PUSH  A
3127: 7C 21 B8 LCALL _configToggle
312A: 38 FE    ADD   SP,254
312C: 38 FF    ADD   SP,255
312E: 20       POP   X
312F: 7F       RET   
(1306) 			// Wait for either a timeout or a valid servo ID (which will trigger a timeout).
(1307) 			while(!TIMEOUT)
(1308) 			{	
(1309) 				if(commandReady())
_xmitWait:
  i                    --> X+0
3130: 10       PUSH  X
3131: 4F       MOV   X,SP
3132: 38 02    ADD   SP,2
(1310) 				{
(1311) 					// If we read a source ID within the range, exit the loop.
(1312) 					if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
3134: 56 01 00 MOV   [X+1],0
3137: 56 00 00 MOV   [X+0],0
313A: 77 01    INC   [X+1]
313C: 0F 00 00 ADC   [X+0],0
313F: 52 01    MOV   A,[X+1]
3141: 11 19    SUB   A,25
3143: 52 00    MOV   A,[X+0]
3145: 31 80    XOR   A,128
3147: 19 80    SBB   A,128
3149: CF F0    JC    0x313A
314B: 38 FE    ADD   SP,254
314D: 20       POP   X
314E: 7F       RET   
(1313) 					{	
(1314) 						// Exit this while loop by setting the timeout flag.
(1315) 						TIMEOUT = 1;
(1316) 						// Set the servo ID variable to where the ping came from.
(1317) 						SERVO_ID = COMMAND_SOURCE;
(1318) 						// Set the index variable such that the for loop exits.
(1319) 						i = SERVO_COMM_ATTEMPTS;
(1320) 						// Set the outer index variable to 2 to not attempt again for no reason.
(1321) 						j = SERVO_COMM_LOOPS;
(1322) 					}
_servoBootWait:
  i                    --> X+0
314F: 10       PUSH  X
3150: 4F       MOV   X,SP
3151: 38 02    ADD   SP,2
(1323) 					else
3153: 56 01 00 MOV   [X+1],0
3156: 56 00 00 MOV   [X+0],0
(1324) 					{
(1325) 						// Exit this while loop and try to ping again.
3159: 50 00    MOV   A,0
315B: 08       PUSH  A
315C: 50 08    MOV   A,8
315E: 08       PUSH  A
315F: 7C 21 B8 LCALL _configToggle
3162: 38 FE    ADD   SP,254
(1326) 						TIMEOUT = 1;
(1327) 					}
(1328) 				}
3164: 56 01 00 MOV   [X+1],0
3167: 56 00 00 MOV   [X+0],0
(1329) 			}
(1330) 		}
316A: 62 D0 00 MOV   REG[208],0
316D: 3C D1 00 CMP   [TIMEOUT],0
3170: B0 06    JNZ   0x3177
3172: 3C D2 00 CMP   [TIMEOUT+1],0
3175: AF F4    JZ    0x316A
(1331) 		
3177: 62 D0 00 MOV   REG[208],0
317A: 55 D2 00 MOV   [TIMEOUT+1],0
317D: 55 D1 00 MOV   [TIMEOUT],0
3180: 77 01    INC   [X+1]
3182: 0F 00 00 ADC   [X+0],0
3185: 52 01    MOV   A,[X+1]
3187: 11 4B    SUB   A,75
3189: 52 00    MOV   A,[X+0]
318B: 31 80    XOR   A,128
318D: 19 80    SBB   A,128
318F: CF DA    JC    0x316A
(1332) 		// If we didn't get a response and haven't written to the flash of the
(1333) 		// servo (first time through), send out a broadcast reset.
(1334) 		if((SERVO_ID == SERVO_START) && (!flashWrite))
3191: 10       PUSH  X
3192: 7C 12 AF LCALL 0x12AF
3195: 20       POP   X
(1335) 		{
3196: 62 D0 00 MOV   REG[208],0
3199: 55 D2 00 MOV   [TIMEOUT+1],0
319C: 55 D1 00 MOV   [TIMEOUT],0
319F: 38 FE    ADD   SP,254
31A1: 20       POP   X
31A2: 7F       RET   
(1336) 			// Set the flash write flag so that we only do this once per power cycle.
(1337) 			flashWrite = 1;
(1338) 			
(1339) 			// Send out a broadcast reset so that we know that the response time interval
(1340) 			// is large enough (default delay time for a servo is 500 microseconds).
(1341) 			servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
_servoConfigWait:
  i                    --> X+0
31A3: 10       PUSH  X
31A4: 4F       MOV   X,SP
31A5: 38 02    ADD   SP,2
(1342) 		}
31A7: 56 01 00 MOV   [X+1],0
31AA: 56 00 00 MOV   [X+0],0
(1343) 	}
(1344) 
31AD: 50 00    MOV   A,0
31AF: 08       PUSH  A
31B0: 50 08    MOV   A,8
31B2: 08       PUSH  A
31B3: 7C 21 B8 LCALL _configToggle
31B6: 38 FE    ADD   SP,254
(1345) 	// Reset flash write flag.
(1346) 	flashWrite = 0;
(1347) 	
(1348) 	// If we have a valid servo ID, set the status return level.  If we don't, just skip this
(1349) 	// because all hope is lost.
31B8: 56 01 00 MOV   [X+1],0
31BB: 56 00 00 MOV   [X+0],0
(1350) 	if(SERVO_ID < BROADCAST)
(1351) 	{
31BE: 62 D0 00 MOV   REG[208],0
31C1: 3C D1 00 CMP   [TIMEOUT],0
31C4: B0 06    JNZ   0x31CB
31C6: 3C D2 00 CMP   [TIMEOUT+1],0
31C9: AF F4    JZ    0x31BE
(1352) 		// This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
31CB: 62 D0 00 MOV   REG[208],0
31CE: 55 D2 00 MOV   [TIMEOUT+1],0
31D1: 55 D1 00 MOV   [TIMEOUT],0
31D4: 77 01    INC   [X+1]
31D6: 0F 00 00 ADC   [X+0],0
31D9: 52 01    MOV   A,[X+1]
31DB: 11 14    SUB   A,20
31DD: 52 00    MOV   A,[X+0]
31DF: 31 80    XOR   A,128
31E1: 19 80    SBB   A,128
31E3: CF DA    JC    0x31BE
(1353) 		// return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
(1354) 		// to early success).  If this fails for the first iteration, or we read a status return level
(1355) 		// other than what we want, we will attempt to write the desired status return level onto the servo.
31E5: 10       PUSH  X
31E6: 7C 12 AF LCALL 0x12AF
31E9: 20       POP   X
(1356) 		for(j = 0; j < SERVO_COMM_LOOPS; j++)
31EA: 62 D0 00 MOV   REG[208],0
31ED: 55 D2 00 MOV   [TIMEOUT+1],0
31F0: 55 D1 00 MOV   [TIMEOUT],0
(1357) 		{
(1358) 			// Attempt to read the status return level for the defined number of attempts.
31F3: 50 00    MOV   A,0
31F5: 08       PUSH  A
31F6: 50 01    MOV   A,1
31F8: 08       PUSH  A
31F9: 7C 21 B8 LCALL _configToggle
31FC: 38 FE    ADD   SP,254
31FE: 38 FE    ADD   SP,254
3200: 20       POP   X
3201: 7F       RET   
(1359) 			for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1360) 			{
(1361) 				// Send a request for the servo's status return level.
(1362) 				servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
(1363) 				
(1364) 				// Wait for either a timeout or an indication that we want to exit the loop.
(1365) 				while(!TIMEOUT)
(1366) 				{
_TX_01234_TIMEOUT_ISR:
3202: 71 C0    OR    F,192
3204: 08       PUSH  A
3205: 5D D0    MOV   A,REG[208]
3207: 08       PUSH  A
(1367) 					// If a valid command is ready, interpret it.
3208: 62 D0 00 MOV   REG[208],0
320B: 55 D2 01 MOV   [TIMEOUT+1],1
320E: 55 D1 00 MOV   [TIMEOUT],0
(1368) 					if(commandReady())
3211: 62 DA FD MOV   REG[218],253
3214: 18       POP   A
3215: 60 D0    MOV   REG[208],A
3217: 18       POP   A
3218: 7E       RETI  
(1369) 					{
(1370) 						if(!COMMAND_ERROR)
(1371) 						{
(1372) 							// If the return level is equal to what is desired, store it.
(1373) 							if(COMMAND_PARAM == STATUS_RET_LEVEL)
_HELLO_TIMEOUT_ISR:
3219: 71 C0    OR    F,192
321B: 08       PUSH  A
321C: 5D D0    MOV   A,REG[208]
321E: 08       PUSH  A
(1374) 							{
321F: 62 D0 00 MOV   REG[208],0
3222: 55 D2 01 MOV   [TIMEOUT+1],1
3225: 55 D1 00 MOV   [TIMEOUT],0
(1375) 								// Set the timeout flag to exit the loop.
3228: 62 DA FD MOV   REG[218],253
322B: 18       POP   A
322C: 60 D0    MOV   REG[208],A
322E: 18       POP   A
322F: 7E       RETI  
(1376) 								TIMEOUT = 1;
(1377) 								// Store the status return level.
(1378) 								status_return_level = COMMAND_PARAM;
(1379) 								// Set i so that we exit the for loop.
(1380) 								i = SERVO_COMM_ATTEMPTS;
_CHILD_1_TIMEOUT_ISR:
3230: 71 C0    OR    F,192
3232: 08       PUSH  A
3233: 5D D0    MOV   A,REG[208]
3235: 08       PUSH  A
(1381) 								// Set the outer loop's variable so that we don't loop again.
3236: 62 D0 00 MOV   REG[208],0
3239: 55 D2 01 MOV   [TIMEOUT+1],1
323C: 55 D1 00 MOV   [TIMEOUT],0
(1382) 								j = SERVO_COMM_LOOPS;
323F: 62 DA FD MOV   REG[218],253
3242: 18       POP   A
3243: 60 D0    MOV   REG[208],A
3245: 18       POP   A
3246: 7E       RETI  
(1383) 							}
(1384) 							else
(1385) 							{	
(1386) 								// Set the timeout flag to exit the loop.
_CHILD_2_TIMEOUT_ISR:
3247: 71 C0    OR    F,192
3249: 08       PUSH  A
324A: 5D D0    MOV   A,REG[208]
324C: 08       PUSH  A
(1387) 								TIMEOUT = 1;
324D: 62 D0 00 MOV   REG[208],0
3250: 55 D2 01 MOV   [TIMEOUT+1],1
3253: 55 D1 00 MOV   [TIMEOUT],0
(1388) 							}
3256: 62 DA FD MOV   REG[218],253
3259: 18       POP   A
325A: 60 D0    MOV   REG[208],A
325C: 18       POP   A
325D: 7E       RETI  
(1389) 						}
(1390) 					}
(1391) 				}
(1392) 			}
_CHILD_3_TIMEOUT_ISR:
325E: 71 C0    OR    F,192
3260: 08       PUSH  A
3261: 5D D0    MOV   A,REG[208]
3263: 08       PUSH  A
(1393) 		
3264: 62 D0 00 MOV   REG[208],0
3267: 55 D2 01 MOV   [TIMEOUT+1],1
326A: 55 D1 00 MOV   [TIMEOUT],0
(1394) 			// If we didn't get a good response and haven't written to the flash of the servo,
326D: 62 DA FD MOV   REG[218],253
3270: 18       POP   A
3271: 60 D0    MOV   REG[208],A
3273: 18       POP   A
3274: 7E       RETI  
(1395) 			// force a change in the status return level with an EEPROM write.
(1396) 			if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
(1397) 			{	
(1398) 				flashWrite = 1;
_CHILD_4_TIMEOUT_ISR:
3275: 71 C0    OR    F,192
3277: 08       PUSH  A
3278: 5D D0    MOV   A,REG[208]
327A: 08       PUSH  A
(1399) 				
327B: 62 D0 00 MOV   REG[208],0
327E: 55 D2 01 MOV   [TIMEOUT+1],1
3281: 55 D1 00 MOV   [TIMEOUT],0
(1400) 				// Try to force the return status to what we want.
3284: 62 DA FD MOV   REG[218],253
3287: 18       POP   A
3288: 60 D0    MOV   REG[208],A
328A: 18       POP   A
328B: 7E       RETI  
(1401) 				servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
(1402) 			}
(1403) 		}
(1404) 		
_INIT_TIMEOUT_ISR:
328C: 71 C0    OR    F,192
328E: 08       PUSH  A
328F: 5D D0    MOV   A,REG[208]
3291: 08       PUSH  A
(1405) 		if(status_return_level != STATUS_RET_LEVEL)
3292: 62 D0 00 MOV   REG[208],0
3295: 55 D2 01 MOV   [TIMEOUT+1],1
3298: 55 D1 00 MOV   [TIMEOUT],0
(1406) 		{
329B: 62 DA FD MOV   REG[218],253
329E: 18       POP   A
329F: 60 D0    MOV   REG[208],A
32A1: 18       POP   A
32A2: 7E       RETI  
(1407) 			// Break on purpose to show that the status return is not correct.
(1408) 			while(1) { }
(1409) 		}
(1410) 	}
_WAIT_RECV_TIMEOUT_ISR:
32A3: 71 C0    OR    F,192
32A5: 08       PUSH  A
32A6: 5D D0    MOV   A,REG[208]
32A8: 08       PUSH  A
(1411) 	else
32A9: 62 D0 00 MOV   REG[208],0
32AC: 55 D2 01 MOV   [TIMEOUT+1],1
32AF: 55 D1 00 MOV   [TIMEOUT],0
(1412) 	{
32B2: 62 DA FD MOV   REG[218],253
32B5: 18       POP   A
32B6: 60 D0    MOV   REG[208],A
32B8: 18       POP   A
32B9: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_revolute_evalINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_9
                                   (0022) 
                                   (0023) 
                                   (0024) Dispatch_INTERRUPT_10:
32BA: 08       PUSH  A             (0025) 	push	a
32BB: 50 00    MOV   A,0           (0026) 	mov		a,0
32BD: 47 04 02 TST   [4],2         (0027) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
32C0: B0 3D    JNZ   0x32FE        (0028) 	jnz		Dispatch_INTERRUPT_10_END
32C2: 50 04    MOV   A,4           (0029) 	mov		a,4
32C4: 47 04 04 TST   [4],4         (0030) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
32C7: B0 36    JNZ   0x32FE        (0031) 	jnz		Dispatch_INTERRUPT_10_END
32C9: 50 08    MOV   A,8           (0032) 	mov		a,8
32CB: 47 04 08 TST   [4],8         (0033) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
32CE: B0 2F    JNZ   0x32FE        (0034) 	jnz		Dispatch_INTERRUPT_10_END
32D0: 50 0C    MOV   A,12          (0035) 	mov		a,12
32D2: 47 04 10 TST   [4],16        (0036) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
32D5: B0 28    JNZ   0x32FE        (0037) 	jnz		Dispatch_INTERRUPT_10_END
32D7: 50 10    MOV   A,16          (0038) 	mov		a,16
32D9: 47 04 20 TST   [4],32        (0039) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
32DC: B0 21    JNZ   0x32FE        (0040) 	jnz		Dispatch_INTERRUPT_10_END
32DE: 50 14    MOV   A,20          (0041) 	mov		a,20
32E0: 47 04 40 TST   [4],64        (0042) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
32E3: B0 1A    JNZ   0x32FE        (0043) 	jnz		Dispatch_INTERRUPT_10_END
32E5: 50 18    MOV   A,24          (0044) 	mov		a,24
32E7: 47 04 80 TST   [4],128       (0045) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
32EA: B0 13    JNZ   0x32FE        (0046) 	jnz		Dispatch_INTERRUPT_10_END
32EC: 50 1C    MOV   A,28          (0047) 	mov		a,28
32EE: 47 05 01 TST   [5],1         (0048) 	tst		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
32F1: B0 0C    JNZ   0x32FE        (0049) 	jnz		Dispatch_INTERRUPT_10_END
32F3: 50 20    MOV   A,32          (0050) 	mov		a,32
32F5: 47 04 01 TST   [4],1         (0051) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
32F8: B0 05    JNZ   0x32FE        (0052) 	jnz		Dispatch_INTERRUPT_10_END
32FA: 18       POP   A             (0053) 	pop		a
32FB: 7E       RETI                (0054) 	reti
                                   (0055) ; Stop Code Compressor from breaking table alignment
                                   (0056) ; The next instruction does not get executed.
32FC: 71 00    OR    F,0           (0057) 	Suspend_CodeCompressor
                                   (0058) Dispatch_INTERRUPT_10_END:
32FE: E0 01    JACC  0x3300        (0059) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0060) Dispatch_INTERRUPT_10_TBL:
3300: 18       POP   A             (0061) 	pop		a
3301: 7D 18 C7 LJMP  0x18C7        (0062) 	ljmp	_HELLO_1_ISR
3304: 18       POP   A             (0063) 	pop		a
3305: 7D 13 03 LJMP  0x1303        (0064) 	ljmp	_INIT_RX_ISR
3308: 18       POP   A             (0065) 	pop		a
3309: 7D 0E 5F LJMP  0x0E5F        (0066) 	ljmp	_TX_23_ISR
330C: 18       POP   A             (0067) 	pop		a
330D: 7D 1F 4B LJMP  0x1F4B        (0068) 	ljmp	_CHILD_1_ISR
3310: 18       POP   A             (0069) 	pop		a
3311: 7D 1D 92 LJMP  0x1D92        (0070) 	ljmp	_CHILD_2_ISR
3314: 18       POP   A             (0071) 	pop		a
3315: 7D 1B D9 LJMP  0x1BD9        (0072) 	ljmp	_CHILD_3_ISR
3318: 18       POP   A             (0073) 	pop		a
3319: 7D 1A 20 LJMP  0x1A20        (0074) 	ljmp	_CHILD_4_ISR
331C: 18       POP   A             (0075) 	pop		a
331D: 7D 10 71 LJMP  0x1071        (0076) 	ljmp	_SERVO_TX_ISR
3320: 18       POP   A             (0077) 	pop		a
3321: 7D 0C A6 LJMP  0x0CA6        (0078) 	ljmp	_WAIT_RECV_ISR
                                   (0079) ; Resume Code Compressor.
                                   (0080) ; The next instruction does not get executed.
3324: 38 00    ADD   SP,0          (0081) 	Resume_CodeCompressor
                                   (0082) 
                                   (0083) Dispatch_INTERRUPT_11:
3326: 08       PUSH  A             (0084) 	push	a
3327: 50 00    MOV   A,0           (0085) 	mov		a,0
3329: 47 04 02 TST   [4],2         (0086) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
332C: B0 13    JNZ   0x3340        (0087) 	jnz		Dispatch_INTERRUPT_11_END
332E: 50 04    MOV   A,4           (0088) 	mov		a,4
3330: 47 04 08 TST   [4],8         (0089) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3333: B0 0C    JNZ   0x3340        (0090) 	jnz		Dispatch_INTERRUPT_11_END
3335: 50 08    MOV   A,8           (0091) 	mov		a,8
3337: 47 04 01 TST   [4],1         (0092) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
333A: B0 05    JNZ   0x3340        (0093) 	jnz		Dispatch_INTERRUPT_11_END
333C: 18       POP   A             (0094) 	pop		a
333D: 7E       RETI                (0095) 	reti
                                   (0096) ; Stop Code Compressor from breaking table alignment
                                   (0097) ; The next instruction does not get executed.
333E: 71 00    OR    F,0           (0098) 	Suspend_CodeCompressor
                                   (0099) Dispatch_INTERRUPT_11_END:
3340: E0 01    JACC  0x3342        (0100) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0101) Dispatch_INTERRUPT_11_TBL:
3342: 18       POP   A             (0102) 	pop		a
3343: 7D 17 6E LJMP  0x176E        (0103) 	ljmp	_HELLO_2_ISR
3346: 18       POP   A             (0104) 	pop		a
3347: 7D 0F 38 LJMP  0x0F38        (0105) 	ljmp	_TX_014_ISR
334A: 18       POP   A             (0106) 	pop		a
334B: 7D 11 4A LJMP  0x114A        (0107) 	ljmp	_RX8_2_ISR
                                   (0108) ; Resume Code Compressor.
                                   (0109) ; The next instruction does not get executed.
334E: 38 00    ADD   SP,0          (0110) 	Resume_CodeCompressor
                                   (0111) 
                                   (0112) Dispatch_INTERRUPT_9:
3350: 08       PUSH  A             (0113) 	push	a
3351: 50 00    MOV   A,0           (0114) 	mov		a,0
3353: 47 04 02 TST   [4],2         (0115) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3356: B0 36    JNZ   0x338D        (0116) 	jnz		Dispatch_INTERRUPT_9_END
3358: 50 04    MOV   A,4           (0117) 	mov		a,4
335A: 47 04 04 TST   [4],4         (0118) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
335D: B0 2F    JNZ   0x338D        (0119) 	jnz		Dispatch_INTERRUPT_9_END
335F: 50 08    MOV   A,8           (0120) 	mov		a,8
3361: 47 04 08 TST   [4],8         (0121) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3364: B0 28    JNZ   0x338D        (0122) 	jnz		Dispatch_INTERRUPT_9_END
3366: 50 0C    MOV   A,12          (0123) 	mov		a,12
3368: 47 04 10 TST   [4],16        (0124) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
336B: B0 21    JNZ   0x338D        (0125) 	jnz		Dispatch_INTERRUPT_9_END
336D: 50 10    MOV   A,16          (0126) 	mov		a,16
336F: 47 04 20 TST   [4],32        (0127) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
3372: B0 1A    JNZ   0x338D        (0128) 	jnz		Dispatch_INTERRUPT_9_END
3374: 50 14    MOV   A,20          (0129) 	mov		a,20
3376: 47 04 40 TST   [4],64        (0130) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
3379: B0 13    JNZ   0x338D        (0131) 	jnz		Dispatch_INTERRUPT_9_END
337B: 50 18    MOV   A,24          (0132) 	mov		a,24
337D: 47 04 80 TST   [4],128       (0133) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
3380: B0 0C    JNZ   0x338D        (0134) 	jnz		Dispatch_INTERRUPT_9_END
3382: 50 1C    MOV   A,28          (0135) 	mov		a,28
3384: 47 04 01 TST   [4],1         (0136) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
3387: B0 05    JNZ   0x338D        (0137) 	jnz		Dispatch_INTERRUPT_9_END
3389: 18       POP   A             (0138) 	pop		a
338A: 7E       RETI                (0139) 	reti
                                   (0140) ; Stop Code Compressor from breaking table alignment
                                   (0141) ; The next instruction does not get executed.
338B: 71 00    OR    F,0           (0142) 	Suspend_CodeCompressor
                                   (0143) Dispatch_INTERRUPT_9_END:
338D: E0 01    JACC  0x338F        (0144) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0145) Dispatch_INTERRUPT_9_TBL:
338F: 18       POP   A             (0146) 	pop		a
3390: 7D 32 19 LJMP  _HELLO_TIMEOUT_ISR(0147) 	ljmp	_HELLO_TIMEOUT_ISR
3393: 18       POP   A             (0148) 	pop		a
3394: 7D 32 8C LJMP  _INIT_TIMEOUT_ISR(0149) 	ljmp	_INIT_TIMEOUT_ISR
3397: 18       POP   A             (0150) 	pop		a
3398: 7D 32 02 LJMP  _TX_01234_TIMEOUT_ISR(0151) 	ljmp	_TX_01234_TIMEOUT_ISR
339B: 18       POP   A             (0152) 	pop		a
339C: 7D 32 30 LJMP  _CHILD_1_TIMEOUT_ISR(0153) 	ljmp	_CHILD_1_TIMEOUT_ISR
339F: 18       POP   A             (0154) 	pop		a
33A0: 7D 32 47 LJMP  _CHILD_2_TIMEOUT_ISR(0155) 	ljmp	_CHILD_2_TIMEOUT_ISR
33A3: 18       POP   A             (0156) 	pop		a
33A4: 7D 32 5E LJMP  _CHILD_3_TIMEOUT_ISR(0157) 	ljmp	_CHILD_3_TIMEOUT_ISR
33A7: 18       POP   A             (0158) 	pop		a
33A8: 7D 32 75 LJMP  _CHILD_4_TIMEOUT_ISR(0159) 	ljmp	_CHILD_4_TIMEOUT_ISR
33AB: 18       POP   A             (0160) 	pop		a
33AC: 7D 32 A3 LJMP  _WAIT_RECV_TIMEOUT_ISR(0161) 	ljmp	_WAIT_RECV_TIMEOUT_ISR
                                   (0162) ; Resume Code Compressor.
                                   (0163) ; The next instruction does not get executed.
                                   (0164) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
